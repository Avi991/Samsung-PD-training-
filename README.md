# Samsung-PD-training-
## Day-0-Installation

 <details>
 <summary> ICC2 </summary>

It appears that "icc2 compiler" might refer to an abbreviation of "Intel C++ Compiler 2," which would be the second version of Intel's C++ compiler. Intel's C++ Compiler is a tool used to compile C and C++ programs, optimizing them for Intel processors and architectures. It offers features like advanced vectorization, parallelization, and optimization techniques to enhance the performance of code on Intel-based systems.

I installed ICC2 using the following commands and Below is the screenshot showing sucessful launch:

<img width="1085" alt="ICC2" src="https://github.com/Avi991/Samsung-PD-training-/blob/cbd01432461cd5fbbf5f74a0625776a4dc6b082d/Samsung_PD_%23day0/icc2.png">
</details>
------------------------------

<details>
 <summary> lc_shell </summary>

LC_shell, also known as Design Compiler Graphical, is a part of the Synopsys suite of Electronic Design Automation (EDA) tools. It's used in the digital design flow for logic synthesis and optimization. Design Compiler Graphical is an advanced version of the original Design Compiler tool, providing additional features and a more user-friendly graphical interface.
I invoked lc_shell using the following commands and Below is the screenshot showing sucessful launch:

<img width="1085" alt="lc_shell" src="https://github.com/Avi991/Samsung-PD-training-/blob/cbd01432461cd5fbbf5f74a0625776a4dc6b082d/Samsung_PD_%23day0/lc.png">
</details>
-------------------------------
<details>
 <summary>dc_shell</summary>
Design Compiler is the command line interface of Synopsys synthesis tool. It includes innovative topographical technology that enables a predictable flow resulting in faster time to results.It is invoked using the command dc_shell    

Below is the screenshot showing the successful launch:

<img width="1085" alt="dc_shell" src="https://github.com/Avi991/Samsung-PD-training-/blob/857bc676cc691d6f1ca6e79cda309159fe38d58e/training_1/dc.png">
</details>

------------------------------

<details>
 <summary> pt_shell </summary>

"PrimeTime" is a widely used Electronic Design Automation (EDA) tool developed by Synopsys. It is used for static timing analysis, which is a crucial step in the digital design flow to ensure that the design meets its timing requirements. The "PrimeTime Shell" is the user interface through which engineers interact with the PrimeTime tool to perform timing analysis and optimization.
I invoked pt_shell using the following commands and Below is the screenshot showing sucessful launch:

<img width="1085" alt="pt_shell" src="https://github.com/Avi991/Samsung-PD-training-/blob/cbd01432461cd5fbbf5f74a0625776a4dc6b082d/Samsung_PD_%23day0/pt.png">
</details>



## Day-1-Introduction to Verilog RTL Design and Synthesis
<details>
 <summary> Introduction to RTL-Design, Test-bench, Simulators </summary>
-RTL Design : The RTL Design stands for Register Transfer Language. It sits between the high-level system specification and the lower-level gate-level implementation. This is a design abstraction which models the flow of digital signals between hardware registers, and the logical operations performed on those signals. RTL is preferred because it is easy to understand and implement compared to structural and behavioral models.

-HDL : A hardware description language (HDL) enables a precise, formal description of an electronic circuit that allows for the automated analysis and simulation of an electronic circuit.

-Simulator : Simulator is the tool used for checking adherence to the specification by simulating the design. iverilog is the tool used for RTL simulation. A simulator looks for change in the input signals and when no change in input, the output also doesn't change. It produces an output in the form of a .vcd file.

-Design : Design is the actual verilog code or set of Verilog codeswhich has the intended functionality to meet the required specifications. Design may have one or more primary inputs or primary outputs.  RTL design is the behavioral representation of the required specification.

<summary> Labs on examples of iverilog and gtkwave </summary>
We made a directory namely VLSI and inside that directory we cloned vsdflow and sky130RTLDesignAndSynthesisWorkshop repository. This repository consists of the required .lib files and verilog codes and its testbenches for practice.
I installed the needed tools and attached the required screenshots:

</details>

 
Below is the output wave form in gtkwave generated by performing a simulation of good_mux using iverilog.

The syntax of the code is: iverilog <RTL_code> <Its_Testbench>
 <details>
 <summary> GTK Wave </summary>

GTKWave is an open-source waveform viewer and analyzer primarily used in digital design and electronic design automation (EDA) workflows. It allows users to visualize and analyze the waveforms generated by digital simulations, making it a valuable tool for debugging and verifying digital designs.

I installed GTKwave using the following commands and Below is the screenshot showing sucessful launch:

<img width="1085" alt="GTKwave" src="https://github.com/Avi991/Samsung-PD-training-/blob/cbd01432461cd5fbbf5f74a0625776a4dc6b082d/Samsung_PD_%23day1/4.png">
</details>
<details>
 <summary> Yosys </summary>
Yosys is an open-source framework for Verilog RTL synthesis. RTL stands for Register Transfer Level, which is a high-level abstraction used to describe digital circuits at the level of registers and their interactions. Yosys is primarily used in the digital design and electronic design automation (EDA) community to convert RTL descriptions of digital circuits, written in languages like Verilog or SystemVerilog, into a netlist representation that can be further optimized, analyzed, and eventually implemented in hardware.

I installed Yosys using the following commands and Below is the screenshot showing sucessful launch:

<img width="1085" alt="yosys" src="https://github.com/Avi991/Samsung-PD-training-/blob/cbd01432461cd5fbbf5f74a0625776a4dc6b082d/Samsung_PD_%23day1/5.png">
</details>
<details>
<summary>Labs on Yosys </summary>
 We were given the overview of this tool and the basic files required to perform the experiment on 2:1 MUX. 
 
 **Procedure** : First we need to read the liberty file using the code
 
 **read_liberty -lib <path of the .lib>**
 
 Then we need read the RTL Design code

 **read_verilog <RTL_Design_file>**

 After this we need to perform synthesis 

 **synth -top <instance_name>**
 
 generating netlist

 **abc -liberty <.lib path>**
 
This Netlist can be viewed in the synthesized circuit form using the **show** command    

<img width="1085" alt="ckt" src="https://github.com/Avi991/Samsung-PD-training-/blob/d0c56f29c950594bf4d7302ad2fca09563c63e3c/Samsung_PD_%23day1/6.png">
<img width="1085" alt="ckt" src="https://github.com/Avi991/Samsung-PD-training-/blob/d0c56f29c950594bf4d7302ad2fca09563c63e3c/Samsung_PD_%23day1/7.png">
<img width="1085" alt="ckt" src="https://github.com/Avi991/Samsung-PD-training-/blob/d0c56f29c950594bf4d7302ad2fca09563c63e3c/Samsung_PD_%23day1/8.png">
<img width="1085" alt="ckt" src="https://github.com/Avi991/Samsung-PD-training-/blob/d0c56f29c950594bf4d7302ad2fca09563c63e3c/Samsung_PD_%23day1/9.png">
<img width="1085" alt="ckt" src="https://github.com/Avi991/Samsung-PD-training-/blob/d0c56f29c950594bf4d7302ad2fca09563c63e3c/Samsung_PD_%23day1/9a.png">

Simplified Netlist code 
<img width="1085" alt="netlist" src="https://github.com/Avi991/Samsung-PD-training-/blob/d0c56f29c950594bf4d7302ad2fca09563c63e3c/Samsung_PD_%23day1/9b.png">
</details>

## Day-2-Introduction to Timing libraries, Hierarchical vs flat synthesis, and flip flop coding
<details>
	
 <summary> Introduction to Timing Library File (.Lib),Hierarchical vs Flat Synthesis </summary>
 
Liberty File(.lib) contains all std cells used in IC design their specifications are stored in .lib file. Also, Liberty File(.lib) consists of ASCII representations of Timing, Area, and Power associated with the Standard cell. The Naming convention in the timing file follows technology node and PVT format (Process, Voltage, Temperature).The Standard library used in our case was sky130_fd_sc_hd_tt_025C_1v8, File description 130 depicts technology node 130nm process is typical(tt), temperature is 25C, and 1v8 represents the 1.8V Voltage .
Screenshot of a standard library file shown below: 
<img width="1085" alt="lib" src="https://github.com/Avi991/Samsung-PD-training-/blob/e80dfe2463278a272ef026609f0bf2b1e7826dc4/Samsung_PD_%23day2/2.png">
	
The Liberty File also consists of the technology used for standard cells as in the above example it is CMOS, it also specifies the delay model, unit of time, unit of voltage, unit of resistance, and many other units.
All the data i.e std cells delays, leakage power, capacitance is stored in form of lookup tables(LUTs). For each gate cell based on the number of inputs(N), there will be 2^N combinations, and for each combination leakage power, area, delay, and all related parameters are mentioned. 

The timing file consists of many different variations of the same gate cells. As we move toward faster cell (cell with higher drive strength) the area and power increases. In liberty file area, power, timing values are given for same cell of different drive strength and it also consist if the inform about leakage power of all the possible logic of different configration shown below.
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/e80dfe2463278a272ef026609f0bf2b1e7826dc4/Samsung_PD_%23day2/2.png">
</details>

<details>
 <summary> Hierarchical vs Flat synthesis in Yosys </summary>
Hierarchical synthesis : The basic flow of hierarchical design is Dividing a design into multiple blocks (i.e. sub-chips, sub-blocks, modules, hierarchical blocks, etc.) which can also be user defined. Hierarchial design has blocks, subblocks in an hierarchy.
In Yosys we have done synthesis of a multimodule combinational circuit which consists of two sub_modules one that of ** AND ** gate and other of ** OR ** gate. Below is the RTL Design code of multimodules is gvien below:
	<img width="1085" alt="lib" src="https://github.com/Avi991/Samsung-PD-training-/blob/e80dfe2463278a272ef026609f0bf2b1e7826dc4/Samsung_PD_%23day2/4.png">

We do synthesis in yosys it generates the following gate level netlist :

<img width="1085" alt="lib" src="https://github.com/Avi991/Samsung-PD-training-/blob/e80dfe2463278a272ef026609f0bf2b1e7826dc4/Samsung_PD_%23day2/5(synthesis).png">

The yosys considers the module hierarchy and does mapping according to the instantiation i.e by using sub blocks.The netlist code for hierarchical implementation of the multiple_modules.

<img width="1085" alt="lib" src="https://github.com/Avi991/Samsung-PD-training-/blob/e80dfe2463278a272ef026609f0bf2b1e7826dc4/Samsung_PD_%23day2/7(synthesisize%20hier).png">

In the netlist it can observed that separate modules namely sub_module1 sub_module2 are created  i.e submodules are getting instanstiated not the std cells present in library

<img width="1085" alt="lib" src="https://github.com/Avi991/Samsung-PD-training-/blob/e80dfe2463278a272ef026609f0bf2b1e7826dc4/Samsung_PD_%23day2/6(show%20hier).png">

Flat synthesis : In Flat synthesis the hierarchies the flattened out and every submodule is created using std cells. We apply flat synthesis on the same design mentioned above. The command used to perform Flat synthesis from yosys are as follows :

--- read_liberty -lib <path of the .lib>

--- read_verilog <RTL_file>

--- synth -top <instance_name>

--- abc -liberty <.lib_path>

--- flatten

--- write_verilog -noattr <.v_File_name>
The synthesized circuit for a flattened netlist is shown in the below: 
<img width="1085" alt="lib" src="https://github.com/Avi991/Samsung-PD-training-/blob/e80dfe2463278a272ef026609f0bf2b1e7826dc4/Samsung_PD_%23day2/8(synthesized%20op%20flat).png">
<img width="1085" alt="lib" src="https://github.com/Avi991/Samsung-PD-training-/blob/e80dfe2463278a272ef026609f0bf2b1e7826dc4/Samsung_PD_%23day2/9(show%20flat).png">
</details>

<details>
 <summary> Flip-flop Coding Styles </summary>
 Flip-flops :A flip-flop is a sequential digital electronic circuit having two stable states that can be used to store one bit of binary data. Flip-flops are the fundamental building blocks of all memory devices.

 The complexity of cobinational circuit increases the chance of glitch, hence FFs are used to avoid it and it stable output.

 Asynchronous Reset D Flop: 
 
 Here the output signal goes low when the reset signal is high , irrespective of the clock's edge(+ve,-ve edge ).
 RTL code of positive edge trigerred asynchronous reset D FF:
 ```
module dff_asyncres ( input clk ,  input async_reset , input d , output reg q );
	always @ (posedge clk , posedge async_reset)
	begin
		if(async_reset)
			q <= 1'b0;
		else	
			q <= d;
	end
endmodule
```
Its gtkwave :<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/b3717ddc1a24961d4e335d766f7df6fea792b6b1/Samsung_PD_%23day2/10(dff_async_gtk).png">
Its Yosys synthesised netlist:
<img width="1085" alt="lib1" src="https://github.com/Luffy-7744/Samsung-PD-Training-/blob/7b832441e73dd5c5bc078425a1f34ee4dea508fd/PD%23Day2/asyn_rst_synth.png">

Asynchronous set D Flop:

Here the output signal goes high when the reset signal is high , irrespective of the clock's edge(+ve,-ve edge ).
 RTL code of positive edge trigerred asynchronous set D FF:
 ```
module dff_async_set ( input clk ,  input async_set , input d , output reg q );
	always @ (posedge clk , posedge async_set)
	begin
		if(async_set)
			q <= 1'b1;
		else
			q <= d;
	end
endmodule
```
Its GTKwave :
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/b3717ddc1a24961d4e335d766f7df6fea792b6b1/Samsung_PD_%23day2/11(async_set).png">

Its Yosys synthesised netlist:
we used **dfflibmap -liberty** <> command to look from only flop library to for d flip flops
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/5dac4460dd9d997d4620d6b16521449a1ec30edd/Samsung_PD_%23day2/12(map).png">
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/5dac4460dd9d997d4620d6b16521449a1ec30edd/Samsung_PD_%23day2/13(dff%20net).png">

Its GTKwave :
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/5dac4460dd9d997d4620d6b16521449a1ec30edd/Samsung_PD_%23day2/11(async_set).png">

Its Yosys synthesised netlist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/5dac4460dd9d997d4620d6b16521449a1ec30edd/Samsung_PD_%23day2/14(async%20set%20netl).png">


Synchronous reset D Flop :

The reset depend on the clock edge. Here the output signal goes low whenever the reset signal is high and at the clock edge(positive or negative)
RTL code of positive edge trigerred synchronous reset D FF:
```
module dff_syncres ( input clk , input async_reset , input sync_reset , input d , output reg q );
	always @ (posedge clk )
	begin
		if (sync_reset)
			q <= 1'b0;
		else	
			q <= d;
	end
endmodule
```
Its GTKwave :
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/d249e61b0031a5effcc73aa6e54e0459942414af/Samsung_PD_%23day2/synch%20res%20gtk.png">

Its Yosys synthesised netlist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/d249e61b0031a5effcc73aa6e54e0459942414af/Samsung_PD_%23day2/sync%20net.png">
</details>

<details>
 <summary> Optimization Techniques </summary>
	
 The Optimization involves the reducing hardware in the design such that to improve area, power and speed. Two example where given:
 1. a*2
Consider a case where 3 bit number is multiplied by 2 in this case we dont need any additional hardware and only needs connecting bits to the output and grounding the LSB bit,same is realized by yosys. When binary number is multiplied by 2^n then result will gave same number by appending zero in LSB by n times.
RTL code:
	
```
	module mul2 (input [2:0] a, output [3:0] y);
	assign y = a * 2; // assign y={a,1'b0}
	endmodule
```

Yosys Synthesis result : 
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/4aa1beeae13c1dcd880195cfe9758467617731a4/Samsung_PD_%23day2/15(mult%20%20synth).png">

 2. a*9
Multiplying a 3 bit number by 9, gives results as concatination of same number twice {a,a}.
a*[8+1]= {a,0,0,0} + a(3bit)={a,a}

RTL code:

```
module mul8 (input [2:0] a, output [5:0] y);
	assign y = a * 9; // assign y={a,a}
endmodule
```

Yosys Synthesis result :

<img width="1085" alt="lib8" src="https://github.com/Avi991/Samsung-PD-training-/blob/4aa1beeae13c1dcd880195cfe9758467617731a4/Samsung_PD_%23day2/16(mult8).png">

</details>

## Day-3- Combinational and sequential optmizations
![dffconst(net)](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/43154f44-cfb6-459d-ae97-45873fef14df)

<details>
 <summary> Combinational Optimization </summary>
Optimising the combinational logic circuit means squeezing the logic to get the most optimized digital design so that optimized circuit area and power is saved. Various techniques and gives us the most optimized circuit.Implemented using synthesis tools
Command to optimize the circuit by yosys is ** yosys> opt_clean -purge ** to remove unused nets
We have done synthesis using yosys for few examples:
	![dffconst(net)](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/43154f44-cfb6-459d-ae97-45873fef14df)

**Example 1**
```
module opt_check (input a , input b , output y);
	assign y = a?b:0;
endmodule
```
yosys generated netlist :
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/opt1.png">
From the output we inferred that above mux implementation can be optimized to two input AND gate

**Example 2**
```
module opt_check2 (input a , input b , output y);
	assign y = a?1:b;
endmodule
```
yosys generated netlist :
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/opt2.png">
From the output we inferred that above mux implementation can be optimized to two input OR gate which is also realised using inverter and NAND gate as stacking of PMOS will result in more area

**Example 3**
```
module opt_check3 (input a , input b, input c , output y);
	assign y = a?(c?b:0):0;
endmodule
```
yosys generated netlist :
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/opt3.png"> 
From the output we inferred that above mux implementation can be optimized to 3 input gate

**Example 4**
```
module opt_check4 (input a , input b , input c , output y);
	assign y = a?(b?(a & c ):c):(!c);
endmodule
```
yosys generated netlist :
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/opt4.png">   
From the output we inferred that above mux implementation can be optimized to two input xnor gate

**Example 5**
Here there is multiple modules present so we will verify whether those module are being used or not and we use flatten for submudules commands to perform that
**read_liberty -lib <library_path>**
**read_verilog <verilog_file>**
**synth -top <module_name>**
**opt_clean -purge**
**abc -liberty <library_path>**
**flatten**
```
module sub_module1(input a , input b , output y);
	 assign y = a & b;
	endmodule

	module sub_module2(input a , input b , output y);
	 assign y = a^b;
	endmodule

	module multiple_module_opt(input a , input b , input c , input d , output y);
	wire n1,n2,n3;
	sub_module1 U1 (.a(a) , .b(1'b1) , .y(n1));
	sub_module2 U2 (.a(n1), .b(1'b0) , .y(n2));
	sub_module2 U3 (.a(b), .b(d) , .y(n3));

	assign y = c | (b & n1); 
	endmodule
```
Generated nelist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/mult_opt1.png"> 
Sub module 1 is an AND gate , Sub module 2 is an OR gate once optimization is done

**Example 6**

```
module sub_module(input a , input b , output y);
	assign y = a & b;
endmodule

module multiple_module_opt2(input a , input b , input c , input d , output y);
	wire n1,n2,n3;
	sub_module U1 (.a(a) , .b(1'b0) , .y(n1));
	sub_module U2 (.a(b), .b(c) , .y(n2));
	sub_module U3 (.a(n2), .b(d) , .y(n3));
	sub_module U4 (.a(n3), .b(n1) , .y(y));
endmodule
```

Generated nelist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/mult_opt2.png">   Sub module is an and gate after realization output comes out to be zero
</details>

<details>
 <summary> Sequential Optimization </summary>
There are various techniques for Sequential Logic Optimization

    - Sequentialal constant propagation

    - Advanced

        - State Optimization

        - Retiming

        - Sequential Logic cloning

Sequential Constant Propogation

For understanding we took asynchronous reset D Flip-flop is fed with d = 0(i.e GND) always so the output will always be 0 irrespective of the clock or circuit.

Advanced

State Optimisation: This is optimisation of unused state. Using this technique we can come up with most optimised state machine.

Cloning : It is an optimization technique that replicates a cell to reduce the load on heavily loaded cell. This technique is usually preffered while performing PHYSICAL AWARE SYNTHESIS. Lets consider a flop A which is connected to flop B and flop C through a combination logic. If B and C are placed far from A in the floorplan, there is a routing path delay. To avoid this, we connect A to two intermediate flops and then from these flops the output is sent to B and C thereby decreasing the delay. This phenomenon is called cloning since we are generating two new flops with same functionality as A.

Retiming : Sequential circuits can be optimised by retiming. The combinational section of the circuitry is unaffected as it only rearranges the registers in the circuit. It is a powerful sequential optimization technique used to move registers across the combinational logic or to optimize the number of registers to improve performance via power-delay trade-off, without changing the input-output behavior of the circuit.

**Example 1**
```
module dff_const2(input clk, input reset, output reg q);
	always @(posedge clk, posedge reset)
	begin
		if(reset)
			q <= 1'b1;
		else
			q <= 1'b1;
	end
endmodule
```
GTK Wave:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst1(gtkwave).png">   


Yosys generated netlist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst(net).png">   
As we know the above code is for a d flipflop with an asynchronous reset this is used to reset the system asynchronously and later the system comes into normal oprtaion for next 1 clk that is synchronously so this system cannot be further optimized and a flipflop is generated 

**Example 2**
```
module dff_const2(input clk, input reset, output reg q);
	always @(posedge clk, posedge reset)
	begin
		if(reset)
			q <= 1'b1;
		else
			q <= 1'b1;
	end
endmodule
```
GTK Wave:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst2(gtkwave).png">


Yosys generated netlist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst2(net).png">
From the output we can say the optimization can be done as the q value is always 1 hence no flop is generated and the optimization is done

**Example 3**
```
module dff_const3(input clk, input reset, output reg q);
	reg q1;

	always @(posedge clk, posedge reset)
	begin
		if(reset)
		begin
			q <= 1'b1;
			q1 <= 1'b0;
		end
		else
		begin
			q1 <= 1'b1;
			q <= q1;
		end
	end
	endmodule
```

GTK Wave:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst3(gtkwave).png">   


Yosys generated netlist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst3(net).png">   

**Example 4**
```
module dff_const4(input clk, input reset, output reg q);
	reg q1;

	always @(posedge clk, posedge reset)
	begin
		if(reset)
		begin
			q <= 1'b1;
			q1 <= 1'b1;
		end
	else
		begin
			q1 <= 1'b1;
			q <= q1;
		end
	end
	endmodule
```

GTK Wave:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst4(gtkwave).png">   


Yosys generated netlist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst4.png"> 

**Example 5**
```
module dff_const5(input clk, input reset, output reg q);
	reg q1;
	always @(posedge clk, posedge reset)
		begin
			if(reset)
			begin
				q <= 1'b0;
				q1 <= 1'b0;
			end
		else
			begin
				q1 <= 1'b1;
				q <= q1;
			end
		end
	endmodule
```
GTK Wave:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffcosnt5(gtkwave).png">   


Yosys generated netlist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst5(net).png"> 
No scope of further optimization as the outputs a constant value is seen in all conditions therefore two flipflops getting generated
</details>


<details>
 <summary> Optimization Examples </summary>
	
**Example 1**
```
   module counter_opt (input clk , input reset , output q);
   reg [2:0] count;
   assign q = count[0];
   always @(posedge clk ,posedge reset)
   begin
   	if(reset)
   		count <= 3'b000;
   	else
   		count <= count + 1;
   end
   endmodule
```
   
GTK wave:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/gtkwave(counter%20opt).png"> 

Yosys generated netlist
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/count_opt(netlist).png">
As the 0th bit is only used for the output hence during the synthesis only one flipflop is generated with inverter for the toggle oprtaion 
Remaining bits are unused so their respective flops are not generated
</details>

## Day-4- GLS Blocking vs Non-Blocking And Synthesis-Simulation Mismatch 
<details>
<summary> GLS Concepts And Flow Using Iverilog </summary>

-- What is GLS- Gate Level Simulation?:
GLS is generating the simulation output by running test bench with netlist file generated from synthesis as design under test. Netlist is logically same as RTL code, hence, same test bench can be used for it.

-- Why GLS?:
We perform this to verify logical correctness of the design after synthesizing it. 

If GLS is run with delay annotion then it can be used for timing analysis 

**Synthesis Simulation Mismatch** 

Synthesis simulation mismatch denotes the discrepancy between the actual behavior of a circuit as simulated during design and its real-world performance after synthesizing the design. 

Synthesis simulation mismatched are mainly caused because of the following reasons 

- Missing sensitivity list
- Blocking vs Non Blocking assignments
- Non standard verilog code

**Missing sensitivity list**
The absence of a complete sensitivity list in VLSI design can give rise to problems. In hardware description languages (HDL) like Verilog, a sensitivity list is utilized to specify the inputs that should activate the execution of a specific process or code block. Inadequate or missing signals in the sensitivity list can lead to inaccurate or unforeseen behavior of the circuit during synthesis or simulation. Ensuring an accurate representation of inputs impacting the logic within a process is vital.

As the synthesizer does not look for sensitivity list and it looks only statements in the procedural block , it infers correct circuit and if we simulate the netlist code , there will be synthesis simulation mismatch. In to order tackle this issue this issue it is important to check the behaviour of the circuit first and then match it with the expected output seen in the simulation. 

**Blocking Vs Non Blocking Assignments**

Blocking statements execute the will wait for the current one to finish.i.e. sequentially inside the always block. 
Non-Blocking statements execute all the assignment parallelly inside a always block.First all the RHS is evaluated and then assigned
This will give mismatch as sometimes, improper use of blocking statements can create latches. 

Missing sensitivity list in always block:
Lets take example of mux having inputs as i0,i1 and sel and output as y.
```
always @(sel)                  always @(*)
//It will infer a latch        // It will infer a mux.
```
If i0 and i1 change in activity will not be reflected in always block.
To avoid the synthesis and simulation mismatch. It is very important to check the behaviour of the circuit first and then match it with the expected output seen in simulation and make sure there are no synthesis and simulation mismatches. This is why we use GLS.
</details>

<details>
<summary> LABs </summary>
	
**Case 1**

```
module ternary_operator_mux (input i0 , input i1 , input sel , output y);
   assign y = sel?i1:i0;
endmodule
```
Gtkwave :
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/rtlgtk1.png">

Hardware
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/ter_mux2.png">

Yosys result: 
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/ter_net.png">

GLS Simulation:
I used the below commands to carry out GLS of ternary_operator_mux.v:
```
iverilog <path to verilog model: ../mylib/verilog_model/primitives.v> <path to sky130_fd_sc_hd__tt_025C_1v80.lib: ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib> <name netlist: ternary_operator_mux_net.v> <name testbench: tb_ternary_operator_mux.v>
./a.out
gtkwave tb_ternary_operator_mux.vdc
```
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/gls%20_ter.png">

In this example there is no mismatch between the RTL Design simulated wave and Netlist simulated wave.

**Case 2**
```
module bad_mux (input i0 , input i1 , input sel , output reg y);
	always @ (sel)
	begin
		if(sel)
			y <= i1;
		else 
			y <= i0;
	end
endmodule
```
Gtkwave:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/badmux%20gtk.png">

Hardware
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/badmux%20rep.png">

GLS Simulation:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/bad_gls%20gtk.png">

From the output we can infer the netlist simulation which corrects the bad_mux design which was only changing waveform when sel was triggered while for a mux to work properly it should be sensitivity to all the input signals. No change in activities of input signal is recorded
On comapring the simulation reults it is observed that the RTL simulation and GLS is totally different

**Case 3**
```
module blocking_caveat (input a , input b , input  c, output reg d); 
reg x;
always @ (*)
	begin
	d = x & c;
	x = a | b;
end
endmodule
```
From the above code it's found that q0 value (previous) which is not updated which appears a flop delay hence the output is one clock cycle delayed which is observed in the simulation result 

Gtkwave:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/blocking%20cav%20gtk.png">

Hardware
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/block%20rep.png">

GLS Simulation:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/blockgtk_gls.png">

The GLS we can see the output is different from that of the Simulation result there is flop delay visible and we got the output to be a proper OR & AND gated output. To avoid this kind of issue we are supposed to run the GLS to make sure there are no Synthesis and SImulation mismatches

</details>

## Day-6-Introduction to logic synthesis in DC

<details>
<summary> Introduction </summary>

**Synthesis**
-RTL to Gate level translation.

-The design is converted inta gate and connections are made betn the gates.

-INPUT to Synthesis :     (1) RTL    (2) .lib

**Contents of .lib**
A typical Liberty file contains detailed information about the behaviour of standard cells, including :
    *Timing Information : This includes delay, transition and capacitance values associated with the standard cells. Timing information specifies how the cells behave under different input conditions.
    
    *Optimization : Synthesis tools perform optimization to improve the design's performance, area, and power consumption.Logic optimization algorithms identify redundant logic and simplify the gate-level 
     representation to achieve a more efficient implementation.
     
    *Technology Mapping : During synthesis, the design is mapped to a specific target technology library that contains the available gates and flip-flops for the manufacturing process being used (e.g., 28nm, 
      7nm, etc.).The choice of gates from the library is critical in determining the final characteristics of the integrated circuit.
      
    *Power Information : Liberty file also provides data on power consumption , including static power and dynamic power characteristics. This information is crucial for optimizing the power consumption in IC.
  
    *Functional Behaviour : Descriptions of the logical functionality of standard cells, such as input and output pins and logical equations and any additional attributesthat define their operation.
    
    *Operating Conditions : Liberty files may include information about different operating condition in terms of process , voltage and temperature under which all cells are characterized.
     
    *Output for Further Stages : The gate-level netlist produced by synthesis serves as the input for subsequent stages of the design flow, including physical design, place-and-route, and manufacturing.
    

**Need of Liberty files**:

Timing Analysis : EDA tools use Liberty files to perform static timing analysis, ensuring that the IC design meets specified timing constraints. This is critical for achieving desired performance targets.

Power Optimization : Power consumption is a significant concern in modern IC design. Liberty files provide power data that allows designers to optimize power usage and meet energy efficiency goals.

Design Closure : During the design process, designers use Liberty files to guide the synthesis, placement, and routing of standard cells. The data in these files helps achieve design closure by ensuring that the design meets performance, power, and area targets.

Variability Handling : Variability in manufacturing processes can impact the behavior of standard cells. Liberty files may include data for different process corners to account for manufacturing variations.


**Constraints**
Constraints are the instructions that the designer apply during various step in VLSI chip implementation, such as logic synthesis, clock tree synthesis, Place and Route, and Static Timing Analysis. They define what the tools can or cannot do with the design or how the tool behaves. In VLSI design, constraints are essential parameters and limitations that guide the development process to ensure that the resulting integrated circuits (ICs) meet specific performance, timing, and functionality requirements. These constraints play a crucial role in achieving a successful VLSI design.

</details>

<details>
<summary> DC Complier </summary>

Design Compiler ,  is a high-level synthesis tool developed by Synopsys, a leading provider of EDA solutions. It plays a pivotal role in the process of designing complex integrated circuits (ICs) and is an integral part of modern VLSI design flows.

Important terms used

- Synopsys Design Constraints(SDC) : These are the design constraints which are supplied to DC to enable appropriate optimization suitable for achieving the best implementation.
- .lib : Design Library which contains the Standard cells.
- .db : Same as .lib but in a different format. DC understands libraries in .db format
- .ddc : Synopsys propreitary format for storing the design information. DC can write out and read in DDC.
- Design : RTL files which has the behavioral model of the design.

```
        Step 1     Read STD Cell/tech.lib
			 
	Step 2	Read Design (Verilog and Design.lib)
			 
	Step 3	Read SDC
			 
	Step 4	Link the Design
			 
	Step 5	Synthesize
			 
        Step 6  Generate Report and analyse QoR
			 
        Step 7  Write out the Netlist
```

The DC compiler does not understand .lib , so the .lib is converted to .db format. lib format is for user reference.

</details>

<details>
<summary> Labs on DC Complier </summary>

 Invoking dc_shell. Then we echo target library and link_library which returns an vitual library named as your library, which needs to be set.
```
 echo $target_library
 echo $link_library
```
 
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/243be2c0a382f6f00b0ca5a9868387bb46d55db9/Samsung_PD_%23day6/2.png">

The RTL design code is 
```
module lab1_flop_with_en ( input res , input clk , input d , input en , output reg q);
always @ (posedge clk , posedge res)
begin
	if(res)
		q <= 1'b0;
	else if(en)
		q <= d;	
end
endmodule
```
Synthesis of this design code can be done using the following commands
```
read_verilog <path of design file>
read_db <path of .db>
write -f verilog -out <net_filename>
```
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/243be2c0a382f6f00b0ca5a9868387bb46d55db9/Samsung_PD_%23day6/1.png">
Below is the screenshot of the output window after compile This generates the netlist file but it consists of some seqgen library as shown in the figure and not the .db file even though we have read the .db file, This is beacuse we didn't set link and target library,
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/243be2c0a382f6f00b0ca5a9868387bb46d55db9/Samsung_PD_%23day6/2.png">
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/243be2c0a382f6f00b0ca5a9868387bb46d55db9/Samsung_PD_%23day6/3.png">


To set the link_library and target_library we use the following commands:
```
set target_library <path of .db>
set link_library { * path of the .db }
link
compile
write -f verilog -out <net_filename>
```
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/243be2c0a382f6f00b0ca5a9868387bb46d55db9/Samsung_PD_%23day6/5.1.png">
The generated netlist
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/243be2c0a382f6f00b0ca5a9868387bb46d55db9/Samsung_PD_%23day6/6.png">

**Comparing the both the netlist before and after proper mapping of library files**
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/243be2c0a382f6f00b0ca5a9868387bb46d55db9/Samsung_PD_%23day6/9.png">

**Labs on Design Vision**
To launch Design Vision we need to enable c shell and then give design Vision:
```
csh
design_vision
```
After launching the design_vison first we need to the net to .ddc which is read by Design_vision tool which can be done by using the below command
```
set target_library /Path_to_library(.db)
set link_library {* /Path_to_library(.db)}
link
compile
write -f verilog -out file.v
write -f ddc -out file.ddc

```
Then we can start GUI and then read the .ddc file generated above. This ddc file contains all the information of the tool memory of that particular session. ddc is synopys proprietary format i.e it can be read only br synopsys tools.When the .db is read it automatically reads the linked .db file.
If we have an RTL design that we want to synthesize and we have the Verilog code available, we would typically use read_verilog to start the synthesis process. However, if we have a DDC-formatted design from a previous run or from another tool in the Synopsys toolchain, we would use read_ddc to work with that design in Design Compiler's GUI or command-line environment.
When we click lab1 and then schematic we get the schematic view of the Design show below:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/243be2c0a382f6f00b0ca5a9868387bb46d55db9/Samsung_PD_%23day6/11.png">

**Lab on DC Setup**
The .synopys_dc.setup file for the above example of mux and d flip flop is as follows :

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/2a5a8c27-4485-4be0-8d3f-e1148c4fa01c)

```
set target_library /home/aviral.s/DC_WORKSHOP/lib/sky130_fd_sc_hd_tt_025c_1v80.db
set link_library {* $target_library }
```
</details>


<details>
<summary> Labs on TCL </summary>
Tcl (Tool Command Language) is a scripting language used for automating tasks. In EDA, it's used to automate design processes. Here are loops in Tcl:
	
1. While Loop:
while is used for repeating a block of code as long as a condition is true.

Example:

```
set i 0
while {$i < 5} {
    puts "Iteration $i"
    incr i
	}
```

2. For Loop:
for is used for iterating over a range or a list.

Example:
```
for {set i 0} {$i < 5} {incr i} {
    puts "Iteration $i"
}
```

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/b9492c99-82c1-4260-ae77-3eda1b29ad0a)

**Example**
These codes can be written in tickle file

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/dee74a60-34c2-43ab-bfd8-ea4f7bbc9c86)

Result

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/530cfe98-a82a-4071-93f3-00a36a580271)

Key Points
1. set is used for creating and storing information in the variables
2. We use $ to use any variable that is set when required to be seen as operating
3. Square brackets are used for nesting of commands in TCL.
4. Make sure there are spaces before "{" and after "}" to avoid any errors
5. Wrong manipulation might lead to infinite loop so make sure you use the variables properly.
6. "\" is used if we need write in next line in tcl file but to be considered as continuation of the current line according to the code.
7. foreach_in_collection is specific to synopsys not common in TCL.
8. We can differentiate between list and collection by printing them if it has {} at start and end it is a collection else it is a list.

</details>


## Day-7-Basic of STA

<details>
<summary> Introduction to STA </summary>

Delay in digital circuits is indeed dependent on input transition and output load. Let's explore how these factors affect delay:

1. **Input Tran (Signal Slope):**

   Definition: It refers to the rate of change of a digital input signal, often measured as the time it takes for the signal to transition from one logic level to another (e.g., from low to high or high to 
     low).

   - **Impact on Delay:**
     Faster Transitions : A faster input transition (slope is more) results in lesser delay because it takes less time for the signal to reach the threshold voltage of the mosfet

     Slower Transitions : Conversely, a slower input transition (slope is less) results in higher delay as it takes more time for the signal to cross the switching threshold.

2. **Output Load (Capacitance):**

   Definition : Output load, often represented as load capacitance , represents the electrical load that an output signal must drive. It includes the inherent capacitance of nets and the input capacitance of 
 gates or components connected to the output.

   - **Effect on Delay:**
     High Load : A higher output load capacitance results in more delay, as it takes more time to charge or discharge capacitance, slowing down the signal transition.
     
     Less Load : A lesser output load capacitance leads to less delay, as there is less capacitance to charge or discharge.

STA breaks down the design into time pathways before doing timing analysis. The following factors make up each time path:

Startpoint: The beginning of a timing route in which data is launched by a clock edge or must be ready at a certain moment. Every startpoint must be a register clock pin or an input port.

Combinational logic network: It includes elements with no internal state or memory. AND, OR, XOR, and inverter elements are allowed in combinational logic, but flip-flops, latches, registers, and RAM are not.

Endpoint: When data is caught by a clock edge or when it needs to be provided at a specified moment, this is the end of a timing path. A register data input pin or an output port must be present at each endpoint.

Static timing analysis calculates a maximum delay using the longest way and a minimum delay using the shortest path.

A Setup time (Max Delay Constraint) : It refers to a design specification or requirement that imposes an upper limit on the delay a signal can experience while propagating through a specific path or circuit within an integrated circuit. Consider a example of 2 registers connected with a combinational logic in between them.

**Tclk >= Tcq + Tcomb + Tsu**

Hold time (Min Delay constraint) : It's the minimum time after the clock's rising edge when data must remain stable at the input of a flip-flop to prevent data corruption.

**Thold < Tcq + Tcomb**

**Timing Arc**

 A timing arc defines the propagation of signals through logic gates/nets and defines a timing relationship between two related pins. Timing arc is one of the components of a timing path. Static timing analysis 
 works on the concept of timing paths. 
 
 Each path starts from either primary input or a register and ends at a primary output or a register. In-between, the path traverses through what are known as timing arcs. We can define a timing arc as an 
 indivisible path/constraint from one pin to another that tells EDA tool to consider the path/relationship between the pins. As in purely combinational logic, AND, NAND, NOT, full adder cell etc. gates have 
 arcs from each input pin to each output pin.

 **Combinational Timing Arcs:** These arcs describe the propagation of signals through combinational logic elements like gates.

  ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/b3431df4-1fe2-4bc3-b41c-a31b0d889505)

 **Sequential Timing Arcs:** Sequential elements like flip-flops introduce clock signals into our design. Sequential timing arcs account for clock-to-Q delays, setup times, and hold times to ensure proper 
   operation
     ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/522ef9c8-40d5-4dab-8eec-ae5dd95294bd)

   Timing paths in VLSI design are specific routes or signal paths within a digital circuit where the timing characteristics, including signal propagation delays, setup times, hold times, and clock-to-q delays, 
   are analyzed to ensure the circuit's correct and reliable operation. These paths are crucial for timing analysis and play a central role in achieving the desired performance and functionality of the 
   integrated circuit. Timing paths typically include a starting point (often a flip-flop or input pin), a set of logic gates and interconnections, and an ending point (another flip-flop or output pin).

**Start points of timing path**

Input ports
Clock pins of regs
End point of timing path

Output ports
D pin of D flip flop / D Latch
Always the timing path start at one of the start point and ends at one of the end point

Clock -> D (Reg 2 Reg)

Clock -> Output port (I/O timing path)

input port -> D (I/O timing path)

input port -> Output port (These should not be present)
</details>

<details>
<summary> Labs </summary>
Timing File (.lib) consists of ASCII representations of Timing, Area, and Power associated with the Standard cell. The Naming convention in the timing file follows PVT format (Process, Voltage, Temperature). For example, the standard library used in our case was sky130_fd_sc_hd_tt_025C_1v8, this name suggests that we are using 130 nm technology and the process is typical, temperature is 25C, and 1.8 V represents the voltage.
The common part of Lib file contains
- Library name and technology name
- Units (of time, power, voltage, current, resistance and capacitance)
- Value of operating condition ( process, voltage and temperature) â€“ Max, Min and Typical 

<img width="1085" alt="lib1" src="">

Based on operating conditions there are three different lib files for Max, Min and Typical corners. In the second part of Lib file, it contains cell-specific information for each cell. 

Cell-specific information in Lib file is mainly
  Cell name
  Pin name
  Area of cell
  Leakage power in respect of input pins logic state.

Also It contains Pins details like
  Pin name
  Pin direction
  Internal power
  Capacitance
  Rise capacitance
  Fall Capacitance
  Fanout load
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/ed9ec95d7da99f2c07912ebd2b3be4a10d103b0c/Samsung_PD_%23day7/1.png">

A Look-Up Table (LUT) in a Liberty file is a component that defines the logical behavior and timing characteristics of a combinational logic cell within a digital library.LUT can be both with respect to timing as well as power

index1[row] represents input transition , index2[column] represeents output load capacitance

example of and2_1 gate index table
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/ed9ec95d7da99f2c07912ebd2b3be4a10d103b0c/Samsung_PD_%23day7/2.png">

**Pin Attributes**
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/ed9ec95d7da99f2c07912ebd2b3be4a10d103b0c/Samsung_PD_%23day7/3(pin%20attributes).png">

Sequential flops have clock pin as **true**

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/ed9ec95d7da99f2c07912ebd2b3be4a10d103b0c/Samsung_PD_%23day7/4(flop).png">

**Unateness**
A function is said to be unate if the rise transition on the positive unate input variable causes the ouput to rise or no change and vice versa.

Negative unateness means cell output logic is inverted version of input logic. eg. In inverter having input A and output Y, Y is -ve unate w.r.t A. Positive unate means cell output logic is same as that of input.
These +ve ad -ve unateness are constraints defined in library file and are defined for output pin w.r.t some input pin.

A clock signal is positive unate if a rising edge at the clock source can only cause a rising edge at the register clock pin, and a falling edge at the clock source can only cause a falling edge at the register clock pin.

A clock signal is negative unateÂ if a rising edge at the clock source can only cause a falling edge at the register clock pin, and a falling edge at the clock source can only cause a rising edge at the register clock pin. In other words, the clock signal is inverted.

A clock signal is not unate if the clock sense is ambiguous as a result of non-unate timing arcs in the clock path.

Unnateness of D flip flop positive edge triggered

```
                related_pin : "CLK_N";
                rise_transition ("del_1_7_7") {
                    index_1("0.0100000000, 0.0230506000, 0.0531329000, 0.1224740000, 0.2823110000, 0.6507430000, 1.5000000000");
                    index_2("0.0005000000, 0.0013189500, 0.0034792400, 0.0091778800, 0.0242103000, 0.0638642000, 0.1684670000");
                    values("0.0232978000, 0.0295765000, 0.0465064000, 0.0946410000, 0.2265447000, 0.5754117000, 1.5026856000", \
                        "0.0234848000, 0.0296225000, 0.0464747000, 0.0944869000, 0.2264113000, 0.5750624000, 1.5045718000", \
                        "0.0233643000, 0.0295607000, 0.0464747000, 0.0945168000, 0.2263061000, 0.5753233000, 1.5028371000", \
                        "0.0235687000, 0.0297767000, 0.0466145000, 0.0944561000, 0.2259604000, 0.5746931000, 1.5046934000", \
                        "0.0235661000, 0.0295917000, 0.0466156000, 0.0945248000, 0.2261588000, 0.5747037000, 1.5006447000", \
                        "0.0236305000, 0.0297841000, 0.0466114000, 0.0943436000, 0.2264104000, 0.5749078000, 1.5007792000", \
                        "0.0234834000, 0.0296178000, 0.0466203000, 0.0946091000, 0.2266867000, 0.5748321000, 1.5022009000");
                }
                timing_sense : "non_unate";
                timing_type : "falling_edge";
            }
```


Unateness of D latch positive edge triggered
```
                related_pin : "GATE_N";
                rise_transition ("del_1_7_7") {
                    index_1("0.0100000000, 0.0230506000, 0.0531329000, 0.1224740000, 0.2823110000, 0.6507430000, 1.5000000000");
                    index_2("0.0005000000, 0.0013104500, 0.0034345500, 0.0090016200, 0.0235923000, 0.0618331000, 0.1620580000");
                    values("0.0290359000, 0.0360989000, 0.0537774000, 0.1023029000, 0.2327008000, 0.5800371000, 1.4992581000", \
                        "0.0290669000, 0.0360541000, 0.0537217000, 0.1023566000, 0.2325888000, 0.5812102000, 1.5037938000", \
                        "0.0289580000, 0.0359722000, 0.0537431000, 0.1023093000, 0.2327867000, 0.5797032000, 1.5054989000", \
                        "0.0289144000, 0.0360224000, 0.0538419000, 0.1022993000, 0.2324767000, 0.5806629000, 1.5049062000", \
                        "0.0289832000, 0.0360823000, 0.0537268000, 0.1023169000, 0.2327650000, 0.5794586000, 1.5054222000", \
                        "0.0290149000, 0.0360945000, 0.0537585000, 0.1023309000, 0.2324873000, 0.5810031000, 1.4970503000", \
                        "0.0289586000, 0.0360057000, 0.0538139000, 0.1022934000, 0.2326491000, 0.5787922000, 1.5045210000");
                }
                timing_sense : "non_unate";
                timing_type : "falling_edge";
            }
```


**Lab on .lib in dc_compiler**

 **To print all the sequential gates**
```
dc_shell> echo $target_library 
DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db
dc_shell> get_lib_cells */* -filter "is_sequential == true"
{sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfbbn_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfbbn_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfbbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfrbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfrbp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfrtn_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfrtp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfrtp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfrtp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfsbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfsbp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfstp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfstp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfstp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfxbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfxbp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfxtp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfxtp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfxtp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlclkp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlclkp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlclkp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrbn_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrbn_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrbp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrtn_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrtn_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrtn_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrtp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrtp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrtp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlxbn_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlxbn_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlxbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlxtn_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlxtn_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlxtn_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlxtp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__edfxbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__edfxtp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__lpflow_inputisolatch_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfbbn_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfbbn_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfbbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfrbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfrbp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfrtn_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfrtp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfrtp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfrtp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfsbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfsbp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfstp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfstp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfstp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfxbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfxbp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfxtp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfxtp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfxtp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdlclkp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdlclkp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdlclkp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sedfxbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sedfxbp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sedfxtp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sedfxtp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sedfxtp_4}
```

**To Prints the library linked**
```
dc_shell> list_lib
Logical Libraries:
-------------------------------------------------------------------------
Library		File			Path
-------		----			----
  sky130_fd_sc_hd__tt_025C_1v80 sky130_fd_sc_hd__tt_025C_1v80.db /home/prakhar.g2/Samsung-PD-Training-/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib
1
```

Ex 3 : the list of cells from the collection
```
dc_shell> foreach_in_collection my_lib_cell [get_lib_cells */*and*] {                                                                                                                                                                      set my_lib_cell_name [get_object_name $my_lib_cell];                                                                                                                                                               echo $my_lib_cell_name;                                                                                                                                                                                            }
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2_0
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2b_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2b_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2b_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and3_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and3_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and3_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and3b_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and3b_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and3b_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4b_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4b_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4b_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4bb_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4bb_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4bb_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand2_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand2_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand2_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand2_8
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand2b_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand2b_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand2b_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_4
```


**Prints the functionality of a particular cell**
```
dc_shell> foreach_in_collection my_pins [get_lib_pins sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/*] {
set my_pin_name [get_object_name $my_pins];
set pin_dir [get_lib_attribute $my_pin_name direction];
echo $my_pin_name $pin_dir;
}
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/A'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/A 1
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/B'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/B 1
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/C'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/C 1
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/D'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/D 1
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/Y 2
dc_shell> get_lib_attribute sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/Y function
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/Y'. 
(!A) | (!B) | (!C) | (!D)
```
**To find the output pin name and its functionality for multiple cells**

First make vim file by name my_script.tcl , then inside gvim file write :
```
set my_list [list sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1 ]



#For each cell in  the list, find the output pin name and its functionality


foreach my_cell $my_list {
foreach_in_collection my_lib_pin [get_lib_pins ${my_cell}/*] {
set my_lib_pin_name [get_object_name $my_lib_pin];
set a [get_lib_attribute $my_lib_pin_name direction];
if {$a > 1} {
set fn [get_lib_attribute $my_lib_pin_name function];
echo $my_lib_pin_name $a $fn;
}
}

}
```
Then Source the file 

dc_shell> source my_script.tcl

```
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1/A'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1/Y 2 (!A) | (!B) | (!C)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2/A'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2/Y 2 (!A) | (!B) | (!C)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4/A'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4/Y 2 (!A) | (!B) | (!C)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1/A_N'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1/Y 2 (A_N) | (!B) | (!C)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2/A_N'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2/Y 2 (A_N) | (!B) | (!C)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4/A_N'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4/Y 2 (A_N) | (!B) | (!C)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1/A'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1/D'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1/Y 2 (!A) | (!B) | (!C) | (!D)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/A'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/D'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/Y 2 (!A) | (!B) | (!C) | (!D)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4/A'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4/D'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4/Y 2 (!A) | (!B) | (!C) | (!D)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1/A_N'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1/D'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1/Y 2 (A_N) | (!B) | (!C) | (!D)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2/A_N'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2/D'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2/Y 2 (A_N) | (!B) | (!C) | (!D)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4/A_N'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4/D'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4/Y 2 (A_N) | (!B) | (!C) | (!D)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1/A_N'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1/B_N'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1/D'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1/Y 2 (A_N) | (B_N) | (!C) | (!D)
```
Everywhere its showing its pin name and functionality.
Similarly , We can do for other attributes like area, capacitance, clock etc.
To find the attributes :

dc_shell> list_attributes -app > a

dc_shell> sh gvim a &
</details>


## Day-8 -ADVANCED CONSTRAINTS 

<details>
<summary>Clock & Timing Terminologies</summary>


Before understanding the terms related to clock.First we"ll look the sources of clocks used in general
 
Clock Generators they generate clock signals from which we control the timing of digital operations within the IC. Clock generators are designed to produce clock signals with attributes such as frequency,duty cycle,and phase,to meet the timing requirements of design

**Types of clock generators**

    - Oscillators: These are widely used as clock generators. They generate continuous periodic signals without an external input. Common types include RC oscillators, LC oscillators, and crystal oscillators.

    - Phase-Locked Loops (PLLs): PLLs are versatile clock generators that can generate clock signals with adjustable frequency and phase. They are often used for clock synchronization and multiplication.

    - Ring Oscillators: These are simple but effective oscillators often used for generating clock signals with relatively low frequencies.

    - Crystal Oscillators: They are highly stable and accurate oscillators that use piezoelectric crystals to generate clock signals.

 Clock is constrained ??  
 
 Actually clock period gets constrained , which in turn limits the combinational delay 
 i.e 

   **Tclk [Clock period] >= Tc2q [contamination Delay] + Tcomb [Combination Delay] + Tsu [Setup Time]**

   **Tcomb <= Tclk - (Tc2q + Tsu)**

 
In practical clock never arrives at  two flip flops at same time.Therwe will always be some difference and that difference in clock arrival is called skew.

 **Global Clock Skew**
 
 Global clock skew refers to the difference in arrival times of a clock signal at various points across the entire chip. It affects all elements of the chip and can lead to synchronization issues between different clock domains. Managing global       clock skew is a critical aspect of clock distribution in large and complex integrated circuits. Global skew can be reduced by careful clock tree synthesis and by minimizing the length of critical paths in the design.

 **Local Clock Skew**
 
 Local clock skew is specific to a particular region or block within the chip. It can result from variations in the lengths of wires or traces that carry the clock signal to different parts of a block. Local skew is often easier to manage than        global skew because it affects a smaller portion of the chip. Techniques like buffer insertion and clock gating can be used to mitigate local clock skew.

 Furthermore it can be classified as
          
	  Positive Skew: Positive skew occurs when clock signals arrive at clock pin later than the ideal clock edge. It results in setup time violations.
          
	  Negative Skew: Negative skew occurs when clock signals arrive at clock pin earlier than the ideal clock edge at different destinations. It result in hold time violations.
   </details>

 <details>
<summary>Clock Tree Distribution Model</summary>

	 
The clock distribution network ensures that the clock signal is delivered accurately and with minimal skew to all the sequential elements (like flip-flops) within the chip. Important aspect considering while modeling a clock distribution network in a design:

 **Clock Source:** 
    Determine the source of the clock signal, whether it's generated on-chip or received from an external source,such as oscillator.
   
 **Clock Domain:** 
    Identify and partition the design into clock domains if multiple clock frequencies or asynchronous clock domains are involved.

 **Clock Tree Synthesis (CTS):** 
    Use CTS tools to automatically generate a clock distribution network that meets the design requirements.
   
 **Clock Buffers:**
    Design clock buffers to drive the clock signal through the clock distribution network. Sizing and placing these buffers is very crucial as per the requirement we insert in the path.
   
 **Clock Routing:**
    Plan the routing of clock lines carefully to minimize wirelength and optimize signal delivery. Clock lines should be short and of equal length.
   
 **Clock Distribution Topology:**
 Choose an appropriate topology for the clock distribution network. Common topologies include tree, mesh, or hybrid structures, depending on the chip's layout and size. There are two models H-TREE , I-TREE . Mostly H-TREE is incorporated in the      design
  
 **Clock Synchronization:**
     Implement clock synchronization techniques when dealing with multiple clock domains, ensuring that data is correctly transferred between domains.

 **Clock Domain Crossing (CDC):**
     Handle clock domain crossing issues, where data crosses between different clock domains.Synchronization is required.It will help in avoiding metastability

 **Clock Redundancy:**
     Introduce redundancy in the clock network to improve reliability and fault tolerance.

Designing a clock distribution network to ensure proper functioning and performance of the integrated circuit.

Practical aspects with respect to clock. Source latency, network latency, clock period, and different types of jitter (duty cycle jitter and period jitter) in the context of VLSI clock design:

**Source Latency:**
    Source latency refers to the delay introduced by the clock source, which could be an on-chip oscillator or an external clock input. This latency includes the time it takes for the clock signal to propagate from the source to the point where it enters the clock distribution network. Minimizing source latency is essential to ensure that the clock arrives at the clock distribution network with minimal delay.

 **Network Latency:**
    Network latency is the cumulative delay introduced by the clock distribution network as the clock signal propagates from the source to the various clock pins (e.g., flip-flops). It includes the delay through clock buffers, wires, and routing resources. Minimizing network latency is crucial to ensure that all clock sinks receive the clock signal within the required time window.

 **Clock Period:**
    The clock period, often denoted as T_clk, is the time interval between consecutive rising or falling edges of the clock signal. It is inversely related to the clock frequency (f_clk) by the equation T_clk = 1 / f_clk. The clock period directly affects the maximum achievable operating frequency of the chip and the timing constraints of the design. Designers must ensure that the clock period meets the setup and hold time requirements of the flip-flops.

 **Jitter:**
    Jitter is the variation in the timing of clock edges compared to their ideal or expected positions. It can be caused by various factors and can manifest in different forms such as temprature , noise , process variations .

Commands used in synopsys for modelling the clock

 **`create_clock`**:
   
    This command is used to define clock signals in the design.

    
 **Syntax**
     
     ```tcl
     create_clock -period <clock_period> -name <clock_name> [get_pins <clock_port>]
     ```
       clock_period: Specifies the clock period in nanoseconds.
       clock_name : Assigning a name to the clock signal.

   **Working**:
     - The `create_clock` until and unless we don't define. Error will be there no clock found
     - It is essential for correctly setting up constraints for the design's clock network.


 **`set_clock_latency -source`**:

    This command sets the source latency for a clock signal.

   **Syntax**:
   
     ```tcl
     set_clock_latency -source <latency_value> [get_clocks <clock_name>]
     ```
     latency_value: Specifies the source latency in nanoseconds.
     clock_name: Specifies the clock to which the source latency is applied (optional if not explicitly defined in `create_clock`).

**Working**:
      Source latency accounts for the delay introduced by the clock source (e.g., oscillator) before the clock signal reaches the chip.
    

**`set_clock_latency (network)`**:

   This command sets network latency for a clock signal.
 
 **Syntax**:
 
     ```tcl
     set_clock_latency -network <latency_value> [get_clocks <clock_name>]
     ```
   latency_value : Specifies the network latency in nanoseconds.
    
**Working**:
     Network latency represents the cumulative delay introduced by the clock distribution network (buffers, wires, routing).
    

**`set_clock_uncertainty (setup or hold)`**:
    
     These commands set the uncertainty (jitter and skew) for setup or hold analysis.

    **Syntax**:
     ```tcl
     set_clock_uncertainty -setup <uncertainty_value> -hold <uncertainty_value> [get_clocks <clock_name>]
     ```
     uncertainty_value: Specifies the uncertainty (jitter and skew) in nanoseconds for setup or hold analysis.
  

   - **Working**:

      Setup uncertainty holds  for variations in clock arrival times, affecting flip-flop data input setup times.
      Hold uncertainty holds for variations in clock and data arrival times, affecting flip-flop data input hold times.
      Jitter represents random variations in clock edges, and skew represents systematic variations in clock arrival times.
     
 **`report_clocks`**:
        This command generates a report of clock-related information.

    **Syntax**:
     ```tcl
     report_clocks [-sort_by {name | period | latency}]
     ```
  **Working**:
      The `report_clocks` command provides information about the defined clocks in the design, including their periods and latencies.

      </details>
     
   
</details>


<details>
<summary> Labs on Advanced Constrains </summary>

**Checking the target and link Library**
```
dc_shell> echo $target_library 
DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db

dc_shell> echo $link_library 
*$target_library
```
**Reading and linking verilog file**

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/073235cdc409365758081db5def941b84631488a/Samsung_PD_%23day%208/1(design%20under%20analysis).png">

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/073235cdc409365758081db5def941b84631488a/Samsung_PD_%23day%208/2.png">

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/073235cdc409365758081db5def941b84631488a/Samsung_PD_%23day%208/3(compile).png">


  Linking design 'lab8_circuit'
  Using the following designs and libraries:
  --------------------------------------------------------------------------
  lab8_circuit   /home/aviral.s/Samsung-PD-Training-/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/verilog_files/lab8_circuit.db
  sky130_fd_sc_hd__tt_025C_1v80 (library) /home/aviral.s/Samsung-PD-Training-/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db


**dc_shell> compile_ultra**
Loading db file '/home/synopsys/DC/syn_vT-2022.03-SP5-1/libraries/syn/dw_foundation.sldb'
Warning: DesignWare synthetic library dw_foundation.sldb is added to the synthetic_library in the current command. (UISN-40)
Information: Performing power optimization. (PWR-850)
Analyzing: "/home/aviral.s/Samsung-PD-Training-/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db"
Library analysis succeeded.
Information: Evaluating DesignWare library utilization. (UISN-27)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/f6fd4cf1-7a3d-4883-bd0f-f95a1ca1a90a)


**Listing ports in design**

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/073235cdc409365758081db5def941b84631488a/Samsung_PD_%23day%208/4(ports%20list).png

```
dc_shell> get_ports 
{rst clk IN_A IN_B OUT_Y out_clk}
# returns all the ports present in the design


dc_shell> foreach_in_collection my_port [get_ports *] {
set my_port_name [get_object_name $my_port];
echo $my_port_name;
}
rst
clk
IN_A

OUT_Y
out_clk
```
**Listing port with direction**

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/073235cdc409365758081db5def941b84631488a/Samsung_PD_%23day%208/5(ports%20dir).png">
```
dc_shell> foreach_in_collection my_port [get_ports *] {                                                                                                                                                                            set my_port_name [get_object_name $my_port];
                 set dir [get_attribute [get_ports $my_port_name] direction];
                 echo $my_port_name $dir;
                 }                                                                                                                                                                                               
rst in
clk in
IN_A in
IN_B in
OUT_Y out
out_clk out
```
**4. Listing Cells in design**
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/073235cdc409365758081db5def941b84631488a/Samsung_PD_%23day%208/6(ref%20name%20of%20cell).png">

```
dc_shell> get_cells *
 {REGA_reg REGB_reg REGC_reg U9 U10 U11 U12 U13 U14}

By default system gives hierarchical cells:
dc_shell> get_cells * -hier -filter "is_hierarchical == false"
{REGA_reg REGB_reg REGC_reg U9 U10 U11 U12 U13 U14}


For listing Reference cells :

dc_shell> foreach_in_collection my_cell [get_cells * -hier] {
 set my_cell_name [get_object_name $my_cell];
 set rname [get_attribute [get_cells $my_cell_name] ref_name];
echo $my_cell_name $rname;
}

REGA_reg sky130_fd_sc_hd__dfrtp_1
REGB_reg sky130_fd_sc_hd__dfrtp_1
REGC_reg sky130_fd_sc_hd__dfrtp_1
U9 sky130_fd_sc_hd__clkinv_1
U10 sky130_fd_sc_hd__clkinv_1
U11 sky130_fd_sc_hd__nor2_1
U12 sky130_fd_sc_hd__a21oi_1
U13 sky130_fd_sc_hd__clkinv_1
U14 sky130_fd_sc_hd__nand2_1

```

Now we convert our design into ddc

dc_shell> write -f ddc -out verilog_files/lab8_circuit.ddc

Then open design_vision gui in another tab read ddc file of lab8.
The schematic of lab8_circuit.ddc as gvien below:

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/073235cdc409365758081db5def941b84631488a/Samsung_PD_%23day%208/7(design%20schematic%20and%20net%20connection).png">

```
design_vision> foreach_in_collection my_pin [all_connected n5] {
set pin_name [get_object_name $my_pin];
set dir [get_attribute [get_pins $pin_name] direction];
echo $pin_name $dir;
}
U11/Y out
U13/A in
U12/B1 in
```
**Getting Pin of Design**

```
dc_shell> get_pin *
{REGA_reg/D REGA_reg/CLK REGA_reg/RESET_B REGA_reg/Q REGB_reg/D REGB_reg/CLK REGB_reg/RESET_B REGB_reg/Q REGC_reg/D REGC_reg/CLK REGC_reg/RESET_B REGC_reg/Q U9/A U9/Y U10/A U10/Y U11/A U11/B U11/Y U12/A1 U12/A2 U12/B1 U12/Y U13/A U13/Y U14/A U14/B U14/Y}

Listing it vertically:
dc_shell> foreach_in_collection my_pin [get_pins *] {
set pin_name [get_object_name $my_pin];
echo $pin_name;
}
REGA_reg/D
REGA_reg/CLK
REGA_reg/RESET_B
REGA_reg/Q
REGB_reg/D
REGB_reg/CLK
REGB_reg/RESET_B
REGB_reg/Q
REGC_reg/D
REGC_reg/CLK
REGC_reg/RESET_B
REGC_reg/Q
U9/A
U9/Y
U10/A
U10/Y
U11/A
U11/B
U11/Y
U12/A1
U12/A2
U12/B1
U12/Y
U13/A
U13/Y
U14/A
U14/B
U14/Y
```
If pin is input pin  the list it:

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/073235cdc409365758081db5def941b84631488a/Samsung_PD_%23day%208/2(find%20clock%20pin).png">

After Sourcing tcl file we get this result:
```
dc_shell> source  query_clock_pin.tcl 
REGA_reg/CLK
REGB_reg/CLK
REGC_reg/CLK
```
**Creating Clock**

```
dc_shell> create_clock -name MYCLK -per 10 [get_ports clk]
1
dc_shell> get_clocks *
{MYCLK}


## Reporting Clock
dc_shell> report_clock *
Information: Updating graph... (UID-83)
 
****************************************
Report : clocks
Design : lab8_circuit
Version: T-2022.03-SP5-1
Date   : Tue Sep 12 15:12:44 2023
****************************************

Attributes:
    d - dont_touch_network
    f - fix_hold
    p - propagated_clock
    G - generated_clock
    g - lib_generated_clock

Clock          Period   Waveform            Attrs     Sources
--------------------------------------------------------------------------------
MYCLK           10.00   {0 5}                         {clk}
--------------------------------------------------------------------------------
1

dc_shell> get_attribute [get_ports out_clk] clocks --------> It tells what are clocks reaching the pin.
{MYCLK}                       
dc_shell> get_attribute [get_ports out_clk] clock ---------> It tells is the pin meant to be a clock pin or not.
Warning: Attribute 'clock' does not exist on port 'out_clk'. (UID-101)
```
Creating different types of clock :
```
dc_shell> create_clock -name MYCLK -per 10 [get_ports clk] -wave {5 10} -----> Clock with rising edge at 5 and falling edge at 10. 50% duty cucle.
dc_shell> create_clock -name MYCLK -per 10 [get_ports clk] -wave {0 2.5} -----> Clock with rising edge at 0 and falling edge at 2.5. 25% duty cycle.
dc_shell> create_clock -name MYCLK -per 10 [get_ports clk] -wave {15 20} ----> rising edge at 15, before 15ns no clock.
```

To remove clock :

dc_shell> remove_clock <clock_name>

**Report_timing**

In report timing it says (Path is unconstrained) because clock is not present.
So, we create a clock first...
```
dc_shell> create_clock -name MYCLK -per 10 [get_ports clk]
1


dc_shell> report_timing -to REGC_reg/D
Information: Updating design information... (UID-85)
 
****************************************
Report : timing
        -path full
        -delay max
        -max_paths 1
Design : lab8_circuit
Version: T-2022.03-SP5-1
Date   : Tue Sep 12 15:54:55 2023
****************************************

Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
Wire Load Model Mode: top

  Startpoint: REGB_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Endpoint: REGC_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Path Group: MYCLK
  Path Type: max

  Point                                                   Incr       Path
  --------------------------------------------------------------------------
  clock MYCLK (rise edge)                                 0.00       0.00
  clock network delay (ideal)                             0.00       0.00
  REGB_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                 0.00       0.00 r
  REGB_reg/Q (sky130_fd_sc_hd__dfrtp_1)                   0.29       0.29 r
  U14/Y (sky130_fd_sc_hd__nand2_1)                        0.04       0.34 f
  REGC_reg/D (sky130_fd_sc_hd__dfrtp_1)                   0.00       0.34 f
  data arrival time                                                  0.34

  clock MYCLK (rise edge)                                10.00      10.00
  clock network delay (ideal)                             0.00      10.00
  REGC_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                 0.00      10.00 r
  library setup time                                     -0.12       9.88
  data required time                                                 9.88
  --------------------------------------------------------------------------
  data required time                                                 9.88
  data arrival time                                                 -0.34
  --------------------------------------------------------------------------
  slack (MET)                                                        9.55
```
This report timing will show the arival time and required time with slack. It will not show uncertanity , input and output external delay, latency because we have not modeled it yet.

```
dc_shell> set_clock_latency -source 2 [get_clocks MYCLK]
1
dc_shell> set_clock_latency 1 [get_clocks MYCLK]
1
dc_shell> set_clock_uncertainty -setup 0.5 [get_clocks MYCLK]
1
dc_shell> set_clock_uncertainty -hold 0.5 [get_clocks MYCLK]
1
```

**FOR  SETUP**
```
dc_shell> report_timing -to REGC_reg/D 
Information: Updating design information... (UID-85)
 
****************************************
Report : timing
        -path full
        -delay max
        -max_paths 1
Design : lab8_circuit
Version: T-2022.03-SP5-1
Date   : Tue Sep 12 16:02:40 2023
****************************************

Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
Wire Load Model Mode: top

  Startpoint: REGB_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Endpoint: REGC_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Path Group: MYCLK
  Path Type: max

  Point                                                   Incr       Path
  --------------------------------------------------------------------------
  clock MYCLK (rise edge)                                 0.00       0.00
  clock network delay (ideal)                             3.00       3.00            { changed from 0 to 3 clock network latency =source latency + nwetwork latency = 2 + 1=3}
  REGB_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                 0.00       3.00 r
  REGB_reg/Q (sky130_fd_sc_hd__dfrtp_1)                   0.29       3.29 r
  U14/Y (sky130_fd_sc_hd__nand2_1)                        0.04       3.34 f
  REGC_reg/D (sky130_fd_sc_hd__dfrtp_1)                   0.00       3.34 f
  data arrival time                                                  3.34

  clock MYCLK (rise edge)                                10.00      10.00
  clock network delay (ideal)                             3.00      13.00            {changed from 0 to 3 clock network latency =source latency + nwetwork latency = 2 + 1=3}
  clock uncertainty                                      -0.50      12.50            {Uncertanity is getting subtracted}
  REGC_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                 0.00      12.50 r
  library setup time                                     -0.12      12.38
  data required time                                                12.38
  --------------------------------------------------------------------------
  data required time                                                12.38
  data arrival time                                                 -3.34
  --------------------------------------------------------------------------
  slack (MET)                                                        9.05        --------------------> slack went down from 9.55 to 9.05
```


**FOR HOLD**

```
dc_shell> report_timing -to REGC_reg/D -delay_type min
 
****************************************
Report : timing
        -path full
        -delay min
        -max_paths 1
Design : lab8_circuit
Version: T-2022.03-SP5-1
Date   : Tue Sep 12 16:09:25 2023
****************************************

Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
Wire Load Model Mode: top

  Startpoint: REGA_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Endpoint: REGC_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Path Group: MYCLK
  Path Type: min

  Point                                                   Incr       Path
  --------------------------------------------------------------------------
  clock MYCLK (rise edge)                                 0.00       0.00
  clock network delay (ideal)                             3.00       3.00
  REGA_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                 0.00       3.00 r
  REGA_reg/Q (sky130_fd_sc_hd__dfrtp_1)                   0.29       3.29 r
  U14/Y (sky130_fd_sc_hd__nand2_1)                        0.04       3.33 f
  REGC_reg/D (sky130_fd_sc_hd__dfrtp_1)                   0.00       3.33 f
  data arrival time                                                  3.33

  clock MYCLK (rise edge)                                 0.00       0.00
  clock network delay (ideal)                             3.00       3.00
  clock uncertainty                                       0.50       3.50     {Here Uncertainity is getting added}
  REGC_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                 0.00       3.50 r
  library hold time                                      -0.05       3.45
  data required time                                                 3.45
  --------------------------------------------------------------------------
  data required time                                                 3.45
  data arrival time                                                 -3.33
  --------------------------------------------------------------------------
  slack (VIOLATED)                                                  -0.12
```
   
**8. Modeling IO delays**

When we do report_timing -from **IN_A** we get path is unconstrained. We set IO Constrains :
```
dc_shell> set_input_delay -max 5 -clock [get_clocks MYCLK] [get_ports IN_A]
1
dc_shell> set_input_delay -max 5 -clock [get_clocks MYCLK] [get_ports IN_B]
1
dc_shell> set_input_delay -min 1 -clock [get_clocks MYCLK] [get_ports IN_B]
1
dc_shell> set_input_delay -min 1 -clock [get_clocks MYCLK] [get_ports IN_A]
1
dc_shell> set_input_transition -max 0.3 [get_ports IN_A]
1
dc_shell> set_input_transition -max 0.3 [get_ports IN_B]
1
dc_shell> set_input_transition -min 0.1 [get_ports IN_B]
1
dc_shell> set_input_transition -min 0.1 [get_ports IN_A]
1
```

We get report_timing as :

FOR SETUP :

```
dc_shell> report_timing -from IN_A -trans -net -cap -nosplit 
 
****************************************
Report : timing
        -path full
        -delay max
        -nets
        -max_paths 1
        -transition_time
        -capacitance
Design : lab8_circuit
Version: T-2022.03-SP5-1
Date   : Tue Sep 12 16:20:38 2023
****************************************

Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
Wire Load Model Mode: top

  Startpoint: IN_A (input port clocked by MYCLK)
  Endpoint: REGA_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Path Group: MYCLK
  Path Type: max

  Point                                       Fanout       Cap     Trans      Incr       Path
  ----------------------------------------------------------------------------------------------
  clock MYCLK (rise edge)                                                     0.00       0.00
  clock network delay (ideal)                                                 3.00       3.00
  input external delay                                                        5.00       8.00 f
  IN_A (in)                                                         0.30      0.00       8.00 f
  IN_A (net)                                    2         0.00                0.00       8.00 f
  U11/Y (sky130_fd_sc_hd__nor2_1)                                   0.16      0.22       8.22 r
  n5 (net)                                      2         0.01                0.00       8.22 r
  U13/Y (sky130_fd_sc_hd__clkinv_1)                                 0.05      0.07       8.29 f
  N0 (net)                                      1         0.00                0.00       8.29 f
  REGA_reg/D (sky130_fd_sc_hd__dfrtp_1)                             0.05      0.00       8.29 f
  data arrival time                                                                      8.29

  clock MYCLK (rise edge)                                                    10.00      10.00
  clock network delay (ideal)                                                 3.00      13.00
  clock uncertainty                                                          -0.50      12.50
  REGA_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                                     0.00      12.50 r
  library setup time                                                         -0.13      12.37
  data required time                                                                    12.37
  ----------------------------------------------------------------------------------------------
  data required time                                                                    12.37
  data arrival time                                                                     -8.29
  ----------------------------------------------------------------------------------------------
                                                                                         4.08   ----------------> Setup slack is reduced due input trans.

```

FOR HOLD : 
```
dc_shell> report_timing -from IN_A -trans -net -cap -nosplit -delay_type min
 
****************************************
Report : timing
        -path full
        -delay min
        -nets
        -max_paths 1
        -transition_time
        -capacitance
Design : lab8_circuit
Version: T-2022.03-SP5-1
Date   : Tue Sep 12 16:25:15 2023
****************************************

Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
Wire Load Model Mode: top

  Startpoint: IN_A (input port clocked by MYCLK)
  Endpoint: REGB_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Path Group: MYCLK
  Path Type: min

  Point                                       Fanout       Cap     Trans      Incr       Path
  ----------------------------------------------------------------------------------------------
  clock MYCLK (rise edge)                                                     0.00       0.00
  clock network delay (ideal)                                                 3.00       3.00
  input external delay                                                        1.00       4.00 r
  IN_A (in)                                                         0.10      0.00       4.00 r
  IN_A (net)                                    2         0.00                0.00       4.00 r
  U12/Y (sky130_fd_sc_hd__a21oi_1)                                  0.04      0.07       4.07 f
  N1 (net)                                      1         0.00                0.00       4.07 f
  REGB_reg/D (sky130_fd_sc_hd__dfrtp_1)                             0.04      0.00       4.07 f
  data arrival time                                                                      4.07

  clock MYCLK (rise edge)                                                     0.00       0.00
  clock network delay (ideal)                                                 3.00       3.00
  clock uncertainty                                                           0.50       3.50
  REGB_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                                     0.00       3.50 r
  library hold time                                                          -0.05       3.45
  data required time                                                                     3.45
  ----------------------------------------------------------------------------------------------
  data required time                                                                     3.45
  data arrival time                                                                     -4.07
  ----------------------------------------------------------------------------------------------
  slack (MET)                                                                            0.62

```
Setting Output Delay 

```
dc_shell> set_output_delay -max 5 -clock [get_clock MYCLK] [get_ports OUT_Y]
1
dc_shell> set_output_delay -min 1 -clock [get_clock MYCLK] [get_ports OUT_Y]
1
```
Report timing :

```
dc_shell> report_timing -to OUT_Y -cap -trans -nosplit
Information: Updating design information... (UID-85)
 
****************************************
Report : timing
        -path full
        -delay max
        -max_paths 1
        -transition_time
        -capacitance
Design : lab8_circuit
Version: T-2022.03-SP5-1
Date   : Tue Sep 12 16:30:24 2023
****************************************

Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
Wire Load Model Mode: top

  Startpoint: REGC_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Endpoint: OUT_Y (output port clocked by MYCLK)
  Path Group: MYCLK
  Path Type: max

  Point                                          Cap     Trans      Incr       Path
  ------------------------------------------------------------------------------------
  clock MYCLK (rise edge)                                           0.00       0.00
  clock network delay (ideal)                                       3.00       3.00
  REGC_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                 0.00      0.00       3.00 r
  REGC_reg/Q (sky130_fd_sc_hd__dfrtp_1)         0.00      0.04      0.34       3.34 f
  U10/Y (sky130_fd_sc_hd__clkinv_1)             0.00      0.01      0.03       3.36 r
  OUT_Y (out)                                             0.01      0.00       3.36 r
  data arrival time                                                            3.36

  clock MYCLK (rise edge)                                          10.00      10.00
  clock network delay (ideal)                                       3.00      13.00
  clock uncertainty                                                -0.50      12.50
  output external delay                                            -5.00       7.50
  data required time                                                           7.50
  ------------------------------------------------------------------------------------
  data required time                                                           7.50
  data arrival time                                                           -3.36
  ------------------------------------------------------------------------------------
  slack (MET)                                                                  4.14
```

After setting load
```
dc_shell> set_load -max 0.4 [get_ports OUT_Y]
1
dc_shell> set_load -min 0.1 [get_ports OUT_Y]
1
```

Report Timing

```
dc_shell> report_timing -to OUT_Y -cap -trans -nosplit
 
****************************************
Report : timing
        -path full
        -delay max
        -max_paths 1
        -transition_time
        -capacitance
Design : lab8_circuit
Version: T-2022.03-SP5-1
Date   : Tue Sep 12 16:33:26 2023
****************************************

Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
Wire Load Model Mode: top

  Startpoint: REGC_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Endpoint: OUT_Y (output port clocked by MYCLK)
  Path Group: MYCLK
  Path Type: max

  Point                                          Cap     Trans      Incr       Path
  ------------------------------------------------------------------------------------
  clock MYCLK (rise edge)                                           0.00       0.00
  clock network delay (ideal)                                       3.00       3.00
  REGC_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                 0.00      0.00       3.00 r
  REGC_reg/Q (sky130_fd_sc_hd__dfrtp_1)         0.00      0.05      0.30       3.30 r
  U10/Y (sky130_fd_sc_hd__clkinv_1)             0.40      3.07      2.32       5.62 f
  OUT_Y (out)                                             3.07      0.00       5.62 f
  data arrival time                                                            5.62

  clock MYCLK (rise edge)                                          10.00      10.00
  clock network delay (ideal)                                       3.00      13.00
  clock uncertainty                                                -0.50      12.50
  output external delay                                            -5.00       7.50
  data required time                                                           7.50
  ------------------------------------------------------------------------------------
  data required time                                                           7.50
  data arrival time                                                           -5.62
  ------------------------------------------------------------------------------------
  slack (MET)                                                                  1.88

```

Due to increase in load from 0 to 0.4 the transition time icreased, due to which we have more delay. Slack is also reduced. 

 **Generated Clock**

A generated clock  refers to a clock signal that is derived or generated from a primary clock source rather than being the primary clock signal itself. 

**Frequency Division**: 

Generated clocks are often used to create lower-frequency clocks from a higher-frequency master clock. This is achieved by dividing the frequency of the primary clock using digital counters or dividers. It allows different parts of the circuit to operate at slower clock speeds for power savings or to meet timing requirements.

**Frequency Multiplication**: 

Conversely, generated clocks can be used to create higher-frequency clocks from a lower-frequency source. This is often done using PLLs (Phase-Locked Loops) or DLLs (Delay-Locked Loops). Frequency multiplication is useful for driving specific high-speed components or meeting timing constraints.

**Clock Skew Control**: 

Generated clocks can be employed to control clock skew, which is the variation in arrival times of clock signals across the chip. By generating clocks with adjusted phases, designers can minimize clock skew and ensure that data is captured reliably in flip-flops and latches.
  
**Clock Gating** : Clock gating is a power-saving technique where clocks to certain parts of the circuit are enabled or disabled dynamically based on activity. Generated clocks can be used to control clock gating circuits, allowing for efficient power management by turning off clocks when they are not needed.

**Clock Domain Isolation** : 

In complex designs, different sections of a chip may operate in separate clock domains. Generated clocks can be used to create domain-specific clocks, enabling isolated operation with respect to clock signals. This is essential for managing timing constraints and avoiding issues associated with crossing clock domains.

**Synchronization** : 

When signals need to cross from one clock domain to another, synchronization is required to prevent data corruption. Generated clocks can be used to create synchronization signals and ensure proper data transfer between domains.


The command to create a generated clock is 

create_generated_clock -name <name_of_generated_clock> - master <master_clock_name> -source \[<master_clock_definition_point>] -div <value> \[<generated_clock_definition_point>]

Here a generated clock namely MYGEN_CLK is created , we can see that its attribute is G

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/7aad20b4-ccc3-47d0-9163-da35a933bc95)


Report timing we get respect to MYCLK

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/2f22858f-1109-4531-9c1b-42b67f0b9a57)

when we add constraints to the MYGEN_CLK we get timing with repect to MYGEN_CLK

set_clock_latency -max 1 \[get_clocks MYGEN_CLK}

set_output_delay -max 5 \[get_ports OUT_Y] -clock \[get_clocks MYGEN_CLK]

set_output_delay -min 1 \[get_ports OUT_Y] -clock \[get_clocks MYGEN_CLK]

The design used for this experiment is as follows

```
module lab8 circuit (input rst, input clk , input IN_A , input IN_B , output OUT_Y , output out_clk output reg out_div_clk)
reg REGA, REGB , REGC ;
always @ (posedge clk , posedge rst )
begin
	if(rst)
	begin
		REGA <= 1'b0 ;
		REGB <= 1'b0 ;
		REGC <= 1'b0 ;
		out_div_clk <= 1'b0 ;
	end
	else
	begin
		REGA= IN_A | IN_B;
		REGB<- IN_A ^ IN_B;
		REGC <= !(REGA & REGB) ;
		out_div_clk <= ~out_div_clk
	end
end

assign OUT_Y = ~REGC ;

assign out_clk = clk;

endmodule
```
Instead of writting constraints everytime we can create a .tcl script and then source it evrerytime

```
create_clock -name MYCLK -per 10 [get_ports clk];
set_clock_latency -source 2 [get_clocks MYCLK];
set_clock_latency 1 [get_clocks MYCLK];
set_clock_uncertainty -setup 0.5 [get_clocks MYCLK];
set_clock_uncertainty -hold 0.1 [get_clocks MYCLK];
set_input_delay -max 4 -clock [get_clocks MYCLK] [get_ports IN_A];
set_input_delay -max 4 -clock [get_clocks MYCLK] [get_ports IN_B];
set_input_delay -min 1 -clock [get_clocks MYCLK] [get_ports IN_A];
set_input_delay -min 1 -clock [get_clocks MYCLK] [get_ports IN_B];
set_input_transition -max 0.4 [get_ports IN_A];
set_input_transition -max 0.4 [get_ports IN_B];
set_input_transition -min 0.1 [get_ports IN_A];
set_input_transition -min 0.1 [get_ports IN_B];
create_generated_clock -name MYGEN_CLK -master MYCLK -source [get_ports clk] -div 1 [get_ports out_clk];
create_generated_clock -name MYGEN_DIV_CLK -master MYCLK -source [get_ports clk] -div 2 [get_ports out_div_clk]; 
set_output_delay -max 4 -clock [get_clocks MYGEN_CLK] [get_ports OUT_Y];
set_output_delay -min 1 -clock [get_clocks MYGEN_CLK] [get_ports OUT_Y];
set_load -max 0.4 [get_ports OUT_Y];
set_load -min 0.1 [get_ports OUT_Y];

```
The report_timing after sourcing the tcl script

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/61196011-e453-48f7-881a-aaa67ccad3e9)

When we give report_port -verbose

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/197bd233-491a-4707-8b7c-faee883b09a1)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/253f1ac0-2f23-4622-839e-bf7ce8e90066)

When we give set_input_delay -max 3 -clock <clock_name>  [<definition_point>]

  Here -max 3 implies that the data arrives 3 ns late compared to clock

  set_input_delay -max -3 -clock <clock_name>  [<definition_point>]

  Here the data is arriving 3 ns before the rising edge which helps in setup time

  so negative max relaxes the path in case of setup

  Positive max tightens the path in case of setup

  In case of hold it is the opposite case negative min tightens the path and positive min relaxes the path.

  The command for max_latency is

  set_max_latency <value> -from \[<source_port_name>] -to \[<destination_port_name>]

  The command for creating virtual clock

  create_clock -name <virtual_clock_name> -period <value>

  For virtual clock there is no latency and no clock defination point 
  ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/51f7afe4-47e3-4b90-9d74-d59889aca6fe)


![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/7f76130e-f5dd-4eb3-93b1-e5ad73cb5f6c)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/97382e37-33b1-4c21-b600-38d0733fc49a)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/e7923dc7-a397-4e84-8960-997ac963aae0)

![schematic (1)](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/6a9fa376-2d5d-4fc3-a9e9-eb04777eaf3d)


<details>
<summary>Virtual Clock and Set Max delay Constraints</summary>

**Creating a Virtual Clock with `create_clock`**:

In Synopsys Design Constraints (SDC), you can define a virtual clock using the `create_clock` command by specifying a period of 10 units. This effectively creates a virtual clock with a specified period.

**Syntax**:
```tcl
create_clock -name virtual_clk -period 10
```
-name <clock_name>: Assigns a name to the virtual clock, in this case, "virtual_clk."
-period <period_value>: Specifies the clock period, which is set to 10 units in this example.

**Working**:

The `create_clock` command is typically used to define clock signals in a digital design.
In this case, we are using it to create a virtual clock, which is a clock that doesn't have a physical source but is defined for timing analysis purposes.
We specify a name for the virtual clock, "virtual_clk," to uniquely identify it in the design.
 The `-period` option sets the clock period to 10 units. While this period value is provided, keep in mind that in the context of a virtual clock, this period doesn't represent a real clock period but is used as an abstract timing constraint for paths associated with this virtual clock.

**Using `set_max_delay` with Virtual Clocks**:

Once you have defined a virtual clock, you can use the `set_max_delay` command to specify timing constraints for paths related to this virtual clock. For example, if you want to set a maximum delay of 15 units for a specific path associated with the virtual clock "virtual_clk," you can use the following command:

```tcl
set_max_delay -from <source> -to <destination> 15 -clock virtual_clk
```

 from source: Specifies the source point in the design.
 -to destination: Specifies the destination point in the design.
 delay_value : Specifies the maximum allowable delay, in this case, 15 units.
 -clock virtual_clk : Associates this timing constraint with the virtual clock "virtual_clk."

**Rise and Fall Delays**:

In addition to setting maximum delays, you can also specify rise and fall delays using the `set_max_delay` command. Rise and fall delays represent the maximum time a signal is allowed to transition from a logic low (0) to a logic high (1) or vice versa. These constraints are important for ensuring proper signal transitions in your design.

To set a maximum rise delay of 5 units and a maximum fall delay of 3 units for a path associated with the virtual clock "virtual_clk," you can use the following commands:

```tcl
set_max_delay -from <source> -to <destination> 5 -clock virtual_clk -rise
set_max_delay -from <source> -to <destination> 3 -clock virtual_clk -fall
```

- `-rise`: Specifies that you are setting a maximum rise delay.
- `-fall`: Specifies that you are setting a maximum fall delay.

By applying these constraints, you ensure that signal transitions on paths related to the virtual clock meet the specified timing requirements, contributing to the overall reliability and performance of your design.
</details>


<details>
<summary>Lab on the above concept</summary>

Let us consider the design shown below
	
```
module lab8_circuit (input rst, input clk , input IN_A , input IN_B , output OUT_Y , output out_clk);
reg REGA , REGB , REGC ; 

always @ (posedge clk , posedge rst)
begin
	if(rst)
	begin
		REGA <= 1'b0;
		REGB <= 1'b0;
		REGC <= 1'b0;
	end
	else
	begin
		REGA <= IN_A | IN_B;
		REGB <= IN_A ^ IN_B;
		REGC <= !(REGA & REGB); 
	end
end

assign OUT_Y = ~REGC;

assign out_clk = clk;

endmodule

```
Commands used to run the Synthesis are

```
#configure .synopsys_dc.setup
read_verilog lab8_circuit.v
link
compile_ultra
write -f ddc -out lab8_circuit.ddc
```

Apart from the verilog code used above we have also used the modified version of it which is mentioned below

```
module lab8_circuit (input rst, input clk , input IN_A , input IN_B , output OUT_Y , output out_clk , output reg out_div_clk , input IN_C , input IN_D , output OUT_Z );
reg REGA , REGB , REGC ; 

always @ (posedge clk , posedge rst)
begin
	if(rst)
	begin
		REGA <= 1'b0;
		REGB <= 1'b0;
		REGC <= 1'b0;
		out_div_clk <= 1'b0;
	end
	else
	begin
		REGA <= IN_A | IN_B;
		REGB <= IN_A ^ IN_B;
		REGC <= !(REGA & REGB);
		out_div_clk <= ~out_div_clk; 
	end
end

assign OUT_Y = ~REGC;

assign out_clk = clk;
assign OUT_Z = IN_C ^ IN_D ;


endmodule
```

Information on all the clocks is given below
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/81229ce8-e3e1-428f-91ac-015223ccb682)

 Since we have not compiled the design the path to OUT_Z is still unconstrained as shown:

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/6063c39c-02c7-46d4-a549-487ca51e1722)


We will constraint the path to OUT_Z by using the virtual clock: <br>

```
set_input_delay -max 5 [get_ports IN_C] -clock [get_clocks MYVCLK];
set_input_delay -max 5 [get_ports IN_D] -clock [get_clocks MYVCLK];
set_output_delay -max 4.9 [get_ports OUT_Z] -clock [get_clocks MYVCLK];
```
 Time period of the clock to 10 ns. Now out of 10 ns, 5 ns for input delay and 4.9 ns is used up by the output path. So out of 10ns only 100 ps is left for the combinational delay of the XOR gate between IN_A, IN_C to OUT_Z. From report XOR gate needs 120 ps, but only 100 ps is available for the combination logic, therefore slack is not met.

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/84b1f179-56ea-4d8d-b548-a620cc31aa2a)


 Now we will compile the design to optimise to fix slack violation as shown

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/9a30d0ac-a0af-4b7b-a45e-19f3bf1e87a0)


It is noted that the input and the output delays are with respect to virtual clock now as shown

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/0baaaeb0-edc6-45ee-874e-51fede331ea8)

</details>


</details>


## Day-9 OPTIMIZATION

<details>
<summary>Introduction to Combinational and Sequential Optimization</summary>

VLSI optimization which is done to improve the design's power consumption, area utilization, timing.

 The goals of optimization :

 **Cost based Optimization**
     Optimize till cost is met at the same time taking care over optimization of one goal should'nt harm other goals.
     
 **Performance Optimization**
      
   Speed :-
      Improve the operational speed of the IC by minimizing delays, optimizing critical paths, and ensuring that the design meets specified timing requirements.
      
  Throughput :-
      Enhance the overall system throughput by optimizing data flow and minimizing bottlenecks in the circuit.

 **Power Optimization**

        Dynamic Power :-
	          Minimize dynamic power consumption to extend battery life in portable devices and reduce power dissipation in data centers.
        Static Power :- 
	          Reduce static power (leakage power) to lower overall power consumption when the IC is in standby or idle mode.

This logic optimizations are mainly of two types:

  -->  Combinational logic optimizations.

            Constant propagation (Direct optimization)

            Squeezing the logic to get optimized version of the output saving area as well as power

  -->  Sequential logic optimizations.

       Basic
           Sequential Constant propagation
           
	   Retiming 
	         Retiming is done when there is requirement distribution of the combinational logic between the  flip flops
           
	   Unused Flop Removal 
           
	   Clock Gating

  	Advanced
           State Optimization 
           Sequential logic cloning :  [Logic cloning is done during physical aware synthesis when there is a huge positive slack is present]


    
 **Optimization of Unloaded Outputs**

Optimizing unloaded outputs typically involves reduction of power consumption , area, delay for unused or idle pins . It refers to flip-flops whose outputs are not connected to any subsequent logic gates or do not affect the functionality of the overall circuit. so these flip flops can be removed thus retaining the function and reducing the area , power of the design.

**Controlling sequential optimization**

**- compile_seqmap_propagate_constants** If this parameter is not set to true, the sequential constant propagating circuits are retained in circuit and not optimized.

**- compile_delete_unloaded_sequential_cells** If this parameter is not set to true, it doesn't remove the counter cells as discussed, it retains all counters in the circuit.

**- compile_register_replication** If this parameter is set to true, this replicates the registers in cloning optimization so that timing is met.
                    
</details>


<details>
<summary> Labs on Sequential and Combinational Optimization </summary>

 1. **Opt_check**
    
    The RTL code of the opt_check is as follows
    ```
    module opt_check (input a , input b , input c , output y1, output y2);
	wire a1;
	assign y1 = a?b:0;
	assign y2 = ~((a1 & b) | c);
	assign a1 = 1'b0;
    endmodule
    ```
    The above code optimized to a simple AND gate after optimization

      ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/6f0a16d5-1074-4e25-8323-17c8582ac286)

      ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/79909207-c9dd-4f2d-a346-46f989791062)

 2. **Opt_check2**

   The RTL code of the opt_check is as follows
    ```
   module opt_check2 (input a , input b , output y);
	assign y = a?1:b;
   endmodule
    ```
    After optimization it result in a simple OR gate

     ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/9569cd29-4f10-42a6-8ecb-e7ef4ca7359b)

3. **Opt_check3**
   
    The RTL code of the opt_check is as follows
    ```
   module opt_check3 (input a , input b, input c , output y);
	assign y = a?(c?b:0):0;
   endmodule
    ```
  The above code is actually supposed to get two multiplexers but after the optimization breaks down into 3 input AND gate as shown below

   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/d838e21d-69bd-4572-85d5-c14075568e3e)

4. **Opt_check4**
   
   The RTL code of the opt_check is as follows
    ```
   module opt_check4 (input a , input b , input c , output y);
 	assign y = a?(b?(a & c ):c):(!c);
   endmodule
    ```
     Finally it optimized to XNOR gate

   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/760c0e5c-03cd-423a-a15b-abb8fd8f6454)
   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/d1ab7238-d78c-480b-8d54-e32cb02a5f14)
   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/ded64aa4-8d0f-494b-841e-bdb436eaf34a)
   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/769be8db-047f-47c7-bebf-e8e5c6971b8c)

**Resource Sharing**

 Consider the example 
 ```
module resource_sharing_mult_check (input [3:0] a , input [3:0] b, input [3:0] c , input [3:0] d, output [7:0] y  , input sel);
	assign y = sel ? (a*b) : (c*d);

endmodule
```

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/d5520240-ab8d-4631-b23e-563ad0b1d59e)

The timing report without constraint to the design are as follows

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/4130e92d-d76e-4136-b4c6-8f9046571605)

when constraining design with max_delay 2.5 ns 
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/f2bd1695-c0e9-43a6-aa85-cefcf58e1283)

After optimization

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/1fefb331-4d0e-4551-a8f6-cb30ccd1993e)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/00448b3b-a051-4185-b2ef-7662474086d6)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/7b93010f-a530-4515-8315-d1d473f9075e)

**set_max_area 800**

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/5232a718-5879-4169-ae23-02bd5af0b933)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/8f0ac7e6-002d-4383-8935-1cb8f91ca0a4)


**Lab Sequential logic Optimizations**

In this optimization sequential constant propagation 1 traverses finally . But we can't directly connect VDD as due to noise logic may degrade hence we use TIE cells

Tie cells

Tie cells also known as tie-high and tie-low cells, are components used in design to ensure that fixed signal value are held at a logic level either 1 or 0 regardless of input condition. These cells are particularly useful in preventing floating or undefined states in digital circuit.

 **dff_const**
  ```ruby
   module dff_const1(input clk, input reset, output reg q);
	always @(posedge clk, posedge reset)
	begin
		if(reset)
			q <= 1'b0;
		else
			q <= 1'b1;
	end

  endmodule
  ```
As it is not a sequential constant we see the flops are present in logic

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/44d65d34-2b0d-4629-b6e4-0e24f98bc4e8)

**dff_const2**
```
module dff_const2(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b1;
	else
		q <= 1'b1;
end

endmodule
```
It is a sequential constant propagation so th flops are optimized also we could also see TIE cell

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/8b8a3ff1-391d-4f4a-9f42-857636593b3d)

If design rquirement is such that we want Flip flops or intermediate modules need to be intact we don't need to optimize the circuit

In such case we can use the following command to prevent constant sequential propagation

**set compile_seqmap_propagate_constants false**

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/30b6e064-f015-4610-8992-7ff627ff4850)

**dff_const3**
```
module dff_const3(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```
This is not an example of sequential constant propagation

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/8ae92186-7fac-463d-b237-9a84dff7a6b1)

**dff_const4**
```
module dff_const4(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b1;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/37027cdc-bdc6-402b-b80c-850ed66bf851)

**dff_const5**
```
module dff_const5(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
        begin
		q <= 1'b0;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```
begin
		q <= 1'b0;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end
endmodule
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/83915d25-3f94-47ba-855f-fc1499a9872e)

</details>

<details>
<summary>Special optimization</summary>

**Boundary Optimization**

The optimization of boundaries or interfaces between different components or modules within a design.

Aspect of Boundary optimization 

Placement Algorithms: Boundary optimization involves using placement algorithms to determine the optimal physical location of each module on the chip's layout. These algorithms consider factors like signal interconnect lengths, wire delays, and minimizing congested areas on the chip.

Routing Considerations : After placement, routing algorithms are used to create the physical wires that connect the module boundaries. Proper routing is essential for meeting timing constraints and minimizing power consumption.Following manhattan algorithm

Design Rules : Boundary optimization must adhere to manufacturing design rules and constraints imposed by the semiconductor fabrication process. These rules govern factors like minimum feature sizes, metal layers, and spacing requirements to ensure the manufacturability of the chip.

Boundary optimization is often an iterative process. Designers may need to make trade-offs between area, power, and timing to achieve the desired performance goals.

**Lab**

RTL Design code
```
module check_boundary (input clk , input res , input [3:0] val_in , output reg [3:0] val_out);
wire en;
internal_module u_im (.clk(clk) , .res(res) , .cnt_roll(en));

always @ (posedge clk , posedge res)
begin
	if(res)
		val_out <= 4'b0;
	else if(en)
		val_out <= val_in;	
end
endmodule

module internal_module (input clk , input res , output cnt_roll);
reg [2:0] cnt;

always @(posedge clk , posedge res)
begin
	if(res)
		cnt <= 3'b0;
	else
		cnt <= cnt + 1;
end

assign cnt_roll = (cnt == 3'b111);

endmodule
```
Loading the design and compiling

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/89704c5a-1ad4-49cd-bc55-889cf0244d16)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/61707ba0-e51d-4adb-8374-d096c8c57f32)

No boundary , Entire design is optimized
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/6cb01c28-b2a4-46be-9c70-e8f73a7234c8)

If we don't want boundary optimization then we need to use the below command

**set_boundary_optimization <name_pin> false**

example : *set_boundary_optimization u_im false*

The following image shows the design with hierarchical module u_im in the design.
 ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/222527eb-dadb-4e9f-a4ae-7bff62509b65)

**Register Retiiming**

Register retiming is a technique used in design to optimize the performance of digital circuits by rearranging the registers in the circuit without changing its functionality. The primary goal of register retiming is to minimize the critical path delay, which is the longest path in the circuit from an input to an output.

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/2223e83c-614e-4563-aa4e-977952db5716)

Command used for retiming in the synthesis

**compile_ultra -retime**


**Lab**

Consider a example in which a 4-bit multiplier multiplying two 4-bit numbers and three 8-bit registers through which data is propagated to output.
```
module check_reg_retime (input clk , input [3:0] a, input [3:0] b , output [7:0] c , input reset);

wire [7:0] mult;
assign mult = a * b;
reg [7:0] q1;
reg [7:0] q2;
reg [7:0] q3;

always @ (posedge clk , posedge reset)
begin
	if(reset)
	begin
		q1 <= 8'b0;
		q2 <= 8'b0;
		q3 <= 8'b0;
	end
	else
	begin
		q1 <= mult;
		q2 <= q1;
		q3 <= q2;
	end
end
assign c = q3;

endmodule
```
The schematic before retime

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/70c81ab7-1ed8-402e-b6a6-0a97a13518d4)

After giving constraint to the design with the given specs when we give report_timing we get violated report on the input side of design

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/69942cc8-bbf6-4c64-be1f-085c60ea0f22)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/c279844e-8996-428f-8555-07aab4314484)

In order to rectify this we retime it using following command

**compile_ultra -retime**

The violation are reduces and is now only on output path

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/cdbf2dbd-93b0-4cea-86c0-5d2e2140549a)

The multiplier used in this has the following design

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/700bc775-9cb0-4c05-8946-f0685c85339d)


**Isolating Output ports**

In VLSI isolating output ports often refers to ensuring that the output signals of a circuit or module are properly isolated and do not interfere with each other or with other parts of the system. This isolation is crucial for maintaining signal integrity, reducing noise, and preventing unintended interactions.

Output port isolation in VLSI design:

1. **Output Ports**: In VLSI design, an integrated circuit typically includes multiple output ports, which are points where the circuit provides data or information to the external world. These output ports can be connected to various external devices or other parts of the circuit.

2. **Signal Integrity**: In a complex IC, signals on different output ports may have different requirements, such as timing, voltage levels, and signal quality. Undesirable interactions between these signals can lead to signal integrity issues, including noise, glitches, and crosstalk.

3. **Output Port Isolation**: Output port isolation is the practice of designing the circuit in such a way that the signals on one output port do not interfere with or affect the signals on another output port. This is achieved by implementing various isolation techniques:

   - **Physical Separation**: Physically separating the output buffers associated with different output ports can reduce the chances of signal interference. This may involve placing output buffers in different areas of the chip or on separate metal layers.

   - **Buffer Design**: Careful selection of buffer types and configurations can help reduce interference. For example, using differential signaling (such as LVDS or differential ECL) can improve noise immunity compared to single-ended signaling.

   - **Shielding**: Adding shielding structures, such as metal layers or well-taps, around sensitive output ports can help block electromagnetic interference (EMI) and minimize crosstalk.

   - **Timing Constraints**: Properly defining and enforcing timing constraints for different output ports can prevent timing violations and ensure that signals do not overlap or cause setup and hold time violations.

Consider a below example, which contains more number of outputs to be connected after implementation of design, this may cause a violation of internal delays as cell delay is a function of load capacitance. Inorder to avoid internal failure, we isolate by inserting a buffer at output port. So, the buffer drives the external load.Now, the internal paths are decoupled from output paths.

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/abeb0616-c238-47ef-b881-0af045e2a337)

**Lab**

RTL Design code
```
module check_boundary (input clk , input res , input [3:0] val_in , output reg [3:0] val_out);
wire en;
internal_module u_im (.clk(clk) , .res(res) , .cnt_roll(en));

always @ (posedge clk , posedge res)
begin
	if(res)
		val_out <= 4'b0;
	else if(en)
		val_out <= val_in;	
end
endmodule


module internal_module (input clk , input res , output cnt_roll);
reg [2:0] cnt;

always @(posedge clk , posedge res)
begin
	if(res)
		cnt <= 3'b0;
	else
		cnt <= cnt + 1;
end

assign cnt_roll = (cnt == 3'b111);

endmodule
```
The Design before isolating the ports 

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/f5cac34c-226f-475c-9405-0f27804b643a)

The timing report before isolating ports

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/cab91262-12e8-4d5d-8d26-6ffb006d3325)

The command for isolating ports

**set_isolate_ports -type buffer \[all_outputs]**

The Design after isolating the ports
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/7dd7ea74-0d7e-4029-a071-f4612c956464)

The timing report after isolating the port

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/68bdeff5-b694-4698-9e0c-1367b2b19e6d)


**Multicycle path**

A multicycle path in design refers to a timing path within a digital circuit where a signal takes multiple clock cycles to propagate from a source register (or flip-flop) to a destination register. This is in contrast to a single-cycle path where the signal must propagate and settle within a single clock cycle.

Multicycle paths are typically encountered in digital designs when specific timing constraints or requirements allow for signals to have longer propagation delays. These paths are often used for various purposes, including achieving certain functionalities, optimizing critical paths, or accommodating variations in clocking schemes.

For a single cycle path, the setup check is done at the consecutive edge of the flop and hold is done at the same edge of the flop. Hold is always checked edge before setup. For a half cycle path, the setup check is done at the subsequent fall edge of the flop and hold is done at the previous falling edge of the flop. In a half cycle path, setup is very tight and hold is relaxed. For a multicycle path, the -setup switch specifies the number of cycles after the launch edge, it needs to check setup and the -hold switch specifies the number of cycles the launch edge moves to check with capture.

**Lab**

The RTL design code 
```
module mcp_check (input clk , input res  , input [7:0] a , input [7:0] b, input en , output reg [15:0] prod);

reg valid; 

always @ (posedge clk , posedge res)
begin
	if(res)
		valid <= 1'b0;
	else 
		valid <= en;
end
always @ (posedge clk , posedge res)
begin
	if(res)
		prod <= 16'b0;
	else if (valid)
		prod <= a * b;
end

endmodule
```
The tcl file for constraints

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/9d0ab020-0de3-40f1-98a4-acd8cd053dda)

The report before optimization

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/bbdd170d-16e3-4531-bbf6-c683b2daabc7)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/8a86403a-a3f2-4779-b230-fa9e6ab975e8)

Now using the command 

**set_multicycle_path -setup 2 -to prod_reg\[*]/D -from \[all_inputs]**

The input report timing 
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/656e8fdd-1154-403d-bde0-603e10630149)

When we give report_timing -delay min we get the violated report as we have only optimized setup path and not hold path

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/b0f1c73a-a885-4c13-aaa8-3bb81bb6b68e)

Then optimizing the hold path by the following command

set_multicycle_path -hold 1 -to prod_reg\[*]/D -from \[all_inputs] -to prod_reg\[*]/D 

report_timing after optimizing hold path
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/0c6d50bb-9aa2-4d79-8a04-87313a61460d)

But the output slack is not met , because high load on the output side
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/070308f6-d44a-4207-87ff-27be0470f1b9)

By isolating the port we can rectify this

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/33941330-c0b5-4666-80a3-3a6df20600bf)

**FALSE PATH**

A false path constraint is a timing constraint used in design during synthesis to inform the synthesis tool that a particular path in the design should not be considered for timing analysis. False path constraints are applied to paths that are not relevant for the overall functionality or timing of the circuit, and they help improve synthesis and optimization results by excluding these paths from the timing analysis process. False path constraints are especially useful when dealing with paths that are not critical to the circuit's operation and should not be optimized for timing.

Here's how you can apply a false path constraint using Synopsys Design Constraints (SDC),  command:

**SDC Command for Applying a False Path Constraint:**

set_false_path -from <source_pins> -to <destination_pins> [-through <through_pins>]

- `set_false_path`: This command is used to specify that a particular path should be treated as a false path.

- `-from <source_pins>`: Replace `<source_pins>` with the list of source pins or elements for the path you want to designate as a false path. These are typically the output pins of certain elements in your design.

- `-to <destination_pins>`: Replace `<destination_pins>` with the list of destination pins or elements for the path you want to designate as a false path. These are typically the input pins of certain elements in your design.

- `-through <through_pins>` (optional): If you want to specify that the path is a false path only when it goes through specific pins or elements, you can use this option to specify those pins or elements.

**Explanation:**
A false path constraint is applied to tell the synthesis tool and timing analysis tools (like static timing analyzers) that a particular path should be ignored during timing analysis. This means that the tools will not consider this path when calculating setup times, hold times, or other timing characteristics.

False paths are often used for the following reasons:

1. **Irrelevant Paths**: In complex designs, there may be paths that are not critical for the circuit's operation, such as debug paths, bypass paths, or paths that are intentionally designed for slower operation. Applying a false path constraint allows you to exclude these paths from timing analysis.

2. **Optimization Control**: By marking certain paths as false paths, you can prevent the synthesis tool from applying aggressive optimization techniques that might negatively impact the circuit's performance. This is especially useful when dealing with sensitive paths that should not be overly optimized.

3. **Tool Efficiency**: Excluding non-critical paths from timing analysis can improve tool efficiency and reduce analysis time, especially in large designs.

 Apply a false path constraint in SDC:

tcl
# Specify that the path from the output "output_reg" to the input "input_reg" is a false path
set_false_path -from \[get_pins output_reg/Q] -to \[get_pins input_reg/D]


In this example, the `output_reg` and `input_reg` represent the source and destination registers of the false path, respectively. The `-from` and `-to` options specify the pins of these registers. By applying this false path constraint, you inform the synthesis tool that this particular path should not be considered for timing analysis, helping you achieve better control and optimization of your design.
</details>


## Day-10-Quality Checks

<details>
 <summary> Introduction </summary>

**Sanity checks:**

Sanity checks in VLSI serve as a checkpoint to decide whether the testing for design-build may proceed or not. The main purpose of this testing is to ensure that the changes or planned features are operating as intended. To ensure that the input received from the library team and synthesis team is correct or not. If we are not doing these checks then it creates problems in later stages of design.

      Design/netlist checks
      SDC checks
     Library checks

Design checks:
To check if current design is consistent or not
It checks the quality of netlist and identifies:
      
       Undriven input ports
       Unloaded outputs
       Floating pins
       Multidriven nets 
       Unconstrained pins 
       Pin mismatch counts between an instance and its reference
       Tristate buses with non-tristate drivers
       Wire loops across hierarchies
 
 **check_design** command 
 
Checks for multi driven nets, floating nets/pins, empty modules.
Pins mismatch, cells or instances without I/O pins/ports etc. 

SDC Checks:

* If any unconstrained paths exist in the design then PNR tool will not optimize that path, so these checks are used to report unconstrained paths 
* Checks whether the clock is reaching to all the clock pin of the flip-flop.
* Check if multiple clock are driving same registers
* Check unconstrained endpoints 
* Port missing input/output delay.
* Port missing slew/load constraints.

**check_timing** command

Library checks:

It checks the quality of Physical and logical library

**check_library**
This command shows the library type & its version, units of time, capacitance, leakage power, and current. It shows the number of cells missing, the number of metal or pins missing in the physical and logical library.


**Propagation Delay :**
Propagation delay, in the context of digital electronics and integrated circuits, refers to the time it takes for an electrical signal to travel from the input of a digital logic gate or circuit to its output. It is a critical parameter in digital design because it affects the speed and performance of the circuit. Propagation delay is typically measured in time units, such as nanoseconds (ns) or picoseconds (ps), and it depends on various factors, including the specific technology used, the length of interconnecting wires, and the complexity of the circuit.

**Rising Edge Propagation Delay (tplh)**: This is the time it takes for the output signal to transition from a low (0) to a high (50% of Vdd crossing) level after the input signal has made a similar transition.

**Falling Edge Propagation Delay (tphl)**: This is the time it takes for the output signal to transition from a high (50% of Vdd crossing) to a low (0) level after the input signal has made a similar transition.

##Some Command Usage


Before using those commands some basic steps

In Design Compiler tool  we load our design, and we check the design

Ensure that you have compiled your design with the necessary constraints files.

Run the timing analysis by entering the **report_timing** command in the Design Compiler command-line interface. Here's a basic syntax:

   report_timing -from <source> -to <destination>
   
   You can also add additional options and constraints to refine the analysis, such as specifying clock constraints, input delays, and output delays.

 **View the Report**: Design Compiler will generate a timing report that includes information about setup time, hold time, clock-to-q delays, and more. You can view this report in the shell or append it to a file for complete scenario

Here's a simplified example of how to use the `report_timing` command:


# Analyze the timing from input signal A to output signal Z
report_timing -from A -to Z

By using the `report_timing` command, you can look for timing violations and make necessary optimizations to meet your design's timing requirements, ensuring that it is functioning correctly at the specified clock frequency.

The `report_timing` command in Synopsys Design Compiler is a powerful tool for analyzing the timing characteristics of a synthesized digital design. It provides various options to specify which timing paths or constraints you want to analyze. Let's break down the key options you mentioned:

1. `-from <source>`: Start point for timing analysis. You can use a specific signal name or a logical expression to define the source. For example:

  **report_timing -from input_IN**

   This command will analyze timing paths starting from the signal named input_IN.

3. `-to <destination>`: This option specifies the destination signal or path up to which you want to analyze timing. Similar to the `-from` option, you can use a signal name or logical expression. For example:

 **report_timing -to output_OUT**

  This command will analyze timing paths up to the signal named `output_Z`.

**-fall_from <source>` and `-rise_from <source>** These options allow you to specify whether you want to analyze falling-edge or rising-edge timing paths from the given source. Timing analysis often considers both rising and falling edges of a clock signal, so you can use these options to focus on one edge if needed. For example:

   report_timing -fall_from clk -to output_Q

   This command will analyze falling-edge timing paths from the clock signal to the output signal output_Q.

`-delay_type max/min`: These options specify whether you want to report the maximum or minimum delay for the timing paths being analyzed. Depending on your design goals, you may want to optimize for maximum delay (worst-case performance) or minimum delay (best-case performance). For example:

   report_timing -from input_IN -to output_OUT -delay_type max
   
This command will report the maximum delay from `input_IN` to `output_OUT`.

Now, let's combine these options in a more comprehensive example:

```
# Analyze the maximum falling-edge delay from input IN to output OUT
report_timing -fall_from input_A -to output_Z -delay_type max
```

In this command, we are specifically interested in the worst-case (maximum) falling-edge delay from input_IN to output_OUT. This information can help identify critical timing paths that may need optimization to meet your design's performance requirements.

By using various combinations of these options, you can customize your timing analysis to focus on specific aspects of your design and identify potential timing violations or optimization opportunities.

The `report_timing` command with the `-max paths -nworst` options in Synopsys Design Compiler is used to report the paths with the maximum (worst-case) timing delays in a digital design. This command is particularly useful for identifying the most critical timing paths in your design, which can be crucial for meeting your design's performance requirements. Let's break down this command and explain its usage:


`report_timing`: This is the main command for timing analysis in Design Compiler.

`-max paths`: This option instructs Design Compiler to report the paths with maximum delays. 

`-nworst`: This option specifies how many of the worst-case paths you want to report. You can specify a numerical value to limit the number of paths reported. For example, `-nworst 3` will report the 3 sluggiest paths.


   ```shell
   report_timing -max paths -nworst <number_of_paths>
   ```

<number_of_paths> : Specify the number of worst-case paths you want to report.

4. **View the Report**: Design Compiler will generate a report listing the specified number of paths with the longest delays. This report will include information about the paths' starting points, ending points, and the timing constraints.

 To use the `report_timing -max paths -nworst` command:

```shell
# Report the 5 worst-case timing paths in the design
report_timing -max paths -nworst 5
```

In this example, the command will identify and report the five paths in your design with the maximum delays. Helps in location critical paths in your design that may require optimization 

By using the `-max paths -nworst` options, you can quickly focus on the most critical timing paths in your design, allowing you to prioritize optimization efforts and make informed decisions about your design's overall performance.

 **Report Many Critical Paths**:

   ```shell
   # Report the 20 worst-case timing paths in the design
   report_timing -max paths -nworst 20
   ```
</details>

<details>
 <summary> LABs </summary>

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/d4c10d72-f176-437c-8445-285de2905cff)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/11f9cd6f-cf0d-4de4-bcc0-e58309184568)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/67800a72-fc3b-4c87-8615-581ab3f3eaaf)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/f280b6b0-7c6f-48fc-91d4-c2bd5c694270)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/eaf62a75-567a-4866-9edf-ca993c5b18ee)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/9c13f691-7931-4e2e-964c-e2f1f2d8ef13)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/b1a6aeda-0002-485e-81d1-afdd35cd72c3)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/27776866-b4a9-4040-a35f-18c7e938fd5f)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/509e8789-23d9-46b6-8efa-a687df30f143)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/bfee4a44-7d76-4062-95ef-d95325bff53a)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/f303d70a-68e6-464f-a408-1ca21b0de225)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/56d946cf-d648-45ec-8165-35b39c58d0ff)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/1f6dbaa9-ee36-4291-b1e2-fb9f9515c8a5)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/7ecfc2fd-754e-4cd5-872b-d658f59b5b61)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/a3d33dd4-a49e-4805-b13a-e5e3cf1fd74f)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/25c34e32-4698-49e7-b67a-94eaaecf6c18)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/4a632416-1375-4bd0-97e3-afda4e6b7c2c)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/c13bd022-5499-4e2e-bb1b-714c668f0785)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/b52bdb5b-8e60-4d47-bf83-ba6c037b0ca7)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/fb5d85a5-4c1b-4b78-9f6e-7eee425abbd2)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/6b67bba0-d0bf-43e8-b99d-e29397ec5e00)

</details>

## Day-11 SOC
 <details>
 <summary>SoC</summary>
**Describing chip used in Oneplus Nord CE 2 LITE is Snapdragon 695**

The Qualcomm Snapdragon 695 is a mid-range mobile system-on-a-chip (SoC) designed and manufactured by Qualcomm. It was announced in 2021 and was part of Qualcomm's Snapdragon 6-series, which is known for offering a good balance between performance and power efficiency.

**CPU Architecture:**
The Snapdragon 695 features a  Qualcomm Kryo 619 CPU, which is an octa-core processor.It features 8 Kryo 660 called cores (64-Bit capable) that are divided in two clusters. A fast cluster of two cores with up to 2.2 GHz based on the ARM Cortex-A78 design. Compared to the previous SD690, the SD695 is now manufactured in 6nm (instead of 8nm) and offers a higher clocked performance cluster. However, the SD695 only supports Wi-Fi 5 instead of Wi-Fi 6 of the SD690.  It's divided into two clusters:

 **1x high-performance core**: This core is designed to handle demanding tasks and offers high single-threaded performance.
 **1x power-efficient core**: This core is optimized for power efficiency to handle light tasks and improve battery life.
 **6x power-efficient cores**: These cores are used for general-purpose computing and background tasks, balancing performance and efficiency.

**GPU:**
he Qualcomm Adreno 619 is a mobile graphics card for mid-range smartphones and tablets (mostly Android based). It is included in the Qualcomm Snapdragon 750G SoCs and based on the Adreno 600 architecture (like the Adreno 630, which should be fully compatible in software). The performance is 60% better compared to the Adreno 612 graphics card and in our benchmarks on par with the 700 series cards.

**Connectivity:**
In addition to the 8 CPU cores, the SoC integrates a lower mid range Adreno 619 GPU, a X51 5G radio (up to 2.5 Gbits download, no mmWave), a 802.11ac (Wi-Fi 5, 8x8 sounding, Dual Band, 2x2), a Bluetooth 5.2 radio, satellite positioning (GPS, QZSS, GLONASS, SBAS, Beidou and Galileo) and a video engine (support for H.265, H.264, VP8 and VP9).

**AI and Machine Learning:**
The Snapdragon 695 includes an AI Engine that supports on-device AI and machine learning tasks.long-standing prowess in AI is thoughtfully incorporated into the Snapdragon 695, steering enhancements from smart imaging techniques to predictive user-interface responses.It can handle functions like image recognition, voice recognition, and various AI-driven enhancements for camera and gaming experiences.

**Camera and Multimedia:**
The SoC supports cameras with impressive capabilities. It can handle up to a 108-megapixel single camera or a 36-megapixel dual-camera setup. It also supports 4K video capture and playback, HDR10+ content, and HEIF image format for efficient storage.

**Display Support:**
The Snapdragon 695 supports Full HD+ displays with high refresh rates, making it suitable for mid-range smartphones with smooth and responsive screens.

**Battery Efficiency:**
Qualcomm's chipsets are known for their power efficiency, and the Snapdragon 695 is no exception. The combination of CPU and GPU cores, AI optimizations, and the integrated 5G modem is designed to strike a balance between performance and battery life.

**Manufacturing Process:**
Depending on the exact model of processor CPUs are built using 6nm tech node
</details>

## Day-11 SOC
 <details>
 <summary>BabySOC MODEL</summary>

 **RTL code for UP_COUNTER**

```
module up_counter (input clk , input reset, output reg [2:0] count);
always @ (posedge clk , posedge reset)
begin
	if(reset)
		count <= 4'b000;
	else
		count <= count + 1;
end
endmodule
```
**TEST BENCH for UP_COUNTER**

```
`timescale 1ns / 1ps
module tb_upcounter;
	reg clk, reset;
	wire [2:0] count;

      	up_counter uut (
		.clk(clk),
		.reset(reset),
		.count(count)
	);

	initial begin
	$dumpfile("tb_upcounter.vcd");
	$dumpvars(0,tb_upcounter);
        clk = 0;
	reset = 1;
	#2000 $finish;
	end

always #10 clk = ~clk;
always #100 reset=0;
endmodule
```
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/66ea92aeb518fad0ed29622de9034fe2189ab2cc/Samsung_PD_%23day11/4(up%20counter).png">

**DAC**
TO model DAC commands used :-

```
iverilog avsddac.v avsddac_tb_test.v
./a.out
gtkwave avsddac_tb_test.vcd
```
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/66ea92aeb518fad0ed29622de9034fe2189ab2cc/Samsung_PD_%23day11/2(dac%20wave%20sim).png">

**PLL**
 
To model PLL commands used are:-
```
iverilog avsd_pll_1v8.v pll_tb.v
./a.out
gtkwave test.vcd
```
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/66ea92aeb518fad0ed29622de9034fe2189ab2cc/Samsung_PD_%23day11/1(pll%20wave%20sim).png">

**RVMYTH**
For rvmyth following is the command:-
	
```
iverilog mythcore_test.v tb_mythcore_test.v 
./a.out
gtkwave tb_mythcore_test.vcd
```
```
[aviral.s@ssirlab03 module]$ iverilog mythcore_test.v tb_mythcore_test.v 
[aviral.s@ssirlab03 module]$ ./a.out
VCD info: dumpfile tb_mythcore_test.vcd opened for output.
[aviral.s@ssirlab03 module]$ gtkwave tb_mythcore_test.vcd
```
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/66ea92aeb518fad0ed29622de9034fe2189ab2cc/Samsung_PD_%23day11/3(mythcore%20wave%20simn).png">

**VSDBABY SOC TOP MODULE**

Interfacing all the modules following is the command:-
```
iverilog vsdbabysoc.v testbench.v avsdpll.v avsddac.v mythcore_test.v
./a.out
gtkwave dump.vcd
```
```
[aviral.s@ssirlab03 module]$ iverilog vsdbabysoc.v testbench.v avsdpll.v avsddac.v mythcore_test.v
[aviral.s@ssirlab03 module]$ ./a.out
VCD info: dumpfile dump.vcd opened for output.
[aviral.s@ssirlab03 module]$ gtkwave dump.vcd
```

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/66ea92aeb518fad0ed29622de9034fe2189ab2cc/Samsung_PD_%23day11/4(soc%20wave%20sim).png">

</details>

## Day-13-Post-Synthesis Simulation of BabySoC

<details>
<summary> Post-Synthesis Simulation </summary>

**Synthesis:**
It's the  process of transforming a high-level description of a hardware design into a lower-level representation that comprises logic gates and flip-flops. 

**Pre-Synthesis:** 
The pre-synthesis phase in digital circuit design is a critical step that occurs before the actual synthesis process. It involves several intermediate steps making the design ready for synthesis, which leads to the creation of the physical hardware. 

**Post-Synthesis:** 
The post-synthesis phase in digital circuit design occurs after the synthesis process has translated the high-level RTL (Register-Transfer Level) design into a gate-level representation. This phase further optimizes the design, ensuring that it meets performance, area, and power constraints.

We perform the pre and post synthesis to figure out is there any simulation and synthesis mismatch.

 **Pre-Synthesis Simulation**
   - **Functionality Check**: Pre-synthesis simulation is primarily focused on verifying the logical functionality of the design. It checks whether the design operates as intended based on the high-level    RTL(Register Transfer Level) description.
   - **Early Validation**: It allows designers to find and correct logical errors and functional issues before the design is synthesized. This is crucial for identifying and fixing design flaws early in     the development cycle, which can save a lot of time and resources.
   - **Fast Execution**: Pre-synthesis simulations are usually faster than post-synthesis simulations because they don't consider gate-level delays and are working in tandem with the original RTL code.

 **Post-Synthesis Simulation**
   - **Timing Analysis**: Post-synthesis simulation considers gate-level delays, which means it takes into account the actual propagation delays of logic gates, interconnects, and other physical components. This helps in analyzing the timing behavior of the design.
   - **Accurate Timing Violation Detection**: It can detect and report timing violations such as setup and hold time violations, clock-to-q delays, and other timing-related issues. This is essential for ensuring that the design meets the required performance criteria.
   - **Power Analysis**: Post-synthesis simulations can also provide insights into power consumption, which is important for battery-powered or low-power designs.
   - **Realistic Behavior**: It provides a more realistic view of how the design will behave once implemented in hardware.

 **Mismatch Detection**
   - Both pre-synthesis and post-synthesis simulations are used to detect mismatches, but they focus on different aspects. Pre-synthesis simulation can identify logical mismatches early in the design phase, while post-synthesis simulation helps identify timing-related mismatches and issues caused by incorrect usage of operators and inference of latches.

In summary, pre-synthesis simulation is essential for early design validation and catching logical errors, while post-synthesis simulation is crucial for ensuring that the design meets timing requirements and for obtaining a realistic view of how the design will perform in hardware. Both types of simulation are complementary and necessary for a comprehensive design verification process.

**GLS: a brief introduction:** <br>
   **Gate Level Perspective**: The term "gate level" refers to the netlist representation of a circuit, generated through logic synthesis.

   **Comprehensive Netlist**: The netlist view encompasses a detailed connection list that includes gates and IP models, complete with their functional and timing characteristics.
   
   **Simulation Environments**: RTL simulation operates within a zero-delay environment, where events primarily occur on the active clock edge. On the other hand, GLS can be configured for zero delay but      is often utilized in unit delay or full timing modes.

**Conversion of .lib to .db** it's required so that DC could read the library properly

Git cone all the .lib files then convert it in .db using lc_shell :

**For PLL lib file**
Commands:
```
lc_shell> read_lib avsdpll.lib
Reading '/home/aviral.s/ws_2/VSDBabySoC/src/lib/avsdpll.lib' ...
Error: Line 54, Cell 'avsdpll', The '//pin' attribute/group name cannot be specified here. (LBDB-76)
Error: Line 58, Cell 'avsdpll', /home/aviral.s/ws_2/VSDBabySoC/src/lib/avsdpll.lib: syntax error on line 58 at or near '}'. (PARSE-1)
Error: Line 66, Cell 'avsdpll', The '//pin' attribute/group name cannot be specified here. (LBDB-76)
Error: Line 70, Cell 'avsdpll', /home/aviral.s/ws_2/VSDBabySoC/src/lib/avsdpll.lib: syntax error on line 70 at or near '}'. (PARSE-1)
Error: Line 72, Cell 'avsdpll', The '//pin' attribute/group name cannot be specified here. (LBDB-76)
Error: Line 76, Cell 'avsdpll', /home/aviral.s/ws_2/VSDBabySoC/src/lib/avsdpll.lib: syntax error on line 76 at or near '}'. (PARSE-1)
Warning: Line 18, Cell 'avsdpll', The 'area' attribute is not specified. Using 0.00. (LBDB-172)
Warning: Line 1, The 'default_output_pin_rise_res' attribute is not specified. Using 0.00. (LBDB-172)
Warning: Line 1, The 'default_inout_pin_fall_res' attribute is not specified. Using 0.00. (LBDB-172)
Warning: Line 1, The 'default_inout_pin_rise_res' attribute is not specified. Using 0.00. (LBDB-172)
Warning: Line 1, The 'default_fanout_load' attribute is not specified. Using 1.00. (LBDB-172)
Warning: Line 1, The 'default_slope_rise' attribute is not specified. Using 0.00. (LBDB-172)
Warning: Line 1, The 'default_output_pin_fall_res' attribute is not specified. Using 0.00. (LBDB-172)
Warning: Line 1, The 'default_intrinsic_rise' attribute is not specified. Using 1.00. (LBDB-172)
Warning: Line 1, The 'default_slope_fall' attribute is not specified. Using 0.00. (LBDB-172)
Warning: Line 1, The 'default_intrinsic_fall' attribute is not specified. Using 1.00. (LBDB-172)
Warning: Line 1, The 'default_inout_pin_cap' attribute is not specified. Using 1.00. (LBDB-172)
Warning: Line 1, The 'default_input_pin_cap' attribute is not specified. Using 1.00. (LBDB-172)
Warning: Line 1, The 'default_output_pin_cap' attribute is not specified. Using 0.00. (LBDB-172)
Warning: Line 19, Cell 'avsdpll', pin 'CLK', The 'CLK' Pin/bus on the 'avsdpll' cell has no 'function' attribute.
	The cell becomes a black box. (LIBG-16)

Technology library 'avsdpll' read successfully
1
lc_shell> write_lib avsdpll -format db -output avsdpll.db
Wrote the 'avsdpll' library to '/home/aviral.s/ws_2/VSDBabySoC/src/lib/avsdpll.db' successfully
1
lc_shell> ls
.   avsddac.db	 avsdpll.db
```
**For DAC lib file**
commands:
```
 lc_shell> read_lib avsddac.lib
Reading '/home/aviral.s/ws_2/VSDBabySoC/src/lib/avsddac.lib' ...
Warning: Line 27, Cell 'avsddac', The 'area' attribute is not specified. Using 0.00. (LBDB-172)
Warning: Line 1, The 'default_output_pin_rise_res' attribute is not specified. Using 0.00. (LBDB-172)
Warning: Line 1, The 'default_inout_pin_fall_res' attribute is not specified. Using 0.00. (LBDB-172)
Warning: Line 1, The 'default_inout_pin_rise_res' attribute is not specified. Using 0.00. (LBDB-172)
Warning: Line 1, The 'default_fanout_load' attribute is not specified. Using 1.00. (LBDB-172)
Warning: Line 1, The 'default_slope_rise' attribute is not specified. Using 0.00. (LBDB-172)
Warning: Line 1, The 'default_output_pin_fall_res' attribute is not specified. Using 0.00. (LBDB-172)
Warning: Line 1, The 'default_intrinsic_rise' attribute is not specified. Using 1.00. (LBDB-172)
Warning: Line 1, The 'default_slope_fall' attribute is not specified. Using 0.00. (LBDB-172)
Warning: Line 1, The 'default_intrinsic_fall' attribute is not specified. Using 1.00. (LBDB-172)
Warning: Line 1, The 'default_inout_pin_cap' attribute is not specified. Using 1.00. (LBDB-172)
Warning: Line 1, The 'default_input_pin_cap' attribute is not specified. Using 1.00. (LBDB-172)
Warning: Line 1, The 'default_output_pin_cap' attribute is not specified. Using 0.00. (LBDB-172)
Warning: Line 28, Cell 'avsddac', pin 'OUT', The 'OUT' Pin/bus on the 'avsddac' cell has no 'function' attribute.
	The cell becomes a black box. (LIBG-16)
Warning: Overwriting an old technology library '/home/aviral.s/ws_2/VSDBabySoC/src/lib/avsddac.db' file with a new one. (UIL-2)
1
lc_shell> write_lib avsddac -format db -output avsddac.db
Wrote the 'avsddac' library to '/home/aviral.s/ws_2/VSDBabySoC/src/lib/avsddac.db' successfully
1
lc_shell> read_lib a
avsddac.db
```
</details>

<details>
	<summary>Post-Synthesis of UP_COUNTER</summary> 

 **Gate level Simulation of 3-bit UP_COUNTER** 

The following are the sequence of steps for simulating the output:

```
iverilog <netlist_file_name> <testbench>
./a.out
gtkwave <vcd_file_name>

module up_counter (input clk , input reset, output reg [2:0] count);
always @ (posedge clk , posedge reset)
begin
	if(reset)
		count <= 3'b000;
	else
		count <= count + 1;
end
endmodule
```
**Synthesis of UP_COUNTER using DC shell:** 
The following are the sequence of steps:
```
set target_library <path_of_the_target_library>
set linl_library {* <path_of_the_target_library>}
read_verilog <file_name.v>
link
compile_ultra
write -f verilog -out up_counter_net.v // this file will be used when we'll simulate by dumping netlist and test bench of counter
write -f ddc -out up_counter.ddc
design_vision> read_ddc up_counter.ddc
```
<img  width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/7e1e88e6540185a13156cac1038bbc76cca755e5/Samsung_PD_%23Day13/3(up%20counter%20schematic).png">

The 'iverilog' command utilizes the simulated gate-level netlist and the same testbench for post-synthesis simulation. 
Running './a.out' generates a VCD format file corresponding to the netlist, which can be viewed using 'gtkwave'.

```
[aviral.s@ssirlab03 module]$ iverilog -DFUNCTIONAL -DUNIT_DELAY=#1 up_counter_net.v tb_up_count.v primitives.v sky130_fd_sc_hd.v 
[aviral.s@ssirlab03 module]$ ./a.out
VCD info: dumpfile tb_upcounter.vcd opened for output.
[aviral.s@ssirlab03 module]$ gtkwave tb_upcounter.vcd

GTKWave Analyzer v3.3.61 (w)1999-2014 BSI
```

The post-simulation output is as follows
<img  width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/7e1e88e6540185a13156cac1038bbc76cca755e5/Samsung_PD_%23Day13/4(up%20counter%20gls).png">
<img  width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/7e1e88e6540185a13156cac1038bbc76cca755e5/Samsung_PD_%23day11/4(up%20counter).png">
Thus the exact match between the post-synthesis and pre-synthesis outputs verifies the logical correctness of the design.

</details>

<details>
	<summary>Post Synthesis of BabySoC</summary>

BabySoc consists of three blocks -
1. RVMYTH
2. DAC
3. PLL
Here only RVMYTH is synthesizable and not DAC nor PLL.

We observe that the functionality remains consistent with the one compared to the pre-synthesis stage, where it calculates the sum of the first n natural numbers up to 1000 and then decrements in the same manner.
The following are the sequence of steps:
```ruby
set target_library <path_of_the_target_library>
set linl_library {* <path_of_the_target_library>}
read_verilog mythcore_test.v
link
compile_ultra
write -f verilog -out rvmyth_net.v
```
The netlist written here as 'out' represents the default output 'clk_gate' in the code. Hence, the 'current_design' is switched to 'core' and the resulting netlist is written out as follows: <br>
```ruby
current_design core
write -f verilog -out rvmyth_net.v
```
The processor's output increments in the same manner as it did at the pre-synthesis stage, confirming the proper definition of logic. 
The following commands are used to simulate the output waveform: <br>
```ruby
iverilog -DFUNCTIONAL -DUNIT_DELAY=#1 rvmyth_net.v tb_mythcore_test.v primitives.v sky130_fd_sc_hdd.v
./a.out
gtkwave tb_mythcore_test.vcd
```

**BabySoC post-synthesis:**
As only RVMYTH is synthesizable, we proceed to synthesis 'rvmyth' and subsequently verify its functionality with 'DAC' and 'PLL'.
The following are the sequence of steps:
```
set target_library <path_of_the_target_library>
set link_library {* <path_of_the_target_library>}
read_verilog mythcore_test.v
link
compile_ultra
write -f verilog -out mythcore_test_net.v
```
```
iverilog -DFUNCTIONAL -DUNIT_DELAY=#1 mythcore_test_net.v tb_mythcore_test.v primitives.v sky130_fd_sc_hdd.v
./a.out
gtkwave dump.vcd
```
```
[aviral.s@ssirlab03 module]$ gvim mythcore_test_net.v 
[aviral.s@ssirlab03 module]$ iverilog -DFUNCTIONAL -DUNIT_DELAY#1 mythcore_test_net.v tb_mythcore_test.v primitives.v sky130_fd_sc_hd.v
sky130_fd_sc_hd.v:12660: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:15094: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:19219: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:20338: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:21433: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:22681: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:27547: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:28109: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:43415: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:43851: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:44336: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:44722: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:47083: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:58039: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:58705: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:59893: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:64750: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:66038: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:67597: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:68795: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:71161: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:75662: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:79254: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:82629: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:88346: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:94608: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:96192: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
sky130_fd_sc_hd.v:100184: warning: macro UNIT_DELAY undefined (and assumed null) at this point.
[aviral.s@ssirlab03 module]$ gvim sky130_fd_sc_hd.v
[aviral.s@ssirlab03 module]$ gvim sky130_fd_sc_hd.v
[aviral.s@ssirlab03 module]$ iverilog -DFUNCTIONAL -DUNIT_DELAY=#1 mythcore_test_net.v tb_mythcore_test.v primitives.v sky130_fd_sc_hd.v
[aviral.s@ssirlab03 module]$ ./a.out
VCD info: dumpfile tb_mythcore_test.vcd opened for output.
```
<img  width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/7e1e88e6540185a13156cac1038bbc76cca755e5/Samsung_PD_%23Day13/1(mythcore%20sim%20wave).png">

```
[aviral.s@ssirlab03 module]$ iverilog -DFUNCTIONAL -DUNIT_DELAY=#1 mythcore_test_net.v vsdbabysoc.v testbench.v avsddac.v avsdpll.v primitives.v sky130_fd_sc_hd.v
warning: Found both default and `timescale based delays. Use
         -Wtimescale to find the module(s) with no `timescale.
[aviral.s@ssirlab03 module]$ ./a.out
VCD info: dumpfile dump.vcd opened for output.
[aviral.s@ssirlab03 module]$ gtkwave dump.vcd

```
<img  width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/7e1e88e6540185a13156cac1038bbc76cca755e5/Samsung_PD_%23Day13/2(top%20module).png">

**TOP MODULE SCHEMATIC**
<img  width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9465b6d02719cebc2b7abd6b3e09ef4b28efa20c/Samsung_PD_%23Day13/5(top%20module%20schematic).png">
</details>

## Day 14 -   Synopsys DC and timing analysis

<details>
<summary>Theory</summary>

**What is synthesis?**
- Translation from RTL to gate level
- The design is transformed into gates, and links are established between the gates.
- This is distributed in the form of a file named netlist.

**What specifically is .lib?**
- A grouping of logical components
- Basic logic gates such as AND, OR, NOT, and so on are included.
- Contains diffrent variety of the same gate

**What does PVT stand for?**
- Temperature, Voltage, and Process
- Process: is used to describe variety. The parameters of transistors during manufacture cannot be similar throughout the device since layers are produced. (tt=typical-typical, ff=fast-fast, ss=slow-slow, fs=fast-slow, sf=slow-fast)
- Voltage: refers to the fluctuating voltages on the chip during operation, which can be caused by a variety of factors such as IO drop or supply noise caused by parasitic inductance.
- Temperature: relates to the chip's variable temperature during operation as a result of power dissipation in the MOS-transistors, which affects the delay on the cells.

**PVT corners**
- Designers model the chip at various process, voltage, and temperature corners in order to make it operate after manufacturing in all feasible scenarios. 
- These are referred to as corners. 
- All three of these characteristics have a direct impact on the cell's latency.
	
 **PVT terminologies**
- WNS (Worst Negative Slack): slack for the timing path with worst timing failure
	- If WNS is positive, the path has passed. Otherwise,it's failed.
- WHS (Worst Hole Slack):  slack for hold path with worst timing failure
- TNS (Total Negative Slack): sum of the total negative path slacks, or the sum of all WNS
	- If TNS = 0, the design meets timing. 
	- If positive, there is negative slack in the design (hence the design fails).
- THS (Total Hold Slack): sum of the total negative hold slack paths, or the sum of all WHS
	- If THS = 0, the design passed. 
	- If positive, the design failed.

 </details>

<details>

<Summary>LABS</Summary>

Steps
 Get all the .lib files by cloning https://github.com/Geetima2021/vsdpcvrd.git
 converting all the 13 .lib files to .db
  ```
  read_lib <library_name>
  write_lib <library_name> -f db -o <name_of_the_db_file>
  ```
Generating a constaraint file as **As without constraint file when minimize the clock period to 0.1 ns we were not seeing any violations neither setup nor hold**
  ```
   set_units -time ns
  create_clock -name MYCLK -per 2 [get_pins {pll/CLK}];

  set_clock_latency -source 1 [get_clocks MYCLK]
  set_clock_uncertainty -setup 0.5 [get_clocks MYCLK]; 
  set_clock_uncertainty -hold 0.4 [get_clocks MYCLK]; 

  set_input_delay -max 1 -clock \[get_clocks MYCLK] [all_inputs];
  set_input_delay -min 0.5 -clock \[get_clocks MYCLK] [all_inputs];
  set_output_delay -max 1 -clock \[get_clocks MYCLK] [all_outputs];
  set_output_delay -min 0.5 -clock \[get_clocks MYCLK] [all_outputs];

  set_input_transition -max 0.2 \[all_inputs];
  set_input_transition -min 0.1 \[all_inputs];

  set_max_area  800;

  set_load -max 0.2 \[all_outputs];
  set_load -min 0.1 \[all_outputs];
  ```
--> Now set the required db files (sky130.db,avsddac.db,avsdpll.db), read the design , link the library and do compile_ultra
--> Commands for implementing this are as follows
  ```
  reset_design
  set target_library { <sky130_PVT_corner> , avsddac.db , avsdpll.db}
  set link_library {* sky130_PVT_corner> , avsddac.db , avsdpll.db}
  read_verilog vsdbabysoc.v
  link
  source <constraints_file_name>
  compile_ultra
  report_qor
  ```

 ##Analysing the Design with respect to 13 libraries provided to us

 **Operating Condition Process- SS Temperature- 40C , Voltage- 1.44**
```
****************************************
Report : timing
        -path full
        -delay max
        -max_paths 1
Design : vsdbabysoc
Version: T-2022.03-SP5-1
Date   : Thu Sep 28 12:15:53 2023
****************************************

 # A fanout number of 1000 was used for high fanout net computations.

Operating Conditions: nom_pvt   Library: avsddac
Wire Load Model Mode: top

  Startpoint: c1/CPU_src1_value_a3_reg[3]
              (rising edge-triggered flip-flop clocked by MYCLK)
  Endpoint: c1/CPU_Xreg_value_a4_reg[2][24]
            (rising edge-triggered flip-flop clocked by MYCLK)
  Path Group: MYCLK
  Path Type: max

  Point                                                   Incr       Path
  --------------------------------------------------------------------------
  clock MYCLK (rise edge)                                 0.00       0.00
  clock network delay (ideal)                             1.00       1.00
  c1/CPU_src1_value_a3_reg[3]/CLK (sky130_fd_sc_hd__dfxtp_2)
                                                          0.00 #     1.00 r
  c1/CPU_src1_value_a3_reg[3]/Q (sky130_fd_sc_hd__dfxtp_2)
                                                          0.90       1.90 f
  c1/U1939/Y (sky130_fd_sc_hd__inv_1)                     0.22       2.12 r
  c1/U2766/Y (sky130_fd_sc_hd__nand2_4)                   0.17       2.29 f
  c1/U2025/Y (sky130_fd_sc_hd__nand2_1)                   0.16       2.45 r
  c1/U1744/Y (sky130_fd_sc_hd__nand2_1)                   0.11       2.57 f
  c1/U1743/Y (sky130_fd_sc_hd__inv_1)                     0.15       2.71 r
  c1/U1742/Y (sky130_fd_sc_hd__nand3_2)                   0.20       2.91 f
  c1/U1937/Y (sky130_fd_sc_hd__nand3_2)                   0.19       3.10 r
  c1/U2863/Y (sky130_fd_sc_hd__nand3_2)                   0.17       3.27 f
  c1/U2273/Y (sky130_fd_sc_hd__nand2_2)                   0.22       3.49 r
  c1/U1957/Y (sky130_fd_sc_hd__nand2_4)                   0.17       3.67 f
  c1/U1748/Y (sky130_fd_sc_hd__inv_2)                     0.21       3.87 r
  c1/U1747/Y (sky130_fd_sc_hd__clkinv_4)                  0.16       4.04 f
  c1/U2100/Y (sky130_fd_sc_hd__nand2_4)                   0.13       4.17 r
  c1/U2101/Y (sky130_fd_sc_hd__nand2_2)                   0.11       4.28 f
  c1/U500/Y (sky130_fd_sc_hd__xnor2_1)                    0.32       4.60 f
  c1/U1316/Y (sky130_fd_sc_hd__nand2_1)                   0.18       4.78 r
  c1/U1808/Y (sky130_fd_sc_hd__nand3_2)                   0.23       5.01 f
  c1/U2673/Y (sky130_fd_sc_hd__nand2_2)                   0.24       5.25 r
  c1/U2059/Y (sky130_fd_sc_hd__inv_4)                     0.16       5.40 f
  c1/U1960/Y (sky130_fd_sc_hd__inv_4)                     0.23       5.63 r
  c1/U4252/Y (sky130_fd_sc_hd__o22ai_1)                   0.17       5.80 f
  c1/CPU_Xreg_value_a4_reg[2][24]/D (sky130_fd_sc_hd__dfxtp_1)
                                                          0.00       5.80 f
  data arrival time                                                  5.80

  clock MYCLK (rise edge)                                 2.00       2.00
  clock network delay (ideal)                             1.00       3.00
  clock uncertainty                                      -0.50       2.50
  c1/CPU_Xreg_value_a4_reg[2][24]/CLK (sky130_fd_sc_hd__dfxtp_1)
                                                          0.00       2.50 r
  library setup time                                     -0.71       1.79
  data required time                                                 1.79
  --------------------------------------------------------------------------
  data required time                                                 1.79
  data arrival time                                                 -5.80
  --------------------------------------------------------------------------
  slack (VIOLATED)                                                  -4.01


 
****************************************
Report : qor
Design : vsdbabysoc
Version: T-2022.03-SP5-1
Date   : Thu Sep 28 12:16:13 2023
****************************************


  Timing Path Group 'MYCLK'
  -----------------------------------
  Levels of Logic:              21.00
  Critical Path Length:          4.80
  Critical Path Slack:          -4.01
  Critical Path Clk Period:      2.00
  Total Negative Slack:      -4215.69
  No. of Violating Paths:     1145.00
  Worst Hold Violation:          0.00
  Total Hold Violation:          0.00
  No. of Hold Violations:        0.00
  -----------------------------------


  Cell Count
  -----------------------------------
  Hierarchical Cell Count:          1
  Hierarchical Port Count:         12
  Leaf Cell Count:               7384
  Buf/Inv Cell Count:            2278
  Buf Cell Count:                  80
  Inv Cell Count:                2198
  CT Buf/Inv Cell Count:            0
  Combinational Cell Count:      6192
  Sequential Cell Count:         1192
  Macro Count:                      0
  -----------------------------------


  Area
  -----------------------------------
  Combinational Area:    31896.841153
  Noncombinational Area: 24138.149698
  Buf/Inv Area:           8892.278140
  Total Buffer Area:           472.95
  Total Inverter Area:        8419.32
  Macro/Black Box Area:      0.000000
  Net Area:                  0.000000
  -----------------------------------
  Cell Area:             56034.990851
  Design Area:           56034.990851


  Design Rules
  -----------------------------------
  Total Number of Nets:          7391
  Nets With Violations:             0
  Max Trans Violations:             0
  Max Cap Violations:               0
  -----------------------------------


  Hostname: ssirlab03

  Compile CPU Statistics
  -----------------------------------------
  Resource Sharing:                    2.19
  Logic Optimization:                 10.33
  Mapping Optimization:               55.69
  -----------------------------------------
  Overall Compile Time:               89.49
  Overall Compile Wall Clock Time:    91.06

  --------------------------------------------------------------------

  Design  WNS: 4.01  TNS: 4215.69  Number of Violating Paths: 1145


  Design (Hold)  WNS: 0.00  TNS: 0.00  Number of Violating Paths: 0
```

 **Operating Condition Process- SS Temperature- 40C , Voltage- 1.40**

 ``` 
****************************************
Report : qor
Design : vsdbabysoc
Version: T-2022.03-SP5-1
Date   : Thu Sep 28 15:16:14 2023
****************************************


  Timing Path Group 'MYCLK'
  -----------------------------------
  Levels of Logic:              18.00
  Critical Path Length:          5.47
  Critical Path Slack:          -4.82
  Critical Path Clk Period:      2.00
  Total Negative Slack:      -5077.17
  No. of Violating Paths:     1191.00
  Worst Hold Violation:          0.00
  Total Hold Violation:          0.00
  No. of Hold Violations:        0.00
  -----------------------------------


  Cell Count
  -----------------------------------
  Hierarchical Cell Count:          1
  Hierarchical Port Count:         12
  Leaf Cell Count:               7568
  Buf/Inv Cell Count:            2255
  Buf Cell Count:                  55
  Inv Cell Count:                2200
  CT Buf/Inv Cell Count:            0
  Combinational Cell Count:      6376
  Sequential Cell Count:         1192
  Macro Count:                      0
  -----------------------------------


  Area
  -----------------------------------
  Combinational Area:    31998.188302
  Noncombinational Area: 24260.767340
  Buf/Inv Area:           8824.713346
  Total Buffer Area:           409.14
  Total Inverter Area:        8415.57
  Macro/Black Box Area:      0.000000
  Net Area:                  0.000000
  -----------------------------------
  Cell Area:             56258.955642
  Design Area:           56258.955642


  Design Rules
  -----------------------------------
  Total Number of Nets:          7575
  Nets With Violations:             0
  Max Trans Violations:             0
  Max Cap Violations:               0
  -----------------------------------


  Hostname: ssirlab03

  Compile CPU Statistics
  -----------------------------------------
  Resource Sharing:                    2.16
  Logic Optimization:                 12.82
  Mapping Optimization:               50.44
  -----------------------------------------
  Overall Compile Time:               86.36
  Overall Compile Wall Clock Time:    87.96

  --------------------------------------------------------------------

  Design  WNS: 4.82  TNS: 5077.17  Number of Violating Paths: 1191


  Design (Hold)  WNS: 0.00  TNS: 0.00  Number of Violating Paths: 0

 **Operating Condition Process- SS Temperature- 40C , Voltage- 1.76**

 ****************************************
Report : qor
Design : vsdbabysoc
Version: T-2022.03-SP5-1
Date   : Thu Sep 28 15:25:00 2023
****************************************


  Timing Path Group 'MYCLK'
  -----------------------------------
  Levels of Logic:              20.00
  Critical Path Length:          2.48
  Critical Path Slack:          -1.24
  Critical Path Clk Period:      2.00
  Total Negative Slack:      -1255.17
  No. of Violating Paths:     1107.00
  Worst Hold Violation:          0.00
  Total Hold Violation:          0.00
  No. of Hold Violations:        0.00
  -----------------------------------


  Cell Count
  -----------------------------------
  Hierarchical Cell Count:          1
  Hierarchical Port Count:         12
  Leaf Cell Count:               6596
  Buf/Inv Cell Count:            1867
  Buf Cell Count:                  66
  Inv Cell Count:                1801
  CT Buf/Inv Cell Count:            0
  Combinational Cell Count:      5404
  Sequential Cell Count:         1192
  Macro Count:                      0
  -----------------------------------


  Area
  -----------------------------------
  Combinational Area:    29570.860431
  Noncombinational Area: 24066.831270
  Buf/Inv Area:           7629.817402
  Total Buffer Area:           506.74
  Total Inverter Area:        7123.08
  Macro/Black Box Area:      0.000000
  Net Area:                  0.000000
  -----------------------------------
  Cell Area:             53637.691701
  Design Area:           53637.691701


  Design Rules
  -----------------------------------
  Total Number of Nets:          6603
  Nets With Violations:             0
  Max Trans Violations:             0
  Max Cap Violations:               0
  -----------------------------------


  Hostname: ssirlab03

  Compile CPU Statistics
  -----------------------------------------
  Resource Sharing:                    2.18
  Logic Optimization:                 14.56
  Mapping Optimization:               51.59
  -----------------------------------------
  Overall Compile Time:               91.59
  Overall Compile Wall Clock Time:    93.23

  --------------------------------------------------------------------

  Design  WNS: 1.24  TNS: 1255.17  Number of Violating Paths: 1107


  Design (Hold)  WNS: 0.00  TNS: 0.00  Number of Violating Paths: 0
```

**Operating Condition Process- SS Temperature- 40C , Voltage- 1.35**
```
****************************************
Report : qor
Design : vsdbabysoc
Version: T-2022.03-SP5-1
Date   : Thu Sep 28 15:28:52 2023
****************************************


  Timing Path Group 'MYCLK'
  -----------------------------------
  Levels of Logic:              19.00
  Critical Path Length:          6.48
  Critical Path Slack:          -6.07
  Critical Path Clk Period:      2.00
  Total Negative Slack:      -6452.99
  No. of Violating Paths:     1192.00
  Worst Hold Violation:          0.00
  Total Hold Violation:          0.00
  No. of Hold Violations:        0.00
  -----------------------------------


  Cell Count
  -----------------------------------
  Hierarchical Cell Count:          1
  Hierarchical Port Count:         12
  Leaf Cell Count:               7532
  Buf/Inv Cell Count:            2332
  Buf Cell Count:                  41
  Inv Cell Count:                2291
  CT Buf/Inv Cell Count:            0
  Combinational Cell Count:      6340
  Sequential Cell Count:         1192
  Macro Count:                      0
  -----------------------------------


  Area
  -----------------------------------
  Combinational Area:    30965.948336
  Noncombinational Area: 24229.487320
  Buf/Inv Area:           9114.991738
  Total Buffer Area:           272.76
  Total Inverter Area:        8842.23
  Macro/Black Box Area:      0.000000
  Net Area:                  0.000000
  -----------------------------------
  Cell Area:             55195.435656
  Design Area:           55195.435656


  Design Rules
  -----------------------------------
  Total Number of Nets:          7538
  Nets With Violations:             0
  Max Trans Violations:             0
  Max Cap Violations:               0
  -----------------------------------


  Hostname: ssirlab03

  Compile CPU Statistics
  -----------------------------------------
  Resource Sharing:                    2.23
  Logic Optimization:                 11.67
  Mapping Optimization:               44.62
  -----------------------------------------
  Overall Compile Time:               79.63
  Overall Compile Wall Clock Time:    81.16

  --------------------------------------------------------------------

  Design  WNS: 6.07  TNS: 6452.99  Number of Violating Paths: 1192


  Design (Hold)  WNS: 0.00  TNS: 0.00  Number of Violating Paths: 0
```

**Operating Condition Process- SS Temperature- 40C , Voltage- 1.28**
```
****************************************
Report : qor
Design : vsdbabysoc
Version: T-2022.03-SP5-1
Date   : Thu Sep 28 15:33:57 2023
****************************************


  Timing Path Group 'MYCLK'
  -----------------------------------
  Levels of Logic:              19.00
  Critical Path Length:          8.75
  Critical Path Slack:          -8.93
  Critical Path Clk Period:      2.00
  Total Negative Slack:      -9617.33
  No. of Violating Paths:     1192.00
  Worst Hold Violation:          0.00
  Total Hold Violation:          0.00
  No. of Hold Violations:        0.00
  -----------------------------------


  Cell Count
  -----------------------------------
  Hierarchical Cell Count:          1
  Hierarchical Port Count:         12
  Leaf Cell Count:               7283
  Buf/Inv Cell Count:            2137
  Buf Cell Count:                  44
  Inv Cell Count:                2093
  CT Buf/Inv Cell Count:            0
  Combinational Cell Count:      6091
  Sequential Cell Count:         1192
  Macro Count:                      0
  -----------------------------------


  Area
  -----------------------------------
  Combinational Area:    30415.420381
  Noncombinational Area: 24164.424898
  Buf/Inv Area:           8406.812561
  Total Buffer Area:           223.96
  Total Inverter Area:        8182.85
  Macro/Black Box Area:      0.000000
  Net Area:                  0.000000
  -----------------------------------
  Cell Area:             54579.845279
  Design Area:           54579.845279


  Design Rules
  -----------------------------------
  Total Number of Nets:          7289
  Nets With Violations:             0
  Max Trans Violations:             0
  Max Cap Violations:               0
  -----------------------------------


  Hostname: ssirlab03

  Compile CPU Statistics
  -----------------------------------------
  Resource Sharing:                    2.29
  Logic Optimization:                 10.39
  Mapping Optimization:               56.51
  -----------------------------------------
  Overall Compile Time:              118.24
  Overall Compile Wall Clock Time:   120.26

  --------------------------------------------------------------------

  Design  WNS: 8.93  TNS: 9617.33  Number of Violating Paths: 1192


  Design (Hold)  WNS: 0.00  TNS: 0.00  Number of Violating Paths: 0
```

**Operating Condition Process- SS Temperature- 100C , Voltage- 1.4**
```
****************************************
Report : qor
Design : vsdbabysoc
Version: T-2022.03-SP5-1
Date   : Thu Sep 28 15:58:58 2023
****************************************


  Timing Path Group 'MYCLK'
  -----------------------------------
  Levels of Logic:              19.00
  Critical Path Length:          4.32
  Critical Path Slack:          -3.32
  Critical Path Clk Period:      2.00
  Total Negative Slack:      -3460.05
  No. of Violating Paths:     1121.00
  Worst Hold Violation:          0.00
  Total Hold Violation:          0.00
  No. of Hold Violations:        0.00
  -----------------------------------


  Cell Count
  -----------------------------------
  Hierarchical Cell Count:          1
  Hierarchical Port Count:         12
  Leaf Cell Count:               7183
  Buf/Inv Cell Count:            2122
  Buf Cell Count:                  59
  Inv Cell Count:                2063
  CT Buf/Inv Cell Count:            0
  Combinational Cell Count:      5991
  Sequential Cell Count:         1192
  Macro Count:                      0
  -----------------------------------


  Area
  -----------------------------------
  Combinational Area:    30480.482793
  Noncombinational Area: 24913.893919
  Buf/Inv Area:           8396.802960
  Total Buffer Area:           447.93
  Total Inverter Area:        7948.87
  Macro/Black Box Area:      0.000000
  Net Area:                  0.000000
  -----------------------------------
  Cell Area:             55394.376712
  Design Area:           55394.376712


  Design Rules
  -----------------------------------
  Total Number of Nets:          7191
  Nets With Violations:             0
  Max Trans Violations:             0
  Max Cap Violations:               0
  -----------------------------------


  Hostname: ssirlab03

  Compile CPU Statistics
  -----------------------------------------
  Resource Sharing:                    2.17
  Logic Optimization:                 14.56
  Mapping Optimization:               41.02
  -----------------------------------------
  Overall Compile Time:               75.57
  Overall Compile Wall Clock Time:    77.18

  --------------------------------------------------------------------

  Design  WNS: 3.32  TNS: 3460.05  Number of Violating Paths: 1121


  Design (Hold)  WNS: 0.00  TNS: 0.00  Number of Violating Paths: 0
```
**Operating Condition Process- SS Temperature- 100C , Voltage- 1.6**
```
****************************************
Report : qor
Design : vsdbabysoc
Version: T-2022.03-SP5-1
Date   : Thu Sep 28 16:03:12 2023
****************************************


  Timing Path Group 'MYCLK'
  -----------------------------------
  Levels of Logic:              17.00
  Critical Path Length:          3.03
  Critical Path Slack:          -1.83
  Critical Path Clk Period:      2.00
  Total Negative Slack:      -1887.53
  No. of Violating Paths:     1118.00
  Worst Hold Violation:          0.00
  Total Hold Violation:          0.00
  No. of Hold Violations:        0.00
  -----------------------------------


  Cell Count
  -----------------------------------
  Hierarchical Cell Count:          1
  Hierarchical Port Count:         12
  Leaf Cell Count:               6533
  Buf/Inv Cell Count:            1864
  Buf Cell Count:                 119
  Inv Cell Count:                1745
  CT Buf/Inv Cell Count:            0
  Combinational Cell Count:      5341
  Sequential Cell Count:         1192
  Macro Count:                      0
  -----------------------------------


  Area
  -----------------------------------
  Combinational Area:    28939.004327
  Noncombinational Area: 24076.840876
  Buf/Inv Area:           7493.436600
  Total Buffer Area:           793.26
  Total Inverter Area:        6700.18
  Macro/Black Box Area:      0.000000
  Net Area:                  0.000000
  -----------------------------------
  Cell Area:             53015.845203
  Design Area:           53015.845203


  Design Rules
  -----------------------------------
  Total Number of Nets:          6552
  Nets With Violations:             0
  Max Trans Violations:             0
  Max Cap Violations:               0
  -----------------------------------


  Hostname: ssirlab03

  Compile CPU Statistics
  -----------------------------------------
  Resource Sharing:                    2.22
  Logic Optimization:                 14.45
  Mapping Optimization:               45.85
  -----------------------------------------
  Overall Compile Time:               79.81
  Overall Compile Wall Clock Time:    81.29

  --------------------------------------------------------------------

  Design  WNS: 1.83  TNS: 1887.53  Number of Violating Paths: 1118


  Design (Hold)  WNS: 0.00  TNS: 0.00  Number of Violating Paths: 0
```

**Operating Condition Process- FF Temperature- 40C , Voltage- 1.56**
```
****************************************
Report : qor
Design : vsdbabysoc
Version: T-2022.03-SP5-1
Date   : Thu Sep 28 16:09:43 2023
****************************************


  Timing Path Group 'MYCLK'
  -----------------------------------
  Levels of Logic:              15.00
  Critical Path Length:          1.56
  Critical Path Slack:          -0.20
  Critical Path Clk Period:      2.00
  Total Negative Slack:       -161.86
  No. of Violating Paths:      953.00
  Worst Hold Violation:         -0.11
  Total Hold Violation:         -7.30
  No. of Hold Violations:      355.00
  -----------------------------------


  Cell Count
  -----------------------------------
  Hierarchical Cell Count:          1
  Hierarchical Port Count:         12
  Leaf Cell Count:               6551
  Buf/Inv Cell Count:            1850
  Buf Cell Count:                  52
  Inv Cell Count:                1798
  CT Buf/Inv Cell Count:            0
  Combinational Cell Count:      5359
  Sequential Cell Count:         1192
  Macro Count:                      0
  -----------------------------------


  Area
  -----------------------------------
  Combinational Area:    28218.313179
  Noncombinational Area: 24050.565678
  Buf/Inv Area:           7213.167787
  Total Buffer Area:           366.60
  Total Inverter Area:        6846.57
  Macro/Black Box Area:      0.000000
  Net Area:                  0.000000
  -----------------------------------
  Cell Area:             52268.878856
  Design Area:           52268.878856


  Design Rules
  -----------------------------------
  Total Number of Nets:          6561
  Nets With Violations:             0
  Max Trans Violations:             0
  Max Cap Violations:               0
  -----------------------------------


  Hostname: ssirlab03

  Compile CPU Statistics
  -----------------------------------------
  Resource Sharing:                    2.12
  Logic Optimization:                 13.17
  Mapping Optimization:               32.11
  -----------------------------------------
  Overall Compile Time:               67.80
  Overall Compile Wall Clock Time:    69.40

  --------------------------------------------------------------------

  Design  WNS: 0.20  TNS: 161.86  Number of Violating Paths: 953


  Design (Hold)  WNS: 0.11  TNS: 7.30  Number of Violating Paths: 355

```
**Operating Condition Process- FF Temperature- 40C , Voltage- 1.65**
```

****************************************
Report : qor
Design : vsdbabysoc
Version: T-2022.03-SP5-1
Date   : Thu Sep 28 16:14:42 2023
****************************************


  Timing Path Group 'MYCLK'
  -----------------------------------
  Levels of Logic:              13.00
  Critical Path Length:          1.39
  Critical Path Slack:          -0.01
  Critical Path Clk Period:      2.00
  Total Negative Slack:         -0.72
  No. of Violating Paths:      220.00
  Worst Hold Violation:         -0.14
  Total Hold Violation:        -42.10
  No. of Hold Violations:     1059.00
  -----------------------------------


  Cell Count
  -----------------------------------
  Hierarchical Cell Count:          1
  Hierarchical Port Count:         12
  Leaf Cell Count:               6445
  Buf/Inv Cell Count:            1805
  Buf Cell Count:                  80
  Inv Cell Count:                1725
  CT Buf/Inv Cell Count:            0
  Combinational Cell Count:      5253
  Sequential Cell Count:         1192
  Macro Count:                      0
  -----------------------------------


  Area
  -----------------------------------
  Combinational Area:    27865.474865
  Noncombinational Area: 24059.324074
  Buf/Inv Area:           7010.473392
  Total Buffer Area:           452.93
  Total Inverter Area:        6557.54
  Macro/Black Box Area:      0.000000
  Net Area:                  0.000000
  -----------------------------------
  Cell Area:             51924.798939
  Design Area:           51924.798939


  Design Rules
  -----------------------------------
  Total Number of Nets:          6452
  Nets With Violations:             0
  Max Trans Violations:             0
  Max Cap Violations:               0
  -----------------------------------


  Hostname: ssirlab03

  Compile CPU Statistics
  -----------------------------------------
  Resource Sharing:                    2.24
  Logic Optimization:                 15.18
  Mapping Optimization:               43.18
  -----------------------------------------
  Overall Compile Time:               80.01
  Overall Compile Wall Clock Time:    81.53

  --------------------------------------------------------------------

  Design  WNS: 0.01  TNS: 0.72  Number of Violating Paths: 220


  Design (Hold)  WNS: 0.14  TNS: 42.10  Number of Violating Paths: 1059
```
**Operating Condition Process- FF Temperature- 40C , Voltage- 1.76**
```
****************************************
Report : qor
Design : vsdbabysoc
Version: T-2022.03-SP5-1
Date   : Thu Sep 28 16:19:04 2023
****************************************


  Timing Path Group 'MYCLK'
  -----------------------------------
  Levels of Logic:              13.00
  Critical Path Length:          1.45
  Critical Path Slack:           0.00
  Critical Path Clk Period:      2.00
  Total Negative Slack:          0.00
  No. of Violating Paths:        0.00
  Worst Hold Violation:         -0.18
  Total Hold Violation:        -86.34
  No. of Hold Violations:     1082.00
  -----------------------------------


  Cell Count
  -----------------------------------
  Hierarchical Cell Count:          1
  Hierarchical Port Count:         12
  Leaf Cell Count:               6095
  Buf/Inv Cell Count:            1587
  Buf Cell Count:                  21
  Inv Cell Count:                1566
  CT Buf/Inv Cell Count:            0
  Combinational Cell Count:      4903
  Sequential Cell Count:         1192
  Macro Count:                      0
  -----------------------------------


  Area
  -----------------------------------
  Combinational Area:    25525.730903
  Noncombinational Area: 23901.672846
  Buf/Inv Area:           5965.721413
  Total Buffer Area:            87.58
  Total Inverter Area:        5878.14
  Macro/Black Box Area:      0.000000
  Net Area:                  0.000000
  -----------------------------------
  Cell Area:             49427.403749
  Design Area:           49427.403749


  Design Rules
  -----------------------------------
  Total Number of Nets:          6101
  Nets With Violations:             0
  Max Trans Violations:             0
  Max Cap Violations:               0
  -----------------------------------


  Hostname: ssirlab03

  Compile CPU Statistics
  -----------------------------------------
  Resource Sharing:                    2.22
  Logic Optimization:                  8.79
  Mapping Optimization:               11.09
  -----------------------------------------
  Overall Compile Time:               38.44
  Overall Compile Wall Clock Time:    39.62

  --------------------------------------------------------------------

  Design  WNS: 0.00  TNS: 0.00  Number of Violating Paths: 0

  Design (Hold)  WNS: 0.18  TNS: 86.34  Number of Violating Paths: 1082
```
  **Operating Condition  Process- FF Temperature- 100C , Voltage- 1.65**
``` 
****************************************
Report : qor
Design : vsdbabysoc
Version: T-2022.03-SP5-1
Date   : Thu Sep 28 16:28:32 2023
****************************************


  Timing Path Group 'MYCLK'
  -----------------------------------
  Levels of Logic:              13.00
  Critical Path Length:          1.40
  Critical Path Slack:           0.00
  Critical Path Clk Period:      2.00
  Total Negative Slack:          0.00
  No. of Violating Paths:        0.00
  Worst Hold Violation:         -0.15
  Total Hold Violation:        -49.07
  No. of Hold Violations:     1072.00
  -----------------------------------


  Cell Count
  -----------------------------------
  Hierarchical Cell Count:          1
  Hierarchical Port Count:         12
  Leaf Cell Count:               6116
  Buf/Inv Cell Count:            1646
  Buf Cell Count:                  58
  Inv Cell Count:                1588
  CT Buf/Inv Cell Count:            0
  Combinational Cell Count:      4924
  Sequential Cell Count:         1192
  Macro Count:                      0
  -----------------------------------


  Area
  -----------------------------------
  Combinational Area:    25644.594887
  Noncombinational Area: 23896.668047
  Buf/Inv Area:           6347.337409
  Total Buffer Area:           331.57
  Total Inverter Area:        6015.77
  Macro/Black Box Area:      0.000000
  Net Area:                  0.000000
  -----------------------------------
  Cell Area:             49541.262934
  Design Area:           49541.262934


  Design Rules
  -----------------------------------
  Total Number of Nets:          6122
  Nets With Violations:             0
  Max Trans Violations:             0
  Max Cap Violations:               0
  -----------------------------------


  Hostname: ssirlab03

  Compile CPU Statistics
  -----------------------------------------
  Resource Sharing:                    2.18
  Logic Optimization:                 13.75
  Mapping Optimization:                7.31
  -----------------------------------------
  Overall Compile Time:               37.95
  Overall Compile Wall Clock Time:    39.10

  --------------------------------------------------------------------

  Design  WNS: 0.00  TNS: 0.00  Number of Violating Paths: 0


  Design (Hold)  WNS: 0.15  TNS: 49.07  Number of Violating Paths: 1072

```
  **Operating Condition  Process- FF Temperature- 100C , Voltage- 1.95**
  ```
****************************************
Report : qor
Design : vsdbabysoc
Version: T-2022.03-SP5-1
Date   : Thu Sep 28 16:31:28 2023
****************************************


  Timing Path Group 'MYCLK'
  -----------------------------------
  Levels of Logic:              13.00
  Critical Path Length:          1.43
  Critical Path Slack:           0.00
  Critical Path Clk Period:      2.00
  Total Negative Slack:          0.00
  No. of Violating Paths:        0.00
  Worst Hold Violation:         -0.20
  Total Hold Violation:       -125.64
  No. of Hold Violations:     1134.00
  -----------------------------------


  Cell Count
  -----------------------------------
  Hierarchical Cell Count:          1
  Hierarchical Port Count:         12
  Leaf Cell Count:               5589
  Buf/Inv Cell Count:            1319
  Buf Cell Count:                   1
  Inv Cell Count:                1318
  CT Buf/Inv Cell Count:            0
  Combinational Cell Count:      4397
  Sequential Cell Count:         1192
  Macro Count:                      0
  -----------------------------------


  Area
  -----------------------------------
  Combinational Area:    23178.479759
  Noncombinational Area: 23867.890450
  Buf/Inv Area:           4962.259045
  Total Buffer Area:             5.00
  Total Inverter Area:        4957.25
  Macro/Black Box Area:      0.000000
  Net Area:                  0.000000
  -----------------------------------
  Cell Area:             47046.370209
  Design Area:           47046.370209


  Design Rules
  -----------------------------------
  Total Number of Nets:          5595
  Nets With Violations:             0
  Max Trans Violations:             0
  Max Cap Violations:               0
  -----------------------------------


  Hostname: ssirlab03

  Compile CPU Statistics
  -----------------------------------------
  Resource Sharing:                    2.23
  Logic Optimization:                  5.47
  Mapping Optimization:                3.72
  -----------------------------------------
  Overall Compile Time:               25.64
  Overall Compile Wall Clock Time:    26.74

  --------------------------------------------------------------------

  Design  WNS: 0.00  TNS: 0.00  Number of Violating Paths: 0

  Design (Hold)  WNS: 0.20  TNS: 125.64  Number of Violating Paths: 1134
```

 **Operating Condition  Process- tt Temperature- 25C , Voltage- 1.80**
 ```
****************************************
Report : qor
Design : vsdbabysoc
Version: T-2022.03-SP5-1
Date   : Thu Sep 28 16:34:47 2023
****************************************


  Timing Path Group 'MYCLK'
  -----------------------------------
  Levels of Logic:              16.00
  Critical Path Length:          1.60
  Critical Path Slack:          -0.21
  Critical Path Clk Period:      2.00
  Total Negative Slack:       -171.00
  No. of Violating Paths:      998.00
  Worst Hold Violation:         -0.09
  Total Hold Violation:         -5.15
  No. of Hold Violations:       69.00
  -----------------------------------


  Cell Count
  -----------------------------------
  Hierarchical Cell Count:          1
  Hierarchical Port Count:         12
  Leaf Cell Count:               6936
  Buf/Inv Cell Count:            1312
  Buf Cell Count:                 159
  Inv Cell Count:                1153
  CT Buf/Inv Cell Count:            0
  Combinational Cell Count:      5744
  Sequential Cell Count:         1192
  Macro Count:                      0
  -----------------------------------


  Area
  -----------------------------------
  Combinational Area:    29019.081009
  Noncombinational Area: 23971.740049
  Buf/Inv Area:           5544.067058
  Total Buffer Area:          1020.98
  Total Inverter Area:        4523.09
  Macro/Black Box Area:      0.000000
  Net Area:                  0.000000
  -----------------------------------
  Cell Area:             52990.821059
  Design Area:           52990.821059


  Design Rules
  -----------------------------------
  Total Number of Nets:          6943
  Nets With Violations:             0
  Max Trans Violations:             0
  Max Cap Violations:               0
  -----------------------------------


  Hostname: ssirlab03

  Compile CPU Statistics
  -----------------------------------------
  Resource Sharing:                    2.23
  Logic Optimization:                 12.59
  Mapping Optimization:               35.78
  -----------------------------------------
  Overall Compile Time:               67.27
  Overall Compile Wall Clock Time:    68.71

  --------------------------------------------------------------------

  Design  WNS: 0.21  TNS: 171.00  Number of Violating Paths: 998


  Design (Hold)  WNS: 0.09  TNS: 5.15  Number of Violating Paths: 69
```

The graph presented below tells the Worst Negative Slack (WNS) and Total Negative Slack (TNS) values in the context of Setup timing violations. The left-hand side (LHS) axis represents WNS, while the right-hand side (RHS) axis represents TNS:

**SETUP CHECK DATAPOINTS**
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/a6cdaee4-ec4f-4d68-b938-5849f234f934)


**HOLD CHECK DATAPOINTS**

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/5c4f7ecd-419d-4a7e-b615-5ba2968e1d5f)

**Findings**
```
From Plots we can observe for slow libraries setup is getting violated as data path is getting slow slack is coming out to be negative. If we can meet the timing with respect to sky130_ss_n40C_1v28 we can take care of timing for remaining corners

From Plots we can observe for fast libraries hold is getting violated as data path is getting fast slack is coming out to be negative. If we can meet the timing with respect to sky130_ff_n40C_1v65 we can take care of timing for remaining corners
```

</details>

  # Day 15 - Inception of EDA and PDK

  <details>

  <Summary>Introduction</Summary>
  An integrated circuit (also known as an IC) is a set of electronic circuits on one small flat piece (or "chip") of semiconductor material, usually silicon. An integrated circuit is typically mounted on a printed circuit board 
  (PCB) to create a functional electronic system.

  The main components of a chip are as shown below
   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/bef19c2f-f46b-4c48-952a-502279e039ca)


  **DIE**  refers to a specific part of a silicon wafer that contains an individual integrated circuit (IC) or chip.Each silicon wafer is divided into multiple smaller sections, each of which contains a copy of the same integrated 
  circuit design. These smaller sections are called "dies." Each die is essentially an individual chip that can function on its own once it's separated from the wafer.

  **Pads** refer to the external connections or pins on an integrated circuit (IC) that allow it to interface with the outside world. Pads serve as the physical connection points through which electrical signals are input to or output 
   from the IC.Pads play a crucial role in the functionality of an IC. They are the points at which signals, such as data, power, clock, and control signals, are brought into or sent out of the chip.

   Types of pads

   - Input Pads: These are used to receive external signals into the IC. For example, input pads might be used for data inputs from other interfaces.
   - Output Pads: These are used to send signals generated within the IC to external devices or other parts of a circuit. For instance, output pads might be used to transmit data 
   - Power Pads: These pads are used to provide power to the IC. They are typically connected to the power supply voltage (VDD) and ground (VSS).
   - Ground Pads: Ground pads are connected to the ground reference voltage (VSS) and are essential for proper functioning and noise reduction in the circuit.
  
  **Core** refers to a fundamental functional block or module within an integrated circuit (IC) design. Cores are designed to perform specific tasks or functions, and they can be combined with other cores and components to create complex ICs that serve various purposes.

  This particular component is housed in a QFN-48 package, which stands for Quad Flat No Leads and has 48 pins. Each of these pins serves as a connection point that interfaces with other components or packages on the design board. The 
  package itself measures 7mm by 7mm in size. At the heart of this package, there is typically a microchip positioned in the center. The pins on the periphery of the package, often referred to as "outbounds," play a crucial role in facilitating the exchange of data between the external world and the chip contained within the package.

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/9b78a1fd-2dd5-4d59-9347-fda531366776)

  </details>

  <details>

  <Summary>RTL to GDSII </Summary>

  ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/98a95714-09fa-4aff-8e34-1474a34b92c8)


- **Synthesis**  refers to the process of transforming a high-level hardware description of a digital circuit, often written in a hardware description language (HDL) using Verilog, into a netlist 
  representing the logical and physical components that will make up the actual integrated circuit.Standard cells are fundamental building blocks used in this process. They have a regular layout, and each 
  cell is represented in various views or models, including electrical, HDL, and SPICE. Additionally, there are abstract and detailed layout views available for standard cells. These standard cells play a 
  pivotal role in constructing the final layout of the integrated circuit.

- **Floor Planning** is a crucial early-stage process that involves defining the physical layout and placement of various functional blocks, modules, and components within an integrated circuit (IC). Floor 
 planning is essential for optimizing factors such as chip area, signal routing, power distribution, and thermal management.

- *Chip Floorplan* : It refers to the specific floorplan designed for an integrated circuit (IC) or semiconductor chip. It is a layout or diagram that details the physical arrangement and placement of 
  various components,functional blocks, and critical elements within the chip's silicon area.

- *Macro Floorplan* : A "macro floorplan" is a specific type of floorplan used in semiconductor and integrated circuit (IC) design. In IC design, a macro typically refers to a predefined and pre- 
  characterized functional block or module that performs a specific function. A macro can be anything from a processor core to a memory block or any other complex building block within an IC.
  
- *Power Planning* : Power planning in VLSI (Very Large Scale Integration) design is a critical aspect of semiconductor chip design that involves managing and distributing electrical power Effective power 
   planning is essential for achieving reliable and efficient operation while minimizing power consumption.


  - **Placement**  is a crucial step in the physical design process of creating integrated circuits (ICs). It involves determining the optimal location for each logical cell, or standard cell, within the chip's silicon area. Effective 
    placement has a significant impact on factors like performance, power consumption, and chip area utilization. The primary objective of placement is to arrange standard cells in a way that minimizes the total wirelength (the total 
    length of wires connecting the cells), optimizes chip area utilization, and meets various design constraints such as timing, power, and manufacturability.

  - **CTS** stands for "Clock Tree Synthesis." CTS is a crucial step in the physical design process of creating integrated circuits (ICs), and it specifically deals with the generation and optimization of the clock distribution 
    network within the chip. The primary goal of CTS is to ensure that clock signals are distributed efficiently and reliably to all flip-flops and sequential elements, minimizing clock skew and meeting the required timing 
    constraints.Clock Tree Synthesis is a critical step in VLSI design, as clock distribution plays a significant role in the overall performance, power consumption, and reliability of integrated circuits. Advanced algorithms and 
    tools are used to automate and optimize the CTS process for complex and high-performance ICs.

  - **Routing** in VLSI (Very Large Scale Integration) design is a fundamental step in the physical design process of creating integrated circuits (ICs). It involves the generation of physical connections (metal traces or wires) 
    between the various components and logic elements on the chip, ensuring that data signals, control signals, and power are routed efficiently and meet design constraints. Routing plays a critical role in determining the 
    performance, power consumption, and overall functionality of the IC.

  - **Sign Off** refers to the final stage of the design process before the design is sent for fabrication (manufacturing). Sign-off involves a comprehensive set of checks, analyses, and validations to ensure that the integrated 
    circuit (IC) design meets all of the necessary criteria, constraints, and specifications before it is sent to the foundry for manufacturing. This stage is critical because any design errors or issues not caught at this point can       in costly and time-consuming problems later in the manufacturing process or after the ICs are in operation.

  - **Physical Verification** It involves a series of checks and analyses to verify that the physical layout of the integrated circuit (IC) adheres to various design rules, constraints, and manufacturing requirements. The goal of 
     physical verification is to ensure the manufacturability, functionality, and reliability of the IC design before it is sent for fabrication. It involves
          -
 1. *Design Rule Checking (DRC)*:
    - Geometry Checks: DRC verifies that the layout adheres to the design rules specified by the foundry. These rules include minimum feature sizes, spacing requirements, width and spacing of metal layers, 
        
 2. *Electrical Rule Checking (ERC)*:
    - Electrical Connectivity: ERC ensures that there are no electrical shorts or opens in the layout. It verifies that the actual connections in the layout match the intended connectivity in the schematic.

    - Antenna Checking: ERC also checks for charge buildup issues, known as antenna effects, that can result from the deposition and etching processes during manufacturing.		

  3. *Layout Versus Schematic (LVS) Verification*:

	   - Netlist Consistency: LVS compares the layout netlist with the schematic netlist to ensure that they are equivalent. Any mismatches or discrepancies are flagged for resolution.

	   - Parasitic Extraction: Parasitic elements, such as capacitance and resistance, are extracted from the layout and compared with the schematic to verify electrical equivalence.



  </details>

  <details>

  <summary>OpenLane Flow</summary>

  OpenLane is an open-source digital ASIC (Application-Specific Integrated Circuit) design flow and toolchain developed by Google and the Skywater Technology Foundry. It provides a 
  complete, automated environment for designing and manufacturing digital chips, from RTL (Register-Transfer Level) design to GDSII (Graphic Data System II) tape-out. OpenLane is built 
  upon various open-source tools and methodologies and is intended to simplify and democratize the ASIC design process.

  1. Synthesis Exploration:

	- Synthesis exploration is a utility used to generate reports that display the design's delay and area characteristics.
 
 	- It helps identify the most suitable design strategy to proceed with by analyzing these reports.
		
		
  2. Design for Testability (DFT):

	- After synthesis, DFT steps prepare the design for testing before fabrication (optional).These steps include:

		- Scan Insertion

   		- Automatic Test Pattern Generation (ATPG)

		- Test Patterns Compaction
  
  		- Fault Coverage Analysis

  3. Physical Implementation (Automated PnR):

	- Physical implementation, often referred to as Automated Place and Route (PnR), is conducted using open-source tools like OpenRoad.It encompasses various steps:

		- Floor and Power Planning

		- End Decoupling Capacitors and Tap Cells Insertion

		- Placement (Global and Detailed)

		- Post Placement Optimization

		- Clock Tree Synthesis (CTS)

		- Routing (Global and Detailed)

		- Logic Equivalent Check (LEC) to ensure functionality consistency after netlist modifications.


  4. Dealing with Antenna Rules Violations: A specific phase during physical implementation addresses Antenna Rules Violations.
     It involves inserting Antenna Diodes to mitigate issues caused by long metal wire segments acting as antennas, which can accumulate charge and potentially damage transistor gates 
     during fabrication.
     Solutions include bridging and adding antenna diode cells.

	- Static Timing Analysis (STA):STA involves several steps, including RC extraction (from .def to .spef format) and the use of tools like OpenSTA (within OpenROAD).
	  It generates timing reports to check for violations in timing paths and ensure that the design meets its timing constraints.
          Physical Verification (DRC & LVS):

	- Magic is utilized for Design Rule Checking (DRC) and SPICE Extraction from Layout.Netgen, along with Magic, is employed for Layout vs. Schematic (LVS) checks, comparing the 
          extracted SPICE data from Magic with the Verilog netlist.
  
  </details>

  <details>

  <summary>Labs</summary>

  **Skywater130 PDK Files**

  The skywater130 PDK contains 3 directories:

  1. skywater-pdk : It contains all pdk related files (.lib,.lef)
  2. open-pdks : It contains scripts that bridge the compatibility gap between closed-source and open-source PDKs for Electronic Design Automation (EDA) tools.
  3. sky130A : It contains open source compatible EDA files.
 
  The commands for invoking Openlane
  ```ruby
  docker
  flow.tcl -interactive
  ```
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/6abed818-37c8-4a8a-b95e-ef6debd91dd3)


  Preparing Design:


![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/3db3f03e-befb-4dba-be9f-2d70c2b4b4e4)

 **Config file in the new directory shows the default parameters taken by the run**.

 ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/e343c37a-c008-46cd-9880-95654a71d4ec)


  After running the command *run_synthesis*
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/c2436373-e812-47f5-b88f-eca1e8e71125)

Timing Report After Synthesis

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/fa4dbf6f-de2a-49d9-80aa-d33a72908591)


  The number of d flip flops = 1613

  Total Number of cells = 14876

  D flip flop ratio = 1613/14876 = 0.108429

  In percentage => 10.8429%

  ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/8532254b-0568-4658-b8ee-70c5e860f608)


  </details>



# Day 16 Good Floorplan and Bad Floorplan

<details>

 <summary>Utillization Factor and aspect ratio</summary>

This circuit consits of 2 Flipflops , 1 And gate and 1 OR gate

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/5e4c8b1a-a513-49d0-ad1c-78c78fb83e47)

 converting this design into physical implementation 

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/f3630554-303d-4296-be0d-38bd236a3847)

 To define the height and width of the core and die we need to know the dimensions of standard cells

 Lets consider the area of standard cell as 1 sq unit and area of the flip flop cell also as 1 sq unit.

 Now we remove the wires and do a rough calculation of min area occupied by netlist.
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/6c5217a5-ddf3-4632-b1b2-084a5f155028)


 The area is **4 sq unit**

 **Utilization Factor** : It is defined as the ratio of area occupied by netlist to the total area of core 

 Utilization Factor = area occupied by netlist / total area of core

 Consider the above circuit  the utilization factor is 1 (4/4)

 **Aspect Ratio** : It is defined by the ratio of height and width of the core.

 Aspect Ratio = Height/Width

 In this the aspect ratio is 1 (2/2)

</details>

<details>

<summary>Concept of preplaced cells</summary>

Consider the below circuit 



These circuits can be split into blocks as shown in the figure and further these blocks can be considered as blackboxes with extended pins , They are known as Ip's and they can be used multiple times in the design




These are example of IP's 

![image](https://github.com/AbhishekChinchani/Samsung_pd/assets/142480501/db44fc1d-a376-4fb3-b1e4-391138b1cd2f)

</details>

<details>

 <summary> Decoupling Capacitors</summary>

 Consider a complex circuit as shown in the figure

 ![image](https://github.com/AbhishekChinchani/Samsung_pd/assets/142480501/84f3cbdf-2190-43f0-813a-a7e7b39404e2)

 - During the switching case the circuit requires high peak current.
 - But there will be some voltage drop beacuse of R and L , as a reult the voltage at node A will be Vdd'.
 - Now if this drop is higher then the noise margin then the Voltage goes to undefined state i.e it can act as 1 or 0.
 - Referring to the noise margin graph, there are three regions: logic 0, undefined, and logic 1. If Vdd falls between Vil and Vih, it is considered undefined, posing a risk.
 - So to overcome this problem we use decoupling capacitor
 - Decoupling Capacitor provide the require amount of the current to the nodes so that they dont do into undefined state
 - They are placed parallel to circuit
 - These capacitors are strategically placed between blocks to ensure that all blocks receive the necessary power supply when switching occurs.

   After placing the decoupling capacitances

   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/b6e74213-d1f0-4633-9d7a-c647169b24a8)

   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/d3636185-189d-420a-85a5-8790c0b8c735)



</details>

<details>

 <summary> Power planning </summary>

 Consider the below case

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/080b0eed-69a0-4029-9c10-73d41be839ac)

 - Now the output at the driver is high , this signal should be sent to another driver.
 - This is a 16 bit bus which is again connected to an inverter
 - So all the logic 1 bits should eventually discharge and all logic 0 should charge .
   **Problem Of Voltage Droop And Ground Bounce**
 - During Discharging all the logic 1 discharge at the same time reulting in bounce , if this bounce exceeds the noise margin then that bit enters the undefined state
 - During charging phase all the logic 0 should be charged at same causing Voltage Droop
 - So to overcome this we use multiple power supplies
 - These multiple power supplies will be directed to the nearest blocks, ensuring that each block receives a reliable power supply without any possibility of missing out.

 ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/6c0eed3d-5282-4acf-8e9e-e7ea7c8b5862)

</details>

<details>

 <summary>Pin placement and logical cell placement blockage </summary>

 This has 4 input and 4 output pins, 2 input clock pins and 1 output clock pins

 pin placement 

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/2eaeb2f2-664a-43e4-a97b-ec54f48ba580)

 - These pins are placed in random order
 - Clock pins are larger because they need to send the signals to all flip flops
 - 
</details>

<details>

 <summary> Floorplan using Openlane</summary>

 Running the floorplan using the command *run_floorplan*
 
 ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/23b91369-acd6-4156-8092-d13fcbcf6074)


 The values chosen are chosen based on set of priorities, the least priority is for floorplan.tcl then config.tcl in designs and the **highest priority is for sky130A_sky130_fd_sc_hd.tcl**

 1. floorplan.tcl
  
 ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/30e49178-36fe-4397-9802-00c46389970a)

 ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/beba2f86-64b1-4f04-a336-c0f641ae57b4)
 
 The values chosen in our case are *utilization ratio 35* , *vertical metal layer as 2* , *horizonatal metal layer as 3*

  ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/919e16c4-7df4-48b3-91c9-8a5d54a99e87)

  ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/148ac070-c64d-4639-85c0-02fa61af4b8a)


 The reult is stored as .def file

 ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/fa7369a3-0f50-47df-8406-99767866e5ef)


 command to invoke magic is
 ```ruby
 magic -T <path_of_tech_file> lef read <path_of_lef_file> def read <path_of_def_file>
 ```

 The floorplan in magic is as follows
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/974233ec-d66f-4e71-bbdd-5ed38e3b962a)


 We can select and check its metal layer by just selecting it in magic and giving what command in tkkon2.3

 ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/75c65e5e-6a3a-43ba-bfa7-035a8fdef259)

 ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/6698dcf1-1f94-49b4-af0e-bd3dc31f8771)


</details>

<details>

 <summary>Netlist Binding and intial place design</summary>

 - First the circuit is converted into the netlist as shown in the figure

  ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/13d4f79c-a0ac-4808-acf4-6a5b9c2f4643)

- A Library consist of different flavours of the gates as shown in the figure

  ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/4729ead5-8e0b-457a-a63a-fd206732496c)

  ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/0d27b79c-3a52-4c0b-a257-a174f73a48df)

</details>

<details>

 <summary>Final placement optimization </summary>

 Consider the initial placement as shown in the figure

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/9e1c3807-70fb-4035-b6a5-c6a0969a5357)


 - At this stage we estimate wire length and capacitance and based on that we insert repetators
 - Repeater insertion involves placing buffers along the signal path to reinforce the signal and duplicate it. It's worth noting that adding more repeaters consumes additional chip area.
 - Consider the above circuit , Lets estimate the wire length between Din1 and Dout1, we see that there are not that far enough so they can be directly connected without any repeater 
   buffers
 - Consider the case between Din2 and Dout2 , Din2 is placed far enought from FF1 so we nees to insert a repeater buffer.
 - While the connection between FF1 (yellow) and Din 1 is acceptable, there's a challenge when crossing other flip-flops due to excessive distance. To address this, buffers are 
   introduced, and to avoid congestion, they are placed on a separate layer.

</details>

<details>

<summary>Placement Labs</summary>

To run tbe placement we use the command *run_placement*

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/bebe4e5d-fb91-4d83-8d90-de28fe02d26f)

The placement in the magic is as follows

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/be9ff1e6-8141-4474-a447-d21f77f790f7)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/2d9e21c4-c786-4d13-bafd-3d61ef9610e8)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/d8ab7c5c-c8ca-42bf-808e-550c00f4d471)


</details>

<details>

 <summary>Standard Cell Design Flow</summary>

 The standard cell design flow and characterization process are essential aspects of designing integrated circuits (ICs) using CMOS technology.

 **Inputs**

 - *Process Design Kits* : Process Design Kits (PDKs) are essential tools used in semiconductor manufacturing and integrated circuit (IC) design. They provide a comprehensive set of information, data, and files necessary for designing and simulating semiconductor devices and ICs using a specific semiconductor manufacturing process technology.
 - *DRC and LVS* : *DRC* stands for "Design Rule Checking," and it is a critical step in the semiconductor and integrated circuit (IC) design and manufacturing process. DRC is a set of automated checks that ensure that the layout of an IC adheres to the design rules specified by the semiconductor foundry or manufacturing facility. These design rules are essential to ensure that the resulting IC can be manufactured reliably and accurately. **LVS** is a process that verifies the accuracy and consistency between the physical layout of an IC (the layout design) and its logical schematic or netlist.
 - *SPICE* : *SPICE* models, often simply referred to as "SPICE," are essential tools used in electronic circuit design and simulation. SPICE stands for "Simulation Program with Integrated Circuit Emphasis." It is a computer program used to model and simulate the behavior of electronic circuits. SPICE models provide a way to mathematically describe and analyze the performance of electronic components and circuits.

**Design Steps**
- *Circuit Design* :n this phase, engineers create the logical schematic representation of the digital circuit. They specify the functionality, connectivity, and desired performance parameters.It refers to the process of creating and optimizing electronic circuits on a microchip or integrated circuit (IC) at a very high level of complexity. VLSI design is a critical aspect of semiconductor engineering and involves the creation of complex digital and analog circuits that can include millions or even billions of transistors on a single chip.
  
- *Layout Design* : After the logical design, engineers create a physical layout of the circuit, adhering to DRC and LVS rules. This involves placing transistors and interconnecting them while considering factors like area, power, and signal integrity.It refers to the process of creating the physical representation of an IC on a semiconductor wafer. This physical representation includes the placement and interconnection of various components, transistors, wires, and other elements that make up the IC.
  
- Characterization*: Characterization is the process of quantifying how the standard cells behave under various conditions. This step ensures that the cells meet timing, power, and noise requirements. GUNA is a software tool used for this purpose.


**Outputs**
- CDL **(Circuit Description Language)**: CDL files describe the logical behavior of standard cells, including their connectivity, functionality, and timing information.
- GDSII **(Graphic Database System II)**: GDSII is a file format used to represent the final layout of the IC in a binary form. It is used for chip fabrication.
- LEF (Library Exchange Format): LEF files provide information about the physical properties of the standard cells, which is necessary for placement and routing in the IC design process.
- Timing, Noise, Power Libraries: These libraries store information on the timing characteristics, noise behavior, and power consumption of standard cells. They are essential for synthesis and optimization tools.
- Extracted Spice Netlist (.cir): This is a SPICE-compatible netlist that includes parasitic elements extracted from the layout. It is used for accurate simulation of the designed circuit.


</details>

<details>

 <summary>Standard Cell Characterization</summary>

 - **Link Model File of CMOS** : This step involves linking the Liberty file, which defines the properties, timing, and other characteristics of the CMOS process technology.

 - **Specify Process Corner(s)**: Process corners represent different manufacturing variations and operating conditions (e.g., fast, slow, typical). The characterization process evaluates 
   the standard cell's behavior across these corners.

 - **Specify Cell Delay and Slew Thresholds**: These thresholds determine how the cell's timing characteristics are characterized, helping capture both the rising and falling edges of 
   signals.
   
 - **Read Parasitic Extracted Netlist** : The parasitic elements extracted from the layout of the standard cell are incorporated into the characterization process to account for their 
    impact on signal delays and power consumption.

 - **Apply Input or Stimulus**: Simulated inputs or stimuli are applied to the standard cell to evaluate its response under various conditions.

 - **Provide Necessary Simulation Commands**: Simulation commands are used to run simulations on the standard cell to gather data on its performance.
</details>

</details>

## Day-17 Standard Cell Characterizations ##

<details>
 <summary>Spice Simulation lab for CMOS Inverter</summary>
	
 1. The initial step involves generating a SPICE Deck file that encompasses essential details, such as the netlist's connectivity information, specified input sources, and designated points for observing outputs. In the creation of this SPICE Deck, the process entails defining the interconnections among components, specifying component values, as well as recognizing and labeling nodes accordingly.
	
 2. A CMOS inverter is a digital logic gate that takes an input signal and produces an output signal that is the logical complement (opposite) of the input. In other words, when the input is high (1), the output is low (0), and when the input is low (0), the output is high (1).
  
 3. A CMOS inverter is constructed using complementary pairs of both NMOS (n-channel metal-oxide-semiconductor) and PMOS (p-channel metal-oxide-semiconductor) transistors. When one transistor is on (conducting), the other is off (non-conducting), allowing for low-power consumption and high noise immunity.
 
 4. A node is identified when a component is positioned between two nodes.

- The SPICE deck for CMOS inverter is as follows.

```ruby
M1 out in vdd vdd pmos W=0.375u L=0.25u
M2 out in 0 0 nmos W=0.375u W=0.25u
cload out 0 10f
Vdd vdd 0 2.5
Vin in 0 2.5
** Simulation Commands**
.op
.dc Vin 0 2.5 0.05
** .include tsmc_025um_model.mod **
.LIB "tsmc_025um_model.mod" CMOS_MODELS
.end
```
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/3df0b64a-4ac0-4d30-bf6d-792018755e50)

1. Component M1 represents a PMOS transistor with its drain connected to the OUT node, its gate linked to the IN node, and its substrate and source connected to VDD. M1 also features a specified width-to-length (W/L) ratio.
2. Component M2 represents an NMOS transistor with its drain linked to the OUT node, its gate connected to the IN node, and its substrate and source tied to the ground (0V). M2 also includes a defined W/L ratio.
3. The load capacitance, with a value of 10fF, is connected between the OUT node and ground. Likewise, the supply voltages, set at 2.5V, are connected between the ground and their respective nodes.
4. The Simulation command signifies the incremental variation of the gate voltage, ranging from 0V to 2.5V, in steps of 0.05V. This procedure is executed to observe and record the output characteristics concerning changes in the input voltage. The model file should be structured as follows, providing a comprehensive description of both NMOS and PMOS transistors, including their respective dimensions (length and width).

The layout of the CMOS inverter is as follows:<br>
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/0607a1d2-a778-409d-9f36-b77bff25c88b)

Following commands are runned in tckon Main window.
```ruby
extract all
ext2spice cthresh 0 rthresh 0
ext2spice
```
The spice netlist generated as shown below
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/2f2b607b-4ff4-4aed-bdb5-d5e3145e4d20)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/b7253f40-3721-4cb4-b7ac-584b31dd4a7f)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/f7b021e9-b47d-4e40-9878-df5ea55c8333)

</details>

<details>
 <summary>16 Mask CMOS Fabricaion</summary>

The manufacturing process involves several key steps:

1.Substrate Preparation: Commences with a silicon wafer as the initial material, which undergoes rigorous cleaning and pre-processing to prepare it for further stages.

2.Gate Oxide Formation (Mask 1): A thin layer of silicon dioxide (SiO2) is either grown or deposited onto the silicon wafer. This layer functions as the gate dielectric.

3.Polysilicon Gate Formation (Mask 2): Polysilicon is deposited and precisely patterned to create gate electrodes for both NMOS and PMOS transistors.

4.N-Well and P-Well Formation (Mask 3): The creation of regions for NMOS and PMOS transistors involves the use of n-type and p-type ion implantation processes.

5.Source and Drain Formation (Masks 4 and 5): Ion implantation, followed by annealing processes, is employed to define the source and drain regions of the transistors.

6.Gate Spacer and Silicidation (Masks 6 and 7): Insulating spacers are introduced around the gate structures, and metal silicide is formed on the source and drain regions to reduce contact resistance.

7.Interlayer Dielectric (ILD) Deposition (Mask 8): A layer of insulating material, typically silicon dioxide, is deposited and planarized to create a level surface for metal interconnections.

8.Contact and Via Formation (Masks 9 and 10): Etching processes create contact holes through the ILD, facilitating connections between metal interconnects and the underlying transistor nodes.

9.Metal Layer 1 (Mask 11): The formation of metal lines and interconnects allows for connections between different parts of the circuit.

10.Intermetal Dielectric (IMD) Deposition (Mask 12): Another insulating layer is deposited to provide separation between metal layers and isolation.

11.Metal Layer 2 (Mask 13): Additional layers of metal interconnects may be added as required.

13.Passivation Layer (Mask 14): A protective layer is deposited to shield the underlying layers and offer electrical insulation.

14.Pad Opening (Mask 15): Openings are created in the passivation layer to enable wire bonding or solder bump connections.

15.Testing and Packaging (Mask 16): Chips undergo rigorous testing for functionality and performance, followed by packaging to prepare them for their final use.

This comprehensive process forms the foundation of semiconductor device manufacturing, allowing for the creation of integrated circuits with intricate electronic functionalities.

***CMOS Inverter layout in Magic***

- When we select nmos and pmos box in Magic and run *what* command in tckon window we obtain below image.
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/05a82229-6977-4af0-a1de-7110109ee429)

- The connection of Y to both the drain terminals of the PMOS and NMOS transistors
  ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/83b856b8-5250-448a-b574-b900065f59ee)

- The connections of the PMOS source and NMOS source are established as follows
 ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/abd8a996-9762-4643-8620-497765ad3ece)

- After removing some layers we get drc errors

  ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/8804a933-8ed8-49db-9d9a-fbbbe6fa9220)

- Below image is obtained after removing Drc Errors
  ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/3d11a2c3-c90f-48ae-886b-3c3c42637e83)

</details>

<details>
 <summary>Labs on DRC</summary>
	
- Initially,git clone the 'open_pdks.git' repository from RTimothyEdwards. Now all the magic files is with us. We will look for mtal3.mag. So metal3.mag file now with us.

- *cif see VIA2* command is runned in tckon window to obtain metal 3 contacts.
- When we see the layout of metal3.mag in Magic 
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/893425ac-0962-4db5-9201-e7f350904f2b)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/0c92baba-9c71-4227-9bf9-4998303b6264)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/f27609ce-f0b8-49ae-bebf-11f1e7c5cff0)


- Now width and height of the box is shown in below image which determine distance between the metal contact and metal layer boundary
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/9522c9ab-611f-4481-b85b-ce5d532f10a0)


- Below image of tckon window shows the box width in poly
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/8f38d20a-cd2b-4759-a69b-292225b3a472)

- Now sky130A.tech file is edited by adding ***allpolynonres*** in poly.9. After editting we load the tech file and check drc using *drc check* in tckon window. 

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/d3a8b82b-2f54-4d92-a47d-42c265d8ca3c)

- Here we can obsevre that no drc error is occuring. Hence we succesfully fixed poly.9 error. 
</details>

## DAY-18 Pre-layout timing analysis and importance of good clock tree
<details>
<summary> Timing model using delay tables</summary>

<details>
 <summary>Lab 1: Lab steps to convert grid info to track info </summary>
Library Exchange Format (LEF)

A specification in which representing the physical layout of an integrated circuit in an ASCII format

It includes design rules and abstract information about the standard cells

LEF only has abstract view of cell required at that level to serve the purpose of the concerned CAD tool

Containing information on input, output, power and group port, does not consists logic path information

Objective: extract LEF file from .mag file and then plug the file into the picorv32a flow (previous is standard cell library)

Main guidelines:

The input and output ports must lie on the intersection of the vertical and horizontal tracks
The width of standard cell should be on the track pitch, and the height should be on the track vertical pitch.
```
~/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/openlane/sky130_fd_sc_hd

vim tracks.info

cd ~/Desktop/work/tools/openlane_working_dir/openlane/vsdstdcelldesign

magic -T sky130A.tech sky130_inv.mag
```
- Track information (using during routing stage) routes can go over the track/layer (metal traces)

- Set the grid based on the tracks.info (grid) converted the track into grid
- Ports are on the intersection of the horizontal and vertical tracks. It ensures that the routes can reach the ports from x and y direction.
- Verified that both input and output ports have fulfilled the guideline where input and output ports lies at the intersection of horizontal and vertical tracks
Note: press "g" to enable grid (zoom in to see the grid)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/f4663d44-a672-4156-98de-7facd15d1b14)

</details>

<details>
 <summary>Lab 2: Lab steps to convert magic layout to std cell LEF </summary>

 We need to only define layers, not ports in layout
- Ports definitions are required when we want to extract LEF file
- Ports will be defined as pins of a macro
How to define ports?

Select port --> edit --> Text --> fill those required information
Note: For A; and Y in locali while for VPWR and VGND in metal1

*Extract the LEF file*
```
In tkcon

save sky130A_prakhar_inv.mag
```
Checking saved file:
```
cd ~/Desktop/work/tools/openlane_working_dir/openlane/vsdstdcelldesign
ls
magic -T sky130A.tech sky130_prakhar_inv.mag
lef write
vim sky130_prakhar_inv.lef
```
aviral_inv:
![inverter in design](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/5a261130-b410-438f-868d-42e747cf7d1a)

</details>

<details>
 <summary>Lab 3: Introduction to timing libs and steps to include new cell in synthesis</summary>

```
cd ~/Desktop/work/tools/openlane_working_dir/openlane/vsdstdcelldesign
cp sky130A_vsdinv.lef ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/src
cd ~/Desktop/work/tools/openlane_working_dir/openlane/vsdstdcelldesign/libs
cp sky130_fd_sc_hd__* ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/src
cd ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/
vim config.tcl
```

Modifying config.tcl file
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/abad90aa-289a-4e1a-adb9-9f2060365b11)


```
cd ~/Desktop/work/tools/openlane_working_dir/openlane
make mount
./flow.tcl -interactive
package require openlane 0.9
prep -design picorv32a -tag <run_name> -overwrite      (Check run date at ls ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs)
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
run_synthesis
```

</details>

 <details>
 <summary>Theory : Introduction to delay tables and its usage </summary>

**Introduction to delay tables**

- We need to look into the timing characteristics of the buffer, in the case where we want to swap out the buffer for a gate.
- For each level of buffering, we should have an identical buffer being used, and each node should be driving the same node.
- Keep in mind that the load at the output will be varying, and since the load of one buffer is varying, the input transition of the following buffer will also vary.
- This means that we will have a variety of delays.
- The delay table is characterized based on varying the input transition and output load of a cell, against the delay of that cell.
- Each cell will have its own delay table for different sizes and threshold tables.


*Delay table usage*

- Each type of cell will be having its own individual delay table, as the internal pmos and nmos width/length ratio gets varied, the resistance changes, then RC constant gets varied 
  as well, meaning the delay of each cell gets varied.
- The values of delay which are not available in the table are extrapolated based on the given data.
- Similarly, the ways on how we have a delay table, we will also have a characterization table for input transition.
- The latency at the endpoints will be the sum of the delays of each individual cell in that path.
- The total skew value between two endpoints will be non-zero if the output load driven for a cell is varied, meaning different delay numbers are seen between endpoints, this is why 
  it is preferred to have the nodes at each level driving the same load.
- Another case in which we can retain the skew to be zero in the presence of varied load, is by using a different buffer size at the same level that can achieve the same level of 
  delay as the other buffer in same level based on its delay table.
- These are factors which should be looked into in the early stages of the clock tree design stage.
- Now we must look into power aware CTS, where we have to consider endpoints which are only active under certain conditions.
- In this case, we do not need to propagate the clock into those cells during the period of inactivity.

</details>

<details>
<summary>Lab 4: Lab steps to configure synthesis settings to fix slack and include aviral_inv</summary>
	 
```
cd ~/Desktop/work/tools/openlane_working_dir/openlane/configuration
vim README.md
```
- SYNTH_STRATEGY: control the area and timing
- SYNTH_BUFFERING: control if we want to buffer high fanout net
- SYNTH_SIZING: control in cell sizing instead of buffering
- SYNTH_DRIVING_CELL: ensure more drive strength cell to drive input

In openlane terminal:
```
echo $::env(SYNTH_STRATEGY)
set ::env(SYNTH_STRATEGY) "DELAY 0"
echo $::env(SYNTH_STRATEGY)
echo $::env(SYNTH_BUFFERING)
echo $::env(SYNTH_SIZING)
set ::env(SYNTH_SIZING) 1
echo $::env(SYNTH_SIZING)
echo $::env(SYNTH_DRIVING_CELL)
```


With SYNTH_STRATEGY of Delay 0, the tool will focus more on optimizing/minimizing the delay, index can be 0 to 3 where 3 is the most optimized for timing (sacrificing more area).
SYNTH_BUFFERING of 1 ensures cell buffer will be used on high fanout cells to reduce delay due to high capacitance load.
SYNTH_SIZING of 1 will enable cell sizing where cell will be upsize or downsized as needed to meet timing.
SYNTH_DRIVING_CELL is the cell used to drive the input ports and is vital for cells with a lot of fan-outs since it needs higher drive strength (larger driving cell needed).


Removing old result:
```
cd ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/results/synthesis
rm -rf picorv32a.synthesis.v
```

In openlane terminal:
```
run_synthesis
```




- After successfully running placement, runs/[date]/results/placement/picorv32.def will be created.

```
cd ~/Desktop/work/tools/openlane_working_dir/openlane/scripts/openroad
vim or_basic_mp.tcl
cd ~/Desktop/work/tools/openlane_working_dir/openlane/scripts/tcl_commands
vim floorplan.tcl
```
Modification in gvim


In openlane:
```
run_floorplan
run_placement
```

In terminal:
```
cd ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/results/placement
magic -T ~/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.placement.def
```
My cell in layout:


</details>

</details>

<details>
<summary>Timing analysis with ideal clocks using openSTA </summary>

<details>
<summary>Theory : Setup timing analysis, introduction to flip-flop setup time and clock jitter </summary>

*Setup timing analysis and introduction to flip-flop setup time*
- At the zero time stamp, there is one clock edge that reaches the launch flop.
- At T time stamp, the second rising edge reaches the capture flop. Any analysis that needs to be done is between 0 and T. For the combinational circuit to work, the combinational delay needs to be less than the period, T.
- Looking at more practical scenarios and how the flop works, there will be a delay within the internal flop circuitry, between mux 1 and mux 2.
- These internal delays will restrict the combinational delay requirements.
- This internal delay is known as the setup time, and this setup time needs to be subtracted away from the complete clock period T.
- Now the capture flop has enough time for it to compute the data within the flop and ensure the data is ready at Q by the time the second rise edge of clock reach.

*Introduction to clock jitter and uncertainty*
Jitter :Deviation of a clock edge from its ideal location

- Typically caused by clock generator circuitry, noise, power supply variations, interference from nearby circuitry etc. Jitter is a contributing factor to the design margin specified for timing closure

- The next practical scenario to take into consideration is jitter.

- The clock is expected to reach the clock pin at exactly 0s or at Ts, but in real scenarios, the clock signal may not be able to reach at the exact moment, as the clock source generation may have its own built-in variation.

-  This is known as jitter, the temporary variation of the clock period.

- The combinational delay will become more stringent as a result. Thus we change our combinational delay to factor in the uncertainty factor from the jitter.
</details>


<details>
<summary>Lab 1: steps to configure OpenSTA for post-synth timing analysis</summary>

```
cd ~/Desktop/work/tools/openlane_working_dir/openlane
gvim pre_sta.conf                                          (For pre-layout timing analysis)
```
pre_sta.conf file:

```ruby
set_cmd_units -time ns -capacitance pF -current mA -voltage V -resistance kOhm -distance um
read_liberty -min /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/src/sky130_fd_sc_hd__slow.lib

read_liberty -max /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/src/sky130_fd_sc_hd__fast.lib

read_verilog /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/06-10_11-41/results/synthesis/picorv32a.synthesis.v

link_design picorv32a

read_sdc /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/src/my_base1.sdc
report_checks -path_delay min_max -fields {slew trans net cap input_pin}
report_tns
report_wns
```
my_base.sdc file:
```

set ::env(CLOCK_PORT) clk 
set ::env(CLOCK_PERIOD) 12
set ::env(SYNTH_DRIVING_CELL) sky130_vsdinv 
set ::env(SYNTH_DRIVING_CELL_PIN) Y 
set ::env(SYNTH_CAP_LOAD) 17.65 
create_clock [get_ports $::env(CLOCK_PORT)] -name $::env(CLOCK_PORT) -period $::env(CLOCK_PERIOD)
set ::env(IO_PCT) 0.2
set input_delay_value [expr $::env(CLOCK_PERIOD) * $::env(IO_PCT)]
set output_delay_value [expr $::env(CLOCK_PERIOD) * $::env(IO_PCT)]
puts "\[INFO\]: Setting output delay to: $output_delay_value" 
puts "\[INFO\]: Setting input delay to: $input_delay_value"
 
## set max fanout S::env(SYNTH MAX FANOUT) (current design)
set clk_indx [lsearch [all_inputs] [get_port $::env(CLOCK_PORT)]]

#set rst indx [isearch (all inputs) Iget port resetn]]
set all_inputs_wo_clk [lreplace [all_inputs] $clk_indx $clk_indx]

#set all inputs wo clk rst (treplace sall inputs wo clk srst indx Srst indx] 
set all_inputs_wo_clk_rst $all_inputs_wo_clk

# correct resetn
set_input_delay $input_delay_value -clock [get_clocks $::env(CLOCK_PORT)] $all_inputs_wo_clk_rst

# set_input_delay 0.0 -clock [get clocks S::env(CLOCK PORT)] (resetn)
set_output_delay $output_delay_value -clock [get_clocks $::env(CLOCK_PORT)] [all_outputs]

# TODO set this as parameter
set_driving_cell -lib_cell $::env(SYNTH_DRIVING_CELL) -pin $::env(SYNTH_DRIVING_CELL_PIN) [all_inputs]
set cap_load [expr $::env(SYNTH_CAP_LOAD) / 1000.0] 
puts "\[INFO\]: Setting load to: $cap_load" 
set_load $cap_load [all_outputs]
```
Running STA:
```
cd ~/Desktop/work/tools/openlane_working_dir/openlane
sta pre_sta.conf
```
![3 hold](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/34c825e3-847b-463f-a91c-6e7c0bee888c)

![4 setup](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/e586d949-18a2-4b32-9997-2ae76c07ca6f)

![5 optimized time](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/62dd85e7-95bd-4535-841d-608c7c13edc0)


</details>


<details>
<summary>Lab 2: Lab steps to optimize synthesis to reduce setup violations</summary>
In openlane :
```
cd ~/Desktop/work/tools/openlane_working_dir/openlane
echo $::env(SYNTH_MAX_FANOUT)
set ::env(SYNTH_MAX_FANOUT) 4
```
Remove old result:
```
cd ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/13-01_14-09/results/synthesis
rm -rf picorv32a.synthesis.v
```
In openlane:
```
run_synthesis
```
```
cd ~/Desktop/work/tools/openlane_working_dir/openlane
sta pre_sta.conf
report_net -connections _18242_                           
replace_cell _41952_ sky130_fd_sc_hd__dfxtp_4             (Pick the highest fanout, cap, slew and replace the worst violations of the cell by increasing drive strength --> upsize cell from 2 to 4)
report_checks -fields {net cap dlew input pins} -digits 4
report_tns
report_wns
```

```
replace_cell _38618_ sky130_fd_sc_hd__dfxtp_4
1
```

_38618_ same as dff in design.

Timing report :
```
 report_checks -fields {net cap dlew input pins} -digits 4
Startpoint: _38615_ (rising edge-triggered flip-flop clocked by clk)
Endpoint: _38545_ (rising edge-triggered flip-flop clocked by clk)
Path Group: clk
Path Type: max

Fanout       Cap     Delay      Time   Description
----------------------------------------------------------------------------
                    0.0000    0.0000   clock clk (rise edge)
                    0.0000    0.0000   clock network delay (ideal)
                    0.0000    0.0000 ^ _38615_/CLK (sky130_fd_sc_hd__dfxtp_2)
                    0.5970    0.5970 v _38615_/Q (sky130_fd_sc_hd__dfxtp_2)
     4    0.0101                       irq_state[0] (net)
                    0.0000    0.5970 v _18612_/A (sky130_fd_sc_hd__buf_1)
                    0.2379    0.8349 v _18612_/X (sky130_fd_sc_hd__buf_1)
     6    0.0120                       _15907_ (net)
                    0.0000    0.8349 v _18623_/A (sky130_fd_sc_hd__buf_1)
                    0.2740    1.1089 v _18623_/X (sky130_fd_sc_hd__buf_1)
     6    0.0119                       _15917_ (net)
                    0.0000    1.1089 v _21670_/B (sky130_fd_sc_hd__nor2_2)
                    1.4228    2.5317 ^ _21670_/Y (sky130_fd_sc_hd__nor2_2)
    32    0.1065                       _00292_ (net)
                    0.0000    2.5317 ^ _35809_/S (sky130_fd_sc_hd__mux2_1)
                    1.1908    3.7225 v _35809_/X (sky130_fd_sc_hd__mux2_1)
     4    0.0137                       _02560_ (net)
                    0.0000    3.7225 v _23131_/A (sky130_fd_sc_hd__xnor2_2)
                    0.3358    4.0583 v _23131_/Y (sky130_fd_sc_hd__xnor2_2)
     2    0.0096                       _18154_ (net)
                    0.0000    4.0583 v _23136_/A_N (sky130_fd_sc_hd__nand3b_2)
                    0.5066    4.5649 v _23136_/Y (sky130_fd_sc_hd__nand3b_2)
     2    0.0087                       _18156_ (net)
                    0.0000    4.5649 v _23143_/A2_N (sky130_fd_sc_hd__o2bb2ai_2)
                    0.2998    4.8647 v _23143_/Y (sky130_fd_sc_hd__o2bb2ai_2)
     2    0.0087                       _18161_ (net)
                    0.0000    4.8647 v _23151_/A2_N (sky130_fd_sc_hd__o2bb2ai_2)
                    0.2386    5.1033 v _23151_/Y (sky130_fd_sc_hd__o2bb2ai_2)
     1    0.0043                       _18167_ (net)
                    0.0000    5.1033 v _23152_/B1 (sky130_fd_sc_hd__o21ai_2)
                    0.1456    5.2489 ^ _23152_/Y (sky130_fd_sc_hd__o21ai_2)
     2    0.0131                       _18168_ (net)
                    0.0000    5.2489 ^ _23159_/B1 (sky130_fd_sc_hd__o21ai_2)
                    0.1911    5.4400 v _23159_/Y (sky130_fd_sc_hd__o21ai_2)
     1    0.0043                       _18173_ (net)
                    0.0000    5.4400 v _23160_/B1 (sky130_fd_sc_hd__o21ai_2)
                    0.1469    5.5869 ^ _23160_/Y (sky130_fd_sc_hd__o21ai_2)
     2    0.0110                       _18174_ (net)
                    0.0000    5.5869 ^ _23167_/A1 (sky130_fd_sc_hd__a21o_2)
                    0.3724    5.9593 ^ _23167_/X (sky130_fd_sc_hd__a21o_2)
     2    0.0131                       _18179_ (net)
                    0.0000    5.9593 ^ _23174_/A1 (sky130_fd_sc_hd__a21oi_2)
                    0.1696    6.1288 v _23174_/Y (sky130_fd_sc_hd__a21oi_2)
     2    0.0122                       _18184_ (net)
                    0.0000    6.1288 v _23182_/A2 (sky130_fd_sc_hd__o21bai_2)
                    0.3186    6.4475 ^ _23182_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.0131                       _18190_ (net)
                    0.0000    6.4475 ^ _23189_/A1 (sky130_fd_sc_hd__a21oi_2)
                    0.2411    6.6886 v _23189_/Y (sky130_fd_sc_hd__a21oi_2)
     2    0.0122                       _18195_ (net)
                    0.0000    6.6886 v _23196_/A2 (sky130_fd_sc_hd__o21bai_2)
                    0.3259    7.0145 ^ _23196_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.0131                       _18200_ (net)
                    0.0000    7.0145 ^ _23202_/A1 (sky130_fd_sc_hd__a21oi_2)
                    0.2411    7.2556 v _23202_/Y (sky130_fd_sc_hd__a21oi_2)
     2    0.0122                       _18204_ (net)
                    0.0000    7.2556 v _23208_/A2 (sky130_fd_sc_hd__o21bai_2)
                    0.3259    7.5815 ^ _23208_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.0131                       _18208_ (net)
                    0.0000    7.5815 ^ _23214_/A1 (sky130_fd_sc_hd__a21oi_2)
                    0.2411    7.8226 v _23214_/Y (sky130_fd_sc_hd__a21oi_2)
     2    0.0122                       _18212_ (net)
                    0.0000    7.8226 v _23220_/A2 (sky130_fd_sc_hd__o21bai_2)
                    0.3259    8.1485 ^ _23220_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.0131                       _18216_ (net)
                    0.0000    8.1485 ^ _23226_/A1 (sky130_fd_sc_hd__a21oi_2)
                    0.2411    8.3896 v _23226_/Y (sky130_fd_sc_hd__a21oi_2)
     2    0.0122                       _18220_ (net)
                    0.0000    8.3896 v _23232_/A2 (sky130_fd_sc_hd__o21bai_2)
                    0.3259    8.7155 ^ _23232_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.0131                       _18224_ (net)
                    0.0000    8.7155 ^ _23238_/A1 (sky130_fd_sc_hd__a21oi_2)
                    0.2411    8.9566 v _23238_/Y (sky130_fd_sc_hd__a21oi_2)
     2    0.0122                       _18228_ (net)
                    0.0000    8.9566 v _23245_/A2 (sky130_fd_sc_hd__o21bai_2)
                    0.3259    9.2825 ^ _23245_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.0131                       _18233_ (net)
                    0.0000    9.2825 ^ _23251_/A1 (sky130_fd_sc_hd__a21oi_2)
                    0.2411    9.5236 v _23251_/Y (sky130_fd_sc_hd__a21oi_2)
     2    0.0122                       _18237_ (net)
                    0.0000    9.5236 v _23258_/A2 (sky130_fd_sc_hd__o21bai_2)
                    0.3811    9.9047 ^ _23258_/Y (sky130_fd_sc_hd__o21bai_2)
     3    0.0176                       _18242_ (net)
                    0.0000    9.9047 ^ _23268_/A (sky130_fd_sc_hd__nand3_2)
                    0.2823   10.1870 v _23268_/Y (sky130_fd_sc_hd__nand3_2)
     3    0.0099                       _18248_ (net)
                    0.0000   10.1870 v _23284_/A2 (sky130_fd_sc_hd__o211ai_2)
                    0.4462   10.6332 ^ _23284_/Y (sky130_fd_sc_hd__o211ai_2)
     3    0.0176                       _18260_ (net)
                    0.0000   10.6332 ^ _23294_/A (sky130_fd_sc_hd__nand3_2)
                    0.2957   10.9289 v _23294_/Y (sky130_fd_sc_hd__nand3_2)
     3    0.0099                       _18266_ (net)
                    0.0000   10.9289 v _23310_/A2 (sky130_fd_sc_hd__o211ai_2)
                    0.4481   11.3771 ^ _23310_/Y (sky130_fd_sc_hd__o211ai_2)
     3    0.0175                       _18278_ (net)
                    0.0000   11.3771 ^ _23315_/A (sky130_fd_sc_hd__nand2_2)
                    0.1895   11.5666 v _23315_/Y (sky130_fd_sc_hd__nand2_2)
     1    0.0043                       _18281_ (net)
                    0.0000   11.5666 v _23318_/A (sky130_fd_sc_hd__nand2_2)
                    0.1319   11.6984 ^ _23318_/Y (sky130_fd_sc_hd__nand2_2)
     1    0.0085                       _18284_ (net)
                    0.0000   11.6984 ^ _23319_/B (sky130_fd_sc_hd__xor2_2)
                    0.1086   11.8071 v _23319_/X (sky130_fd_sc_hd__xor2_2)
     1    0.0018                       _01676_ (net)
                    0.0000   11.8071 v _36534_/A1 (sky130_fd_sc_hd__mux2_1)
                    0.6252   12.4323 v _36534_/X (sky130_fd_sc_hd__mux2_1)
     1    0.0013                       _01677_ (net)
                    0.0000   12.4323 v _36988_/A1 (sky130_fd_sc_hd__mux4_1)
                    1.0986   13.5309 v _36988_/X (sky130_fd_sc_hd__mux4_1)
     1    0.0015                       _01678_ (net)
                    0.0000   13.5309 v _36535_/A0 (sky130_fd_sc_hd__mux2_1)
                    0.6333   14.1642 v _36535_/X (sky130_fd_sc_hd__mux2_1)
     1    0.0016                       _02529_ (net)
                    0.0000   14.1642 v _18990_/A (sky130_fd_sc_hd__or2b_2)
                    0.6472   14.8114 v _18990_/X (sky130_fd_sc_hd__or2b_2)
     1    0.0024                       _16178_ (net)
                    0.0000   14.8114 v _18991_/C1 (sky130_fd_sc_hd__o211a_2)
                    0.2140   15.0254 v _18991_/X (sky130_fd_sc_hd__o211a_2)
     1    0.0016                       _03989_ (net)
                    0.0000   15.0254 v _38545_/D (sky130_fd_sc_hd__dfxtp_2)
                             15.0254   data arrival time

                   12.0000   12.0000   clock clk (rise edge)
                    0.0000   12.0000   clock network delay (ideal)
                    0.0000   12.0000   clock reconvergence pessimism
                             12.0000 ^ _38545_/CLK (sky130_fd_sc_hd__dfxtp_2)
                   -0.2909   11.7091   library setup time
                             11.7091   data required time
----------------------------------------------------------------------------
                             11.7091   data required time
                            -15.0254   data arrival time
----------------------------------------------------------------------------
                             -3.3164   slack (VIOLATED)

report_tns             
tns -311.63
report_wns  
wns -3.32

```
Tns and wns has improved for setup by increasing drive strength.

![6 optimized time](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/326a2e70-c516-47e1-a607-a18301ad32dc)


</details>
</details>

<details>
<summary>Clock tree synthesis TritonCTS and signal integrity</summary>

<details>	
<summary>Theory : Clock tree routing and buffering using H-Tree algorithm, Crosstalk and clock net shielding </summary>

*Clock tree routing and buffering using H-Tree algorithm*

    - Clock tree synthesis is done to propagate the clock signals to all the clock pins in the design.
    - However, a good clock tree needs to be designed to take into account the skew between the clock pins due to long routing.
    - Through the use of H-tree, which is a smarter implementation for a clock tree design, that is designed based on the distances between the clock pins in the design between the clock port.
    - This is to give a skew value as close to 0 as possible by having the clock signals reach all the cells at the same time.
    
    - The next step is to perform clock tree buffering.
    - The wires for the clock routes each will have resistances and huge number of capacitances, and with the long routing, there will be signal integrity issues.
    - Thus, to maintain the signal integrity, we need buffering on these nets.

*Crosstalk and clock net shielding*

    - Another topic to understand before moving to using real clocks is clock net shielding.
    - Clock nets are the critical nets in the design, we build the clock tree to ensure there is a minimum skew.
    - However, if there is any cross talk that happens and affect the clock signals, that will affect the design very badly.
    - By shielding, we are protecting the clock nets from the outside world, avoiding glitches and delta delays from occurring.
    - If a glitch occurs on the clock net, incorrect data in the memory will cause inaccurate functionality for the design.
    - The shield can be connected to ground or to Vdd, as long as there is no switching activity occurring.
    - Critical data nets are also necessary to be shielded.
</details>

<details>
<summary>Lab 1: Lab steps to run CTS using TritonCTS</summary>

In sta terminal:
```
write_verilog ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/results/synthesis/picorv32a.synthesis.v
```
```
cd ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/13-01_14-09/results/synthesis
ls -lrt picorv32a.synthesis.v
date
```
In openlane:
```
run_floorplan
run_placement
run_cts
```

picorv32a.synthesis_cts.v is generated.

![6 optimized time](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/23f1ba2b-a1df-4416-a0b1-ae340d7bd9d1)

![7 optimized time](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/03ac0571-035e-4a85-8722-3385ed3ee1c0)

</details>

<details>
<summary>Lab 2: Lab steps to verify CTS runs</summary>

```
cd ~/Desktop/work/tools/openlane_working_dir/openlane/scripts/tcl_commands
vim cts.tcl
```

In openlane:
```
echo $::env(LIB_TYPICAL)
echo $::env(CURRENT_DEF)
echo $::env(CTS_MAX_CAP)
echo $::env(CTS_CLK_BUFFER_LIST)
echo $::env(CTS_ROOT_BUFFER)
```
![8_fp](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/bf37aa3b-9ad9-4aef-a3e1-93b4865b8616)

![9_place](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/321ba384-0e1a-4f9e-8343-d057a61d0059)

</details>
</details>

<details>
<summary>Timing analysis with real clocks using openSTA</summary>

<details>
<summary>Theory: Setup timing and Hold timing analysis using real clocks </summary>
	
**Setup timing analysis using real clocks**

    - After buffer has been added in, more clock network delay has been introduced and it will combining all the delays.
    - With real clocks, we will need to have buffers inserted into the clock path to ensure the clock signal integrity.
    - Because of the buffer introduction, the clock edge will reach the clock pin with consideration to the delays of the buffers inserted.
    - The clock network delay will also need to take into consideration the delays from the buffers inserted.
    - The window will become shifted as a result of the delays from the buffers inserted.
    - The skew for this design will now be the difference between the deltas.
    - If the data arrival time is higher than the data required time, then we will have negative slack on the path, meaning we have violations.

    - For hold timing analysis, where the capture edge is on the o clock rise edge, the combinational delay should be greater than the hold time of the flop.
    - Hold time refers to the second mux delay, which is the time required for the data to be sent after the clock edge within the flop.
    - So the data needs to be arrived after the hold time, so the new data can be captured into the flop, after existing data is launched out.

**Hold timing analysis using real clocks**

    - Introducing more real factors into our design for hold analysis will yield the below equation for hold timing.
    - Jitter for the launch clock and capture flop will not need to be taken into consideration as the design is on the 0 clock edge, and the arrival difference for the capture and launch flop will be the same.
    - So, the uncertainty should be kept low for the hold analysis.
    - The slack formula will be --> data arrival time â€“ data required time
    - If data required time is higher, we will have negative slack, meaning the timing path for hold will be violated.
    - For the timing path setup for real clocks, we need to take into considerations the deltas that were mentioned earlier.
    - For delta1, will be launch clock network delay, while delta2, will be capture clock network delay.
</details>


<details>
<summary>Lab 1: Lab steps to analyze timing with real clocks using OpenSTA</summary>

In openlane:
```
openroad                                                                                                       (Invoking openroad)
read_lef /openLANE_flow/designs/picorv32a/runs/13-01_14-09/tmp/merged.lef
read_def /openLANE_flow/designs/picorv32a/runs/13-01_14-09/results/cts/picorv32a.cts.def
write_db pico_cts.db
read_db pico_cts.db
read_verilog /openLANE_flow/designs/picorv32a/runs/13-01_14-09/results/synthesis/picorv32a.synthesis_cts.v
read_liberty -max $::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__slow.lib
read_liberty -min $::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__fast.lib
set_propagated_clock [all_clocks]
read_sdc designs/picorv32a/src/my_base.sdc
report_checks -path_delay min_max -format full_clock_expanded -digits 4
```
This step is not practical, therefore it violated.

```

% report_checks -path_delay min_max -format full_clock_expanded -digits 4
Startpoint: _40725_ (rising edge-triggered flip-flop clocked by clk)
Endpoint: _40725_ (rising edge-triggered flip-flop clocked by clk)
Path Group: clk
Path Type: min

    Delay      Time   Description
-------------------------------------------------------------
   0.0000    0.0000   clock clk (rise edge)
   0.0000    0.0000   clock network delay (ideal)
   0.0000    0.0000 ^ _40725_/CLK (sky130_fd_sc_hd__dfxtp_1)
   0.1823    0.1823 ^ _40725_/Q (sky130_fd_sc_hd__dfxtp_1)
   0.0472    0.2295 ^ _23930_/X (sky130_fd_sc_hd__clkbuf_1)
   0.0000    0.2295 ^ _40725_/D (sky130_fd_sc_hd__dfxtp_1)
             0.2295   data arrival time

   0.0000    0.0000   clock clk (rise edge)
   0.0000    0.0000   clock network delay (ideal)
   0.0000    0.0000   clock reconvergence pessimism
             0.0000 ^ _40725_/CLK (sky130_fd_sc_hd__dfxtp_1)
  -0.0176   -0.0176   library hold time
            -0.0176   data required time
-------------------------------------------------------------
           -0.0176   data required time
            -0.2295   data arrival time
-------------------------------------------------------------
             0.2471   slack (MET)


Startpoint: _41952_ (rising edge-triggered flip-flop clocked by clk)
Endpoint: _41879_ (rising edge-triggered flip-flop clocked by clk)
Path Group: clk
Path Type: max

    Delay      Time   Description
-------------------------------------------------------------
   0.0000    0.0000   clock clk (rise edge)
   0.0000    0.0000   clock network delay (ideal)
   0.0000    0.0000 ^ _41952_/CLK (sky130_fd_sc_hd__dfxtp_4)
   0.9923    0.9923 ^ _41952_/Q (sky130_fd_sc_hd__dfxtp_4)
   0.8498    1.8421 v _39853_/X (sky130_fd_sc_hd__mux2_1)
   0.6464    2.4885 v _39852_/X (sky130_fd_sc_hd__mux2_1)
   0.3149    2.8034 v _25161_/X (sky130_fd_sc_hd__and2_1)
   0.6072    3.4106 v _39143_/X (sky130_fd_sc_hd__mux2_2)
   0.2837    3.6942 v _25583_/Y (sky130_fd_sc_hd__xnor2_1)
   0.4643    4.1586 v _25588_/Y (sky130_fd_sc_hd__nand3b_2)
   0.2835    4.4421 v _25595_/Y (sky130_fd_sc_hd__o2bb2ai_1)
   0.2387    4.6809 v _25603_/Y (sky130_fd_sc_hd__o2bb2ai_1)
   0.1845    4.8653 ^ _25604_/Y (sky130_fd_sc_hd__o21ai_1)
   0.2208    5.0861 v _25611_/Y (sky130_fd_sc_hd__o21ai_1)
   0.1325    5.2187 ^ _25612_/Y (sky130_fd_sc_hd__o21ai_2)
   0.3209    5.5395 ^ _25619_/X (sky130_fd_sc_hd__a21o_1)
   0.1551    5.6946 v _25626_/Y (sky130_fd_sc_hd__a21oi_2)
   0.3124    6.0071 ^ _25634_/Y (sky130_fd_sc_hd__o21bai_2)
   0.1891    6.1962 v _25641_/Y (sky130_fd_sc_hd__a21oi_4)
   0.2576    6.4538 ^ _25648_/Y (sky130_fd_sc_hd__o21bai_2)
   0.1952    6.6490 v _25654_/Y (sky130_fd_sc_hd__a21oi_2)
   0.3159    6.9649 ^ _25660_/Y (sky130_fd_sc_hd__o21bai_2)
   0.1891    7.1539 v _25666_/Y (sky130_fd_sc_hd__a21oi_4)
   0.2576    7.4115 ^ _25672_/Y (sky130_fd_sc_hd__o21bai_2)
   0.1952    7.6067 v _25678_/Y (sky130_fd_sc_hd__a21oi_2)
   0.3158    7.9225 ^ _25684_/Y (sky130_fd_sc_hd__o21bai_2)
   0.2038    8.1264 v _25690_/Y (sky130_fd_sc_hd__a21oi_4)
   0.2544    8.3808 ^ _25697_/Y (sky130_fd_sc_hd__o21bai_4)
   0.1776    8.5583 v _25704_/Y (sky130_fd_sc_hd__a21oi_4)
   0.2661    8.8244 ^ _25711_/Y (sky130_fd_sc_hd__o21bai_4)
   0.2044    9.0288 v _25721_/Y (sky130_fd_sc_hd__nand3_4)
   0.3568    9.3856 ^ _25737_/Y (sky130_fd_sc_hd__o211ai_4)
   0.2251    9.6107 v _25747_/Y (sky130_fd_sc_hd__nand3_4)
   0.3081    9.9188 ^ _25763_/Y (sky130_fd_sc_hd__o211ai_4)
   0.1550   10.0737 v _25768_/Y (sky130_fd_sc_hd__nand2_1)
   0.1149   10.1887 ^ _25771_/Y (sky130_fd_sc_hd__nand2_1)
   0.1165   10.3051 v _25772_/X (sky130_fd_sc_hd__xor2_1)
   0.6296   10.9347 v _39868_/X (sky130_fd_sc_hd__mux2_1)
   1.0986   12.0333 v _40322_/X (sky130_fd_sc_hd__mux4_1)
   0.6333   12.6665 v _39869_/X (sky130_fd_sc_hd__mux2_1)
   0.4839   13.1505 v _20796_/X (sky130_fd_sc_hd__or2b_1)
   0.1920   13.3424 v _20797_/X (sky130_fd_sc_hd__o211a_1)
   0.0000   13.3424 v _41879_/D (sky130_fd_sc_hd__dfxtp_1)
            13.3424   data arrival time

  12.0000   12.0000   clock clk (rise edge)
   0.0000   12.0000   clock network delay (ideal)
   0.0000   12.0000   clock reconvergence pessimism
            12.0000 ^ _41879_/CLK (sky130_fd_sc_hd__dfxtp_1)
  -0.2845   11.7155   library setup time
            11.7155   data required time
-------------------------------------------------------------
            11.7155   data required time
           -13.3424   data arrival time
-------------------------------------------------------------
            -1.6270   slack (VIOLATED)
```

</details>


<details>
<summary>Lab 2: Lab steps to execute OpenSTA with right timing libraries and CTS assignment</summary>

Continuing from previous lab:
```
exit        (Exit openroad)
openroad
read_db pico_cts.db
read_verilog /openLANE_flow/designs/picorv32a/runs/13-01_14-09/results/synthesis/picorv32a.synthesis_cts.v
read_liberty $::env(LIB_SYNTH_COMPLETE)
link_design picorv32a
read_sdc designs/picorv32a/src/my_base.sdc
set_propagated_clock [all_clocks]
report_checks -path_delay min_max -fields {slew trans net cap input pin} -format full_clock_expanded
echo $::env(CTS_CLK_BUFFER_LIST)                              (To see the list of buffers)
```

- Both timing are already met after post CTS
- The tool picked small cell first to meet the skew and area
  - skew values are within 10% of the max clock period
```
% report_checks -path_delay min_max -fields {slew trans net cap input pin} -format full_clock_expanded
Startpoint: _37166_ (rising edge-triggered flip-flop clocked by clk)
Endpoint: _37548_ (rising edge-triggered flip-flop clocked by clk)
Path Group: clk
Path Type: min

Fanout     Cap    Slew   Delay    Time   Description
-----------------------------------------------------------------------------
                          0.00    0.00   clock clk (rise edge)
                          0.00    0.00   clock source latency
                  0.00    0.00    0.00 ^ clk (in)
     1    0.01                           clk (net)
                  0.00    0.00    0.00 ^ clkbuf_0_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.03    0.09    0.09 ^ clkbuf_0_clk/X (sky130_fd_sc_hd__clkbuf_16)
     2    0.00                           clknet_0_clk (net)
                  0.03    0.00    0.09 ^ clkbuf_1_1_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.04    0.07    0.16 ^ clkbuf_1_1_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     1    0.00                           clknet_1_1_0_clk (net)
                  0.04    0.00    0.16 ^ clkbuf_1_1_1_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.06    0.09    0.25 ^ clkbuf_1_1_1_clk/X (sky130_fd_sc_hd__clkbuf_1)
     2    0.00                           clknet_1_1_1_clk (net)
                  0.06    0.00    0.25 ^ clkbuf_2_2_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.04    0.08    0.34 ^ clkbuf_2_2_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     1    0.00                           clknet_2_2_0_clk (net)
                  0.04    0.00    0.34 ^ clkbuf_2_2_1_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.06    0.09    0.43 ^ clkbuf_2_2_1_clk/X (sky130_fd_sc_hd__clkbuf_1)
     2    0.00                           clknet_2_2_1_clk (net)
                  0.06    0.00    0.43 ^ clkbuf_3_4_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.06    0.10    0.53 ^ clkbuf_3_4_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     2    0.00                           clknet_3_4_0_clk (net)
                  0.06    0.00    0.53 ^ clkbuf_4_8_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.06    0.10    0.62 ^ clkbuf_4_8_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     2    0.00                           clknet_4_8_0_clk (net)
                  0.06    0.00    0.62 ^ clkbuf_5_17_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.47    0.38    1.00 ^ clkbuf_5_17_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     5    0.04                           clknet_5_17_0_clk (net)
                  0.47    0.00    1.00 ^ clkbuf_leaf_182_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.04    0.22    1.22 ^ clkbuf_leaf_182_clk/X (sky130_fd_sc_hd__clkbuf_16)
     5    0.01                           clknet_leaf_182_clk (net)
                  0.04    0.00    1.22 ^ _37166_/CLK (sky130_fd_sc_hd__dfxtp_1)
                  0.04    0.29    1.52 ^ _37166_/Q (sky130_fd_sc_hd__dfxtp_1)
     1    0.00                           alu_out_q[29] (net)
                  0.04    0.00    1.52 ^ _36370_/A1 (sky130_fd_sc_hd__mux2_1)
                  0.06    0.13    1.64 ^ _36370_/X (sky130_fd_sc_hd__mux2_1)
     2    0.00                           _01548_ (net)
                  0.06    0.00    1.64 ^ _24072_/B2 (sky130_fd_sc_hd__a221o_1)
                  0.04    0.13    1.77 ^ _24072_/X (sky130_fd_sc_hd__a221o_1)
     1    0.00                           _02128_ (net)
                  0.04    0.00    1.77 ^ _35742_/A0 (sky130_fd_sc_hd__mux2_4)
                  0.05    0.14    1.92 ^ _35742_/X (sky130_fd_sc_hd__mux2_4)
     4    0.01                           cpuregs_wrdata[29] (net)
                  0.05    0.00    1.92 ^ _21409_/A1 (sky130_fd_sc_hd__mux2_1)
                  0.03    0.11    2.03 ^ _21409_/X (sky130_fd_sc_hd__mux2_1)
     1    0.00                           _02992_ (net)
                  0.03    0.00    2.03 ^ _37548_/D (sky130_fd_sc_hd__dfxtp_1)
                                  2.03   data arrival time

                          0.00    0.00   clock clk (rise edge)
                          0.00    0.00   clock source latency
                  0.00    0.00    0.00 ^ clk (in)
     1    0.01                           clk (net)
                  0.00    0.00    0.00 ^ clkbuf_0_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.03    0.09    0.09 ^ clkbuf_0_clk/X (sky130_fd_sc_hd__clkbuf_16)
     2    0.00                           clknet_0_clk (net)
                  0.03    0.00    0.09 ^ clkbuf_1_0_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.04    0.07    0.16 ^ clkbuf_1_0_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     1    0.00                           clknet_1_0_0_clk (net)
                  0.04    0.00    0.16 ^ clkbuf_1_0_1_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.06    0.09    0.25 ^ clkbuf_1_0_1_clk/X (sky130_fd_sc_hd__clkbuf_1)
     2    0.00                           clknet_1_0_1_clk (net)
                  0.06    0.00    0.25 ^ clkbuf_2_0_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.04    0.08    0.34 ^ clkbuf_2_0_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     1    0.00                           clknet_2_0_0_clk (net)
                  0.04    0.00    0.34 ^ clkbuf_2_0_1_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.06    0.09    0.43 ^ clkbuf_2_0_1_clk/X (sky130_fd_sc_hd__clkbuf_1)
     2    0.00                           clknet_2_0_1_clk (net)
                  0.06    0.00    0.43 ^ clkbuf_3_0_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.06    0.10    0.53 ^ clkbuf_3_0_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     2    0.00                           clknet_3_0_0_clk (net)
                  0.06    0.00    0.53 ^ clkbuf_4_0_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.06    0.10    0.62 ^ clkbuf_4_0_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     2    0.00                           clknet_4_0_0_clk (net)
                  0.06    0.00    0.62 ^ clkbuf_5_0_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  1.46    1.06    1.69 ^ clkbuf_5_0_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
    16    0.13                           clknet_5_0_0_clk (net)
                  1.46    0.00    1.69 ^ clkbuf_leaf_259_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.07    0.32    2.00 ^ clkbuf_leaf_259_clk/X (sky130_fd_sc_hd__clkbuf_16)
     5    0.01                           clknet_leaf_259_clk (net)
                  0.07    0.00    2.00 ^ _37548_/CLK (sky130_fd_sc_hd__dfxtp_1)
                          0.00    2.00   clock reconvergence pessimism
                         -0.03    1.98   library hold time
                                  1.98   data required time
-----------------------------------------------------------------------------
                                  1.98   data required time
                                 -2.03   data arrival time
-----------------------------------------------------------------------------
                                  0.05   slack (MET)


Startpoint: _38618_ (rising edge-triggered flip-flop clocked by clk)
Endpoint: _38545_ (rising edge-triggered flip-flop clocked by clk)
Path Group: clk
Path Type: max

Fanout     Cap    Slew   Delay    Time   Description
-----------------------------------------------------------------------------
                          0.00    0.00   clock clk (rise edge)
                          0.00    0.00   clock source latency
                  0.00    0.00    0.00 ^ clk (in)
     1    0.01                           clk (net)
                  0.00    0.00    0.00 ^ clkbuf_0_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.03    0.09    0.09 ^ clkbuf_0_clk/X (sky130_fd_sc_hd__clkbuf_16)
     2    0.00                           clknet_0_clk (net)
                  0.03    0.00    0.09 ^ clkbuf_1_0_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.04    0.07    0.16 ^ clkbuf_1_0_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     1    0.00                           clknet_1_0_0_clk (net)
                  0.04    0.00    0.16 ^ clkbuf_1_0_1_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.06    0.09    0.25 ^ clkbuf_1_0_1_clk/X (sky130_fd_sc_hd__clkbuf_1)
     2    0.00                           clknet_1_0_1_clk (net)
                  0.06    0.00    0.25 ^ clkbuf_2_1_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.04    0.08    0.34 ^ clkbuf_2_1_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     1    0.00                           clknet_2_1_0_clk (net)
                  0.04    0.00    0.34 ^ clkbuf_2_1_1_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.06    0.09    0.43 ^ clkbuf_2_1_1_clk/X (sky130_fd_sc_hd__clkbuf_1)
     2    0.00                           clknet_2_1_1_clk (net)
                  0.06    0.00    0.43 ^ clkbuf_3_3_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.06    0.10    0.53 ^ clkbuf_3_3_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     2    0.00                           clknet_3_3_0_clk (net)
                  0.06    0.00    0.53 ^ clkbuf_4_6_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.06    0.10    0.62 ^ clkbuf_4_6_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     2    0.00                           clknet_4_6_0_clk (net)
                  0.06    0.00    0.62 ^ clkbuf_5_12_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.65    0.50    1.13 ^ clkbuf_5_12_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     7    0.06                           clknet_5_12_0_clk (net)
                  0.65    0.00    1.13 ^ clkbuf_leaf_212_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.04    0.25    1.37 ^ clkbuf_leaf_212_clk/X (sky130_fd_sc_hd__clkbuf_16)
     2    0.00                           clknet_leaf_212_clk (net)
                  0.04    0.00    1.37 ^ _38618_/CLK (sky130_fd_sc_hd__dfxtp_4)
                  0.33    0.55    1.92 ^ _38618_/Q (sky130_fd_sc_hd__dfxtp_4)
    33    0.12                           latched_stalu (net)
                  0.33    0.00    1.92 ^ _36519_/S (sky130_fd_sc_hd__mux2_1)
                  0.06    0.37    2.29 v _36519_/X (sky130_fd_sc_hd__mux2_1)
     2    0.00                           _00293_ (net)
                  0.06    0.00    2.29 v _36518_/A1 (sky130_fd_sc_hd__mux2_1)
                  0.05    0.28    2.57 v _36518_/X (sky130_fd_sc_hd__mux2_1)
     1    0.00                           _00294_ (net)
                  0.05    0.00    2.57 v _22741_/B (sky130_fd_sc_hd__and2_1)
                  0.03    0.15    2.71 v _22741_/X (sky130_fd_sc_hd__and2_1)
     1    0.00                           _00295_ (net)
                  0.03    0.00    2.71 v _35809_/A0 (sky130_fd_sc_hd__mux2_2)
                  0.07    0.28    2.99 v _35809_/X (sky130_fd_sc_hd__mux2_2)
     4    0.01                           _02560_ (net)
                  0.07    0.00    2.99 v _23131_/A (sky130_fd_sc_hd__xnor2_1)
                  0.07    0.15    3.14 v _23131_/Y (sky130_fd_sc_hd__xnor2_1)
     2    0.01                           _18154_ (net)
                  0.07    0.00    3.14 v _23136_/A_N (sky130_fd_sc_hd__nand3b_2)
                  0.07    0.21    3.35 v _23136_/Y (sky130_fd_sc_hd__nand3b_2)
     2    0.00                           _18156_ (net)
                  0.07    0.00    3.35 v _23143_/A2_N (sky130_fd_sc_hd__o2bb2ai_1)
                  0.06    0.14    3.49 v _23143_/Y (sky130_fd_sc_hd__o2bb2ai_1)
     2    0.00                           _18161_ (net)
                  0.06    0.00    3.49 v _23151_/A2_N (sky130_fd_sc_hd__o2bb2ai_1)
                  0.05    0.13    3.62 v _23151_/Y (sky130_fd_sc_hd__o2bb2ai_1)
     1    0.00                           _18167_ (net)
                  0.05    0.00    3.62 v _23152_/B1 (sky130_fd_sc_hd__o21ai_2)
                  0.12    0.07    3.68 ^ _23152_/Y (sky130_fd_sc_hd__o21ai_2)
     2    0.01                           _18168_ (net)
                  0.12    0.00    3.68 ^ _23159_/B1 (sky130_fd_sc_hd__o21ai_1)
                  0.06    0.09    3.77 v _23159_/Y (sky130_fd_sc_hd__o21ai_1)
     1    0.00                           _18173_ (net)
                  0.06    0.00    3.77 v _23160_/B1 (sky130_fd_sc_hd__o21ai_2)
                  0.13    0.07    3.84 ^ _23160_/Y (sky130_fd_sc_hd__o21ai_2)
     2    0.01                           _18174_ (net)
                  0.13    0.00    3.84 ^ _23167_/A1 (sky130_fd_sc_hd__a21o_1)
                  0.13    0.19    4.03 ^ _23167_/X (sky130_fd_sc_hd__a21o_1)
     2    0.01                           _18179_ (net)
                  0.13    0.00    4.03 ^ _23174_/A1 (sky130_fd_sc_hd__a21oi_4)
                  0.05    0.07    4.10 v _23174_/Y (sky130_fd_sc_hd__a21oi_4)
     2    0.01                           _18184_ (net)
                  0.05    0.00    4.10 v _23182_/A2 (sky130_fd_sc_hd__o21bai_2)
                  0.20    0.18    4.28 ^ _23182_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.01                           _18190_ (net)
                  0.20    0.00    4.28 ^ _23189_/A1 (sky130_fd_sc_hd__a21oi_4)
                  0.06    0.08    4.37 v _23189_/Y (sky130_fd_sc_hd__a21oi_4)
     2    0.01                           _18195_ (net)
                  0.06    0.00    4.37 v _23196_/A2 (sky130_fd_sc_hd__o21bai_2)
                  0.15    0.15    4.52 ^ _23196_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.01                           _18200_ (net)
                  0.15    0.00    4.52 ^ _23202_/A1 (sky130_fd_sc_hd__a21oi_2)
                  0.06    0.09    4.61 v _23202_/Y (sky130_fd_sc_hd__a21oi_2)
     2    0.01                           _18204_ (net)
                  0.06    0.00    4.61 v _23208_/A2 (sky130_fd_sc_hd__o21bai_2)
                  0.20    0.19    4.79 ^ _23208_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.01                           _18208_ (net)
                  0.20    0.00    4.79 ^ _23214_/A1 (sky130_fd_sc_hd__a21oi_4)
                  0.06    0.08    4.87 v _23214_/Y (sky130_fd_sc_hd__a21oi_4)
     2    0.01                           _18212_ (net)
                  0.06    0.00    4.87 v _23220_/A2 (sky130_fd_sc_hd__o21bai_2)
                  0.20    0.18    5.06 ^ _23220_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.01                           _18216_ (net)
                  0.20    0.00    5.06 ^ _23226_/A1 (sky130_fd_sc_hd__a21oi_4)
                  0.06    0.08    5.14 v _23226_/Y (sky130_fd_sc_hd__a21oi_4)
     2    0.01                           _18220_ (net)
                  0.06    0.00    5.14 v _23232_/A2 (sky130_fd_sc_hd__o21bai_2)
                  0.15    0.15    5.29 ^ _23232_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.01                           _18224_ (net)
                  0.15    0.00    5.29 ^ _23238_/A1 (sky130_fd_sc_hd__a21oi_2)
                  0.06    0.09    5.38 v _23238_/Y (sky130_fd_sc_hd__a21oi_2)
     2    0.01                           _18228_ (net)
                  0.06    0.00    5.38 v _23245_/A2 (sky130_fd_sc_hd__o21bai_2)
                  0.20    0.19    5.56 ^ _23245_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.01                           _18233_ (net)
                  0.20    0.00    5.56 ^ _23251_/A1 (sky130_fd_sc_hd__a21oi_4)
                  0.07    0.09    5.65 v _23251_/Y (sky130_fd_sc_hd__a21oi_4)
     2    0.01                           _18237_ (net)
                  0.07    0.00    5.65 v _23258_/A2 (sky130_fd_sc_hd__o21bai_4)
                  0.16    0.16    5.81 ^ _23258_/Y (sky130_fd_sc_hd__o21bai_4)
     3    0.02                           _18242_ (net)
                  0.16    0.00    5.81 ^ _23268_/A (sky130_fd_sc_hd__nand3_4)
                  0.08    0.10    5.91 v _23268_/Y (sky130_fd_sc_hd__nand3_4)
     3    0.01                           _18248_ (net)
                  0.08    0.00    5.91 v _23284_/A2 (sky130_fd_sc_hd__o211ai_4)
                  0.20    0.21    6.12 ^ _23284_/Y (sky130_fd_sc_hd__o211ai_4)
     3    0.02                           _18260_ (net)
                  0.20    0.00    6.12 ^ _23294_/A (sky130_fd_sc_hd__nand3_4)
                  0.09    0.10    6.23 v _23294_/Y (sky130_fd_sc_hd__nand3_4)
     3    0.01                           _18266_ (net)
                  0.09    0.00    6.23 v _23310_/A2 (sky130_fd_sc_hd__o211ai_4)
                  0.16    0.18    6.41 ^ _23310_/Y (sky130_fd_sc_hd__o211ai_4)
     3    0.01                           _18278_ (net)
                  0.16    0.00    6.41 ^ _23315_/A (sky130_fd_sc_hd__nand2_1)
                  0.05    0.06    6.47 v _23315_/Y (sky130_fd_sc_hd__nand2_1)
     1    0.00                           _18281_ (net)
                  0.05    0.00    6.47 v _23318_/A (sky130_fd_sc_hd__nand2_1)
                  0.06    0.07    6.54 ^ _23318_/Y (sky130_fd_sc_hd__nand2_1)
     1    0.00                           _18284_ (net)
                  0.06    0.00    6.54 ^ _23319_/B (sky130_fd_sc_hd__xor2_1)
                  0.05    0.05    6.59 v _23319_/X (sky130_fd_sc_hd__xor2_1)
     1    0.00                           _01676_ (net)
                  0.05    0.00    6.59 v _36534_/A1 (sky130_fd_sc_hd__mux2_1)
                  0.05    0.27    6.87 v _36534_/X (sky130_fd_sc_hd__mux2_1)
     1    0.00                           _01677_ (net)
                  0.05    0.00    6.87 v _36988_/A1 (sky130_fd_sc_hd__mux4_1)
                  0.08    0.48    7.34 v _36988_/X (sky130_fd_sc_hd__mux4_1)
     1    0.00                           _01678_ (net)
                  0.08    0.00    7.34 v _36535_/A0 (sky130_fd_sc_hd__mux2_1)
                  0.05    0.28    7.62 v _36535_/X (sky130_fd_sc_hd__mux2_1)
     1    0.00                           _02529_ (net)
                  0.05    0.00    7.62 v _18990_/A (sky130_fd_sc_hd__or2b_1)
                  0.04    0.21    7.83 v _18990_/X (sky130_fd_sc_hd__or2b_1)
     1    0.00                           _16178_ (net)
                  0.04    0.00    7.83 v _18991_/C1 (sky130_fd_sc_hd__o211a_1)
                  0.03    0.10    7.93 v _18991_/X (sky130_fd_sc_hd__o211a_1)
     1    0.00                           _03989_ (net)
                  0.03    0.00    7.93 v _38545_/D (sky130_fd_sc_hd__dfxtp_1)
                                  7.93   data arrival time

                         12.00   12.00   clock clk (rise edge)
                          0.00   12.00   clock source latency
                  0.00    0.00   12.00 ^ clk (in)
     1    0.01                           clk (net)
                  0.00    0.00   12.00 ^ clkbuf_0_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.03    0.09   12.09 ^ clkbuf_0_clk/X (sky130_fd_sc_hd__clkbuf_16)
     2    0.00                           clknet_0_clk (net)
                  0.03    0.00   12.09 ^ clkbuf_1_1_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.04    0.07   12.16 ^ clkbuf_1_1_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     1    0.00                           clknet_1_1_0_clk (net)
                  0.04    0.00   12.16 ^ clkbuf_1_1_1_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.06    0.09   12.25 ^ clkbuf_1_1_1_clk/X (sky130_fd_sc_hd__clkbuf_1)
     2    0.00                           clknet_1_1_1_clk (net)
                  0.06    0.00   12.25 ^ clkbuf_2_2_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.04    0.08   12.34 ^ clkbuf_2_2_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     1    0.00                           clknet_2_2_0_clk (net)
                  0.04    0.00   12.34 ^ clkbuf_2_2_1_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.06    0.09   12.43 ^ clkbuf_2_2_1_clk/X (sky130_fd_sc_hd__clkbuf_1)
     2    0.00                           clknet_2_2_1_clk (net)
                  0.06    0.00   12.43 ^ clkbuf_3_4_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.06    0.10   12.53 ^ clkbuf_3_4_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     2    0.00                           clknet_3_4_0_clk (net)
                  0.06    0.00   12.53 ^ clkbuf_4_8_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.06    0.10   12.62 ^ clkbuf_4_8_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     2    0.00                           clknet_4_8_0_clk (net)
                  0.06    0.00   12.62 ^ clkbuf_5_17_0_clk/A (sky130_fd_sc_hd__clkbuf_1)
                  0.47    0.38   13.00 ^ clkbuf_5_17_0_clk/X (sky130_fd_sc_hd__clkbuf_1)
     5    0.04                           clknet_5_17_0_clk (net)
                  0.47    0.00   13.00 ^ clkbuf_leaf_182_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.04    0.22   13.22 ^ clkbuf_leaf_182_clk/X (sky130_fd_sc_hd__clkbuf_16)
     5    0.01                           clknet_leaf_182_clk (net)
                  0.04    0.00   13.22 ^ _38545_/CLK (sky130_fd_sc_hd__dfxtp_1)
                          0.00   13.22   clock reconvergence pessimism
                         -0.11   13.12   library setup time
                                 13.12   data required time
-----------------------------------------------------------------------------
                                 13.12   data required time
                                 -7.93   data arrival time
-----------------------------------------------------------------------------
                                  5.19   slack (MET)

```




</details>

<details>
<summary>Lab 3: Lab steps to observe impact of bigger CTS buffers on setup and hold timing</summary>

In openlane:
```
exit 
echo $::env(CTS_CLK_BUFFER_LIST)
set ::env(CTS_CLK_BUFFER_LIST) [lreplace $::env(CTS_CLK_BUFFER_LIST) 0 0]
echo $::env(CURRENT_DEF)
set ::env(CURRENT_DEF) /openLANE_flow/designs/picorv32a/runs/13-01_14-09/results/placement/picorv32a.placement.def
run_cts
openroad
read_lef /openLANE_flow/designs/picorv32a/runs/13-01_14-09/tmp/merged.lef
read_def /openLANE_flow/designs/picorv32a/runs/13-01_14-09/results/cts/picorv32a.cts.def
write_db pico_cts1.db
read_db pico_cts1.db
read_verilog /openLANE_flow/designs/picorv32a/runs/13-01_14-09/results/synthesis/picorv32a.synthesis_cts.v
read_liberty $::env(LIB_SYNTH_COMPLETE)
link_design picorv32a
read_sdc designs/picorv32a/src/my_base.sdc
set_propagated_clock [all_clocks]
report_checks -path_delay min_max -fields {slew trans net cap input pin} -format full_clock_expanded
```

Report check : Both MIN and MAX slack
```

report_checks -path_delay min_max -fields {slew trans net cap input pin} -format full_clock_expanded
Startpoint: _37098_ (rising edge-triggered flip-flop clocked by clk)
Endpoint: _37103_ (rising edge-triggered flip-flop clocked by clk)
Path Group: clk
Path Type: min

Fanout     Cap    Slew   Delay    Time   Description
-----------------------------------------------------------------------------
                          0.00    0.00   clock clk (rise edge)
                          0.00    0.00   clock source latency
                  0.00    0.00    0.00 ^ clk (in)
     1    0.01                           clk (net)
                  0.00    0.00    0.00 ^ clkbuf_0_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.03    0.09    0.09 ^ clkbuf_0_clk/X (sky130_fd_sc_hd__clkbuf_16)
     2    0.00                           clknet_0_clk (net)
                  0.03    0.00    0.09 ^ clkbuf_1_0_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.10    0.20 ^ clkbuf_1_0_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     1    0.00                           clknet_1_0_0_clk (net)
                  0.03    0.00    0.20 ^ clkbuf_1_0_1_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11    0.31 ^ clkbuf_1_0_1_clk/X (sky130_fd_sc_hd__clkbuf_4)
     2    0.00                           clknet_1_0_1_clk (net)
                  0.03    0.00    0.31 ^ clkbuf_2_1_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11    0.42 ^ clkbuf_2_1_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     1    0.00                           clknet_2_1_0_clk (net)
                  0.03    0.00    0.42 ^ clkbuf_2_1_1_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11    0.53 ^ clkbuf_2_1_1_clk/X (sky130_fd_sc_hd__clkbuf_4)
     2    0.00                           clknet_2_1_1_clk (net)
                  0.03    0.00    0.53 ^ clkbuf_3_2_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11    0.64 ^ clkbuf_3_2_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     2    0.00                           clknet_3_2_0_clk (net)
                  0.03    0.00    0.64 ^ clkbuf_4_4_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11    0.75 ^ clkbuf_4_4_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     2    0.00                           clknet_4_4_0_clk (net)
                  0.03    0.00    0.75 ^ clkbuf_5_9_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.15    0.21    0.96 ^ clkbuf_5_9_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     6    0.05                           clknet_5_9_0_clk (net)
                  0.15    0.00    0.96 ^ clkbuf_leaf_219_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.03    0.15    1.11 ^ clkbuf_leaf_219_clk/X (sky130_fd_sc_hd__clkbuf_16)
     4    0.01                           clknet_leaf_219_clk (net)
                  0.03    0.00    1.11 ^ _37098_/CLK (sky130_fd_sc_hd__dfxtp_2)
                  0.07    0.33    1.44 ^ _37098_/Q (sky130_fd_sc_hd__dfxtp_2)
     6    0.01                           irq_pending[0] (net)
                  0.07    0.00    1.44 ^ _35948_/A1 (sky130_fd_sc_hd__mux2_1)
                  0.03    0.12    1.56 ^ _35948_/X (sky130_fd_sc_hd__mux2_1)
     1    0.00                           _18309_ (net)
                  0.03    0.00    1.56 ^ _37103_/D (sky130_fd_sc_hd__dfxtp_1)
                                  1.56   data arrival time

                          0.00    0.00   clock clk (rise edge)
                          0.00    0.00   clock source latency
                  0.00    0.00    0.00 ^ clk (in)
     1    0.01                           clk (net)
                  0.00    0.00    0.00 ^ clkbuf_0_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.03    0.09    0.09 ^ clkbuf_0_clk/X (sky130_fd_sc_hd__clkbuf_16)
     2    0.00                           clknet_0_clk (net)
                  0.03    0.00    0.09 ^ clkbuf_1_1_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.10    0.20 ^ clkbuf_1_1_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     1    0.00                           clknet_1_1_0_clk (net)
                  0.03    0.00    0.20 ^ clkbuf_1_1_1_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11    0.31 ^ clkbuf_1_1_1_clk/X (sky130_fd_sc_hd__clkbuf_4)
     2    0.00                           clknet_1_1_1_clk (net)
                  0.03    0.00    0.31 ^ clkbuf_2_2_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11    0.42 ^ clkbuf_2_2_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     1    0.00                           clknet_2_2_0_clk (net)
                  0.03    0.00    0.42 ^ clkbuf_2_2_1_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11    0.53 ^ clkbuf_2_2_1_clk/X (sky130_fd_sc_hd__clkbuf_4)
     2    0.00                           clknet_2_2_1_clk (net)
                  0.03    0.00    0.53 ^ clkbuf_3_5_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11    0.64 ^ clkbuf_3_5_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     2    0.00                           clknet_3_5_0_clk (net)
                  0.03    0.00    0.64 ^ clkbuf_4_10_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11    0.75 ^ clkbuf_4_10_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     2    0.00                           clknet_4_10_0_clk (net)
                  0.03    0.00    0.75 ^ clkbuf_5_20_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.17    0.22    0.98 ^ clkbuf_5_20_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     7    0.06                           clknet_5_20_0_clk (net)
                  0.17    0.00    0.98 ^ clkbuf_opt_5_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.03    0.16    1.14 ^ clkbuf_opt_5_clk/X (sky130_fd_sc_hd__clkbuf_16)
     1    0.01                           clknet_opt_5_clk (net)
                  0.03    0.00    1.14 ^ clkbuf_leaf_187_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.04    0.12    1.25 ^ clkbuf_leaf_187_clk/X (sky130_fd_sc_hd__clkbuf_16)
     8    0.02                           clknet_leaf_187_clk (net)
                  0.04    0.00    1.25 ^ _37103_/CLK (sky130_fd_sc_hd__dfxtp_1)
                          0.00    1.25   clock reconvergence pessimism
                         -0.03    1.22   library hold time
                                  1.22   data required time
-----------------------------------------------------------------------------
                                  1.22   data required time
                                 -1.56   data arrival time
-----------------------------------------------------------------------------
                                  0.34   slack (MET)


Startpoint: _38618_ (rising edge-triggered flip-flop clocked by clk)
Endpoint: _38545_ (rising edge-triggered flip-flop clocked by clk)
Path Group: clk
Path Type: max

Fanout     Cap    Slew   Delay    Time   Description
-----------------------------------------------------------------------------
                          0.00    0.00   clock clk (rise edge)
                          0.00    0.00   clock source latency
                  0.00    0.00    0.00 ^ clk (in)
     1    0.01                           clk (net)
                  0.00    0.00    0.00 ^ clkbuf_0_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.03    0.09    0.09 ^ clkbuf_0_clk/X (sky130_fd_sc_hd__clkbuf_16)
     2    0.00                           clknet_0_clk (net)
                  0.03    0.00    0.09 ^ clkbuf_1_0_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.10    0.20 ^ clkbuf_1_0_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     1    0.00                           clknet_1_0_0_clk (net)
                  0.03    0.00    0.20 ^ clkbuf_1_0_1_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11    0.31 ^ clkbuf_1_0_1_clk/X (sky130_fd_sc_hd__clkbuf_4)
     2    0.00                           clknet_1_0_1_clk (net)
                  0.03    0.00    0.31 ^ clkbuf_2_1_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11    0.42 ^ clkbuf_2_1_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     1    0.00                           clknet_2_1_0_clk (net)
                  0.03    0.00    0.42 ^ clkbuf_2_1_1_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11    0.53 ^ clkbuf_2_1_1_clk/X (sky130_fd_sc_hd__clkbuf_4)
     2    0.00                           clknet_2_1_1_clk (net)
                  0.03    0.00    0.53 ^ clkbuf_3_3_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11    0.64 ^ clkbuf_3_3_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     2    0.00                           clknet_3_3_0_clk (net)
                  0.03    0.00    0.64 ^ clkbuf_4_6_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11    0.75 ^ clkbuf_4_6_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     2    0.00                           clknet_4_6_0_clk (net)
                  0.03    0.00    0.75 ^ clkbuf_5_12_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.17    0.22    0.98 ^ clkbuf_5_12_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     7    0.06                           clknet_5_12_0_clk (net)
                  0.17    0.00    0.98 ^ clkbuf_leaf_212_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.03    0.15    1.13 ^ clkbuf_leaf_212_clk/X (sky130_fd_sc_hd__clkbuf_16)
     2    0.00                           clknet_leaf_212_clk (net)
                  0.03    0.00    1.13 ^ _38618_/CLK (sky130_fd_sc_hd__dfxtp_4)
                  0.33    0.54    1.67 ^ _38618_/Q (sky130_fd_sc_hd__dfxtp_4)
    33    0.12                           latched_stalu (net)
                  0.33    0.00    1.67 ^ _36519_/S (sky130_fd_sc_hd__mux2_1)
                  0.06    0.37    2.04 v _36519_/X (sky130_fd_sc_hd__mux2_1)
     2    0.00                           _00293_ (net)
                  0.06    0.00    2.04 v _36518_/A1 (sky130_fd_sc_hd__mux2_1)
                  0.05    0.28    2.32 v _36518_/X (sky130_fd_sc_hd__mux2_1)
     1    0.00                           _00294_ (net)
                  0.05    0.00    2.32 v _22741_/B (sky130_fd_sc_hd__and2_1)
                  0.03    0.15    2.47 v _22741_/X (sky130_fd_sc_hd__and2_1)
     1    0.00                           _00295_ (net)
                  0.03    0.00    2.47 v _35809_/A0 (sky130_fd_sc_hd__mux2_2)
                  0.07    0.28    2.75 v _35809_/X (sky130_fd_sc_hd__mux2_2)
     4    0.01                           _02560_ (net)
                  0.07    0.00    2.75 v _23131_/A (sky130_fd_sc_hd__xnor2_1)
                  0.07    0.15    2.89 v _23131_/Y (sky130_fd_sc_hd__xnor2_1)
     2    0.01                           _18154_ (net)
                  0.07    0.00    2.89 v _23136_/A_N (sky130_fd_sc_hd__nand3b_2)
                  0.07    0.21    3.10 v _23136_/Y (sky130_fd_sc_hd__nand3b_2)
     2    0.00                           _18156_ (net)
                  0.07    0.00    3.10 v _23143_/A2_N (sky130_fd_sc_hd__o2bb2ai_1)
                  0.06    0.14    3.24 v _23143_/Y (sky130_fd_sc_hd__o2bb2ai_1)
     2    0.00                           _18161_ (net)
                  0.06    0.00    3.24 v _23151_/A2_N (sky130_fd_sc_hd__o2bb2ai_1)
                  0.05    0.13    3.37 v _23151_/Y (sky130_fd_sc_hd__o2bb2ai_1)
     1    0.00                           _18167_ (net)
                  0.05    0.00    3.37 v _23152_/B1 (sky130_fd_sc_hd__o21ai_2)
                  0.12    0.07    3.44 ^ _23152_/Y (sky130_fd_sc_hd__o21ai_2)
     2    0.01                           _18168_ (net)
                  0.12    0.00    3.44 ^ _23159_/B1 (sky130_fd_sc_hd__o21ai_1)
                  0.06    0.09    3.53 v _23159_/Y (sky130_fd_sc_hd__o21ai_1)
     1    0.00                           _18173_ (net)
                  0.06    0.00    3.53 v _23160_/B1 (sky130_fd_sc_hd__o21ai_2)
                  0.13    0.07    3.60 ^ _23160_/Y (sky130_fd_sc_hd__o21ai_2)
     2    0.01                           _18174_ (net)
                  0.13    0.00    3.60 ^ _23167_/A1 (sky130_fd_sc_hd__a21o_1)
                  0.13    0.19    3.79 ^ _23167_/X (sky130_fd_sc_hd__a21o_1)
     2    0.01                           _18179_ (net)
                  0.13    0.00    3.79 ^ _23174_/A1 (sky130_fd_sc_hd__a21oi_4)
                  0.05    0.07    3.86 v _23174_/Y (sky130_fd_sc_hd__a21oi_4)
     2    0.01                           _18184_ (net)
                  0.05    0.00    3.86 v _23182_/A2 (sky130_fd_sc_hd__o21bai_2)
                  0.20    0.18    4.04 ^ _23182_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.01                           _18190_ (net)
                  0.20    0.00    4.04 ^ _23189_/A1 (sky130_fd_sc_hd__a21oi_4)
                  0.06    0.08    4.12 v _23189_/Y (sky130_fd_sc_hd__a21oi_4)
     2    0.01                           _18195_ (net)
                  0.06    0.00    4.12 v _23196_/A2 (sky130_fd_sc_hd__o21bai_2)
                  0.15    0.15    4.27 ^ _23196_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.01                           _18200_ (net)
                  0.15    0.00    4.27 ^ _23202_/A1 (sky130_fd_sc_hd__a21oi_2)
                  0.06    0.09    4.36 v _23202_/Y (sky130_fd_sc_hd__a21oi_2)
     2    0.01                           _18204_ (net)
                  0.06    0.00    4.36 v _23208_/A2 (sky130_fd_sc_hd__o21bai_2)
                  0.20    0.19    4.54 ^ _23208_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.01                           _18208_ (net)
                  0.20    0.00    4.54 ^ _23214_/A1 (sky130_fd_sc_hd__a21oi_4)
                  0.06    0.08    4.63 v _23214_/Y (sky130_fd_sc_hd__a21oi_4)
     2    0.01                           _18212_ (net)
                  0.06    0.00    4.63 v _23220_/A2 (sky130_fd_sc_hd__o21bai_2)
                  0.20    0.18    4.81 ^ _23220_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.01                           _18216_ (net)
                  0.20    0.00    4.81 ^ _23226_/A1 (sky130_fd_sc_hd__a21oi_4)
                  0.06    0.08    4.89 v _23226_/Y (sky130_fd_sc_hd__a21oi_4)
     2    0.01                           _18220_ (net)
                  0.06    0.00    4.89 v _23232_/A2 (sky130_fd_sc_hd__o21bai_2)
                  0.15    0.15    5.04 ^ _23232_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.01                           _18224_ (net)
                  0.15    0.00    5.04 ^ _23238_/A1 (sky130_fd_sc_hd__a21oi_2)
                  0.06    0.09    5.13 v _23238_/Y (sky130_fd_sc_hd__a21oi_2)
     2    0.01                           _18228_ (net)
                  0.06    0.00    5.13 v _23245_/A2 (sky130_fd_sc_hd__o21bai_2)
                  0.20    0.19    5.32 ^ _23245_/Y (sky130_fd_sc_hd__o21bai_2)
     2    0.01                           _18233_ (net)
                  0.20    0.00    5.32 ^ _23251_/A1 (sky130_fd_sc_hd__a21oi_4)
                  0.07    0.09    5.41 v _23251_/Y (sky130_fd_sc_hd__a21oi_4)
     2    0.01                           _18237_ (net)
                  0.07    0.00    5.41 v _23258_/A2 (sky130_fd_sc_hd__o21bai_4)
                  0.16    0.16    5.57 ^ _23258_/Y (sky130_fd_sc_hd__o21bai_4)
     3    0.02                           _18242_ (net)
                  0.16    0.00    5.57 ^ _23268_/A (sky130_fd_sc_hd__nand3_4)
                  0.08    0.10    5.66 v _23268_/Y (sky130_fd_sc_hd__nand3_4)
     3    0.01                           _18248_ (net)
                  0.08    0.00    5.66 v _23284_/A2 (sky130_fd_sc_hd__o211ai_4)
                  0.20    0.21    5.87 ^ _23284_/Y (sky130_fd_sc_hd__o211ai_4)
     3    0.02                           _18260_ (net)
                  0.20    0.00    5.87 ^ _23294_/A (sky130_fd_sc_hd__nand3_4)
                  0.09    0.10    5.98 v _23294_/Y (sky130_fd_sc_hd__nand3_4)
     3    0.01                           _18266_ (net)
                  0.09    0.00    5.98 v _23310_/A2 (sky130_fd_sc_hd__o211ai_4)
                  0.16    0.18    6.16 ^ _23310_/Y (sky130_fd_sc_hd__o211ai_4)
     3    0.01                           _18278_ (net)
                  0.16    0.00    6.16 ^ _23315_/A (sky130_fd_sc_hd__nand2_1)
                  0.05    0.06    6.23 v _23315_/Y (sky130_fd_sc_hd__nand2_1)
     1    0.00                           _18281_ (net)
                  0.05    0.00    6.23 v _23318_/A (sky130_fd_sc_hd__nand2_1)
                  0.06    0.07    6.29 ^ _23318_/Y (sky130_fd_sc_hd__nand2_1)
     1    0.00                           _18284_ (net)
                  0.06    0.00    6.29 ^ _23319_/B (sky130_fd_sc_hd__xor2_1)
                  0.05    0.05    6.35 v _23319_/X (sky130_fd_sc_hd__xor2_1)
     1    0.00                           _01676_ (net)
                  0.05    0.00    6.35 v _36534_/A1 (sky130_fd_sc_hd__mux2_1)
                  0.05    0.27    6.62 v _36534_/X (sky130_fd_sc_hd__mux2_1)
     1    0.00                           _01677_ (net)
                  0.05    0.00    6.62 v _36988_/A1 (sky130_fd_sc_hd__mux4_1)
                  0.08    0.48    7.10 v _36988_/X (sky130_fd_sc_hd__mux4_1)
     1    0.00                           _01678_ (net)
                  0.08    0.00    7.10 v _36535_/A0 (sky130_fd_sc_hd__mux2_1)
                  0.05    0.28    7.37 v _36535_/X (sky130_fd_sc_hd__mux2_1)
     1    0.00                           _02529_ (net)
                  0.05    0.00    7.37 v _18990_/A (sky130_fd_sc_hd__or2b_1)
                  0.04    0.21    7.59 v _18990_/X (sky130_fd_sc_hd__or2b_1)
     1    0.00                           _16178_ (net)
                  0.04    0.00    7.59 v _18991_/C1 (sky130_fd_sc_hd__o211a_1)
                  0.03    0.10    7.68 v _18991_/X (sky130_fd_sc_hd__o211a_1)
     1    0.00                           _03989_ (net)
                  0.03    0.00    7.68 v _38545_/D (sky130_fd_sc_hd__dfxtp_1)
                                  7.68   data arrival time

                         12.00   12.00   clock clk (rise edge)
                          0.00   12.00   clock source latency
                  0.00    0.00   12.00 ^ clk (in)
     1    0.01                           clk (net)
                  0.00    0.00   12.00 ^ clkbuf_0_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.03    0.09   12.09 ^ clkbuf_0_clk/X (sky130_fd_sc_hd__clkbuf_16)
     2    0.00                           clknet_0_clk (net)
                  0.03    0.00   12.09 ^ clkbuf_1_1_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.10   12.20 ^ clkbuf_1_1_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     1    0.00                           clknet_1_1_0_clk (net)
                  0.03    0.00   12.20 ^ clkbuf_1_1_1_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11   12.31 ^ clkbuf_1_1_1_clk/X (sky130_fd_sc_hd__clkbuf_4)
     2    0.00                           clknet_1_1_1_clk (net)
                  0.03    0.00   12.31 ^ clkbuf_2_2_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11   12.42 ^ clkbuf_2_2_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     1    0.00                           clknet_2_2_0_clk (net)
                  0.03    0.00   12.42 ^ clkbuf_2_2_1_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11   12.53 ^ clkbuf_2_2_1_clk/X (sky130_fd_sc_hd__clkbuf_4)
     2    0.00                           clknet_2_2_1_clk (net)
                  0.03    0.00   12.53 ^ clkbuf_3_4_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11   12.64 ^ clkbuf_3_4_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     2    0.00                           clknet_3_4_0_clk (net)
                  0.03    0.00   12.64 ^ clkbuf_4_8_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.03    0.11   12.75 ^ clkbuf_4_8_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     2    0.00                           clknet_4_8_0_clk (net)
                  0.03    0.00   12.75 ^ clkbuf_5_17_0_clk/A (sky130_fd_sc_hd__clkbuf_4)
                  0.13    0.19   12.95 ^ clkbuf_5_17_0_clk/X (sky130_fd_sc_hd__clkbuf_4)
     5    0.04                           clknet_5_17_0_clk (net)
                  0.13    0.00   12.95 ^ clkbuf_leaf_182_clk/A (sky130_fd_sc_hd__clkbuf_16)
                  0.03    0.15   13.09 ^ clkbuf_leaf_182_clk/X (sky130_fd_sc_hd__clkbuf_16)
     5    0.01                           clknet_leaf_182_clk (net)
                  0.03    0.00   13.09 ^ _38545_/CLK (sky130_fd_sc_hd__dfxtp_1)
                          0.00   13.09   clock reconvergence pessimism
                         -0.11   12.98   library setup time
                                 12.98   data required time
-----------------------------------------------------------------------------
                                 12.98   data required time
                                 -7.68   data arrival time
-----------------------------------------------------------------------------
                                  5.30   slack (MET)

```


```
report_clock_skew -hold
report_clock_skew -setup
set ::env(CTS_CLK_BUFFER_LIST) [linsert $::env(CTS_CLK_BUFFER_LIST) 0 sky130_fd_sc_hd__clkbuf_1]      (Adding back clkbuf1)
```

<img width="820" alt="435B0EB3-CDB0-4F50-B29E-805DD63628C8" src="https://github.com/Avi991/Samsung-PD-training-/assets/142480104/59786300-ef43-48c3-9664-780e30494e15">

</details>

</details>



# Day-19 Final Step RTL to GDSII
<details>
 <summary>Introduction to maze Routing use Lee's Algorithm</summary>

 **Routing** 

 Routing refers to the process of connecting various components, such as transistors, logic gates, and other electronic elements, on an integrated circuit (IC) using a network of interconnected wires or metal layers. Efficient and 
 optimized routing is crucial for the performance and functionality of VLSI chips. There are two main types of routing in VLSI: global routing and detailed routing.

 **Maze Routing Lee's Algorithm**

 The Lee algorithm, also known as the Lee-Moore algorithm, is a pathfinding or maze routing algorithm used in computer science, particularly in VLSI design and printed circuit board (PCB) design. Its primary purpose is to find the 
 shortest path between two points on a grid or maze, considering obstacles or blocked areas. It is a breadth-first search (BFS) algorithm and is often used in detailed routing stages of VLSI design.

 The steps in Lee Algorithm

 *Initialization* :

 - Create a grid or maze where each cell can be either empty (open) or blocked.
 - Mark the starting point as the source cell and the destination point as the target cell.
 - Initialize a queue data structure to manage the cells to be explored.

 *Breadth-First Search* :

 - Begin with the source cell and enqueue it in the queue.
 - Set its distance or step count as 0.
 - Start a loop until the queue is empty.
 - For each cell in the queue
 - Explore the neighboring cells (up, down, left, right) that are not blocked and have not been visited. If a neighboring cell is not visited, mark it as visited, enqueue it, and set its distance or step count as the distance of the 
   current cell plus one. Continue this process until the destination cell is reached or until there are no more cells to explore.

*Backtracking* :

 - Once the destination cell is reached, the algorithm can backtrack from the destination to the source by examining the neighboring cells and choosing the one with a lower distance value at each step. This retraces the shortest path 
   from the destination to the source.

*Path Construction*:

- After backtracking, the path from the source to the destination is reconstructed, and the shortest route is found.
- The Lee algorithm is especially useful in detailed routing for VLSI design because it helps find the shortest path while taking into account the grid structure and obstacles. It is an efficient way to navigate around obstacles, 
  avoid congestion, and connect various components on an integrated circuit

 

One of the key advantages of the Lee algorithm is its ability to guarantee that the shortest path is found. However, it may require a significant amount of memory and can be computationally intensive for large grids or mazes. There are variations and optimizations of the Lee algorithm to address these limitations, such as bidirectional Lee algorithm, A* algorithm, and hierarchical versions for PCB routing.

</details>

<details>

 <summary>Design Rule Checks</summary>

 - Design Rule Checks (DRC) are a crucial part of the integrated circuit (IC) design and manufacturing process, especially in VLSI (Very Large Scale Integration) design.
 - DRC is a set of guidelines and checks used to ensure that the layout of an IC adheres to manufacturing and design rules. These rules are essential to guarantee that the IC can be manufactured successfully and will function as 
   intended.

 - Some of the Design Rule checks are as shown in the figure

 - One of the violation is a signal short, where two wires that are not intended to be connected becomes in contact on the same layer.

 - This could lead to functional failure, so this needs to be taken care of.

 - To fix this, we need to simply moving one of the wires onto a different metal layer.

 - However, please keep in mind that there are new drc rules that need to be taken into account.

 - Performing parasitic extraction, where the resistances and capacitances of the wires are extracted and will be used for further processes.

</details>

<details>

 <summary>Labs</summary>
 Starting Openlane again
ls -ltr
./flow.tcl -interactive
package require openlane 0.9
prep -design picorv32a -tag 13-01_14-09
```

In openlane 
```ruby
echo $::env(CURRENT_DEF)    (Ensure current_def is on the CTS stage)
gen_pdn                     (To generate power distribution network)
```
We get the error
file:///home/aviral.s/day%2019/1_gen_pdn.png
file:///home/aviral.s/day%2019/gen_pdn_error_2.png

**Basics of global and detail routing and configure TritonRoute**

Routing, in the context of electronic design and integrated circuits, refers to the process of determining the physical paths or connections for electrical signals on a chip or a printed circuit board (PCB). It involves deciding how wires, traces, or interconnects should be laid out to ensure that signals can travel from their source to their destination while meeting various design constraints, such as timing, area constraints, and avoiding interference.

**Global and detailed routing are two phases within the routing process:**

**Global Routing:**

- Global routing is the initial phase in the routing process, where the overall path for connections is established at a high level.<br>
- It focuses on determining the general path and direction of wires or signal paths while taking into account high-level design constraints.<br>
- At this stage, specific paths for each wire or signal are not yet defined in detail. Instead, it involves creating a rough plan for how wires should traverse the chip or PCB to connect various components.<br>
- Global routing helps define the general topology of the interconnections and ensures that there are no major conflicts or congestion issues in the design.<br><br>

**Detailed Routing:**

- Detailed routing, also known as track assignment or channel routing, is the subsequent phase that follows global routing.<br>
- In this phase, the exact paths for each wire or signal are defined in detail. This includes determining the specific locations of vias, routing layers, and obstacles that may be encountered
- Detailed routing takes into consideration the intricacies of the design, adheres to design rules, and aims to optimize the routing for various objectives such as minimizing wirelength, reducing crosstalk, and avoiding congestion

```ruby
echo $::env(CURRENT_DEF)            (Ensure the def file of pdn has been created)
echo $::env(ROUTING_STRATEGY)
set ::env(CURRENT_DEF) <path_of_cts.def>
run_routing
```
when we run the command *run_routing* we get

file:///home/aviral.s/day%2019/run_routing.png

</details>

## Day-20 Floorplanning and power planning labs ##
<details>
 <summary>Theory</summary>
	The physical design flow in VLSI (Very Large Scale Integration) is a series of steps that transform a high-level hardware description of a digital circuit into a physical layout that can be fabricated as an integrated circuit (IC) on a semiconductor wafer. This flow involves several stages and a range of tools and methodologies. Here is an overview of the typical steps in the physical design flow:

1. Design Specification: This is the initial step where you gather requirements and specifications for the digital circuit. It includes understanding the functionality, power consumption, performance, area constraints, and other design goals.

2. RTL Design: Register Transfer Level (RTL) design involves creating a high-level representation of the digital circuit in a hardware description language (HDL) like VHDL or Verilog. The RTL description typically consists of flip-flops, registers, and the interconnections between them.

3. Logic Synthesis: This step involves converting the RTL description into a gate-level representation. Logic synthesis tools map the RTL to a library of standard cells, optimizing for area, power, and speed while meeting the design constraints.

4. Floor Planning: In this phase, you decide on the placement of different functional blocks and macros on the chip. It involves defining the size and location of each block to optimize for area, power, and signal routing.

5. Power Planning: Power distribution networks are designed to ensure that all parts of the chip receive a stable and adequate power supply. This includes the design of power grids and voltage regulation circuits.

6. Placement: The placement stage determines the physical locations of each standard cell on the chip. Tools aim to minimize wirelength, optimize for timing, and meet other design constraints.

7. Clock Tree Synthesis (CTS): CTS is the process of designing a clock distribution network to ensure that clock signals reach all the flip-flops and latches with minimal skew and low power consumption.

8. Routing: The routing step involves creating the physical wires (metal layers) that connect the gates, ensuring that all connections meet design requirements and constraints. Global and detailed routing are usually performed.

9. Design for Manufacturing (DFM): DFM considerations address manufacturability issues like lithography, etching, and other process-related aspects to ensure the chip can be manufactured with high yield.

10. Design Verification: Extensive verification is carried out at each stage of the physical design flow to ensure that the final layout adheres to the original design specifications and that it is free from logical and physical errors.

11. Physical Verification: This involves checking the design against manufacturing rules, including design rule checking (DRC) and layout vs. schematic (LVS) checks.

12. Extraction: Parasitic capacitances and resistances are extracted from the layout and included in the simulation models to accurately predict circuit behavior.

13. Sign-off: This is the final review and approval stage before tape-out, where the design is deemed ready for fabrication.

14. Tape-out: Once the design is thoroughly reviewed, validated, and optimized, it is sent for semiconductor fabrication. A set of files representing the design layout is created and submitted to the foundry.

15. Post-Tapeout Tasks: After fabrication, there may be additional tasks such as package design, testing, and assembly before the final IC is ready for use.

The physical design flow in VLSI is a complex and iterative process that requires careful planning and the use of various EDA (Electronic Design Automation) tools. Success in physical design depends on meeting the design goals and constraints while optimizing for power, area, and performance.
</details>

<details>
 <summary>Labs</summary>
	
```ruby
git clone https://github.com/manili/VSDBabySoC.git
git clone https://github.com/Devipriya1921/VSDBabySoC_ICC2.git
git clone https://github.com/bharath19-gs/synopsys_ICC2flow_130nm.git
git clone https://github.com/kunalg123/icc2_workshop_collaterals.git
git clone https://github.com/google/skywater-pdk-libs-sky130_fd_sc_hd.git
git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git
```

 ```ruby
gvim vsdbabysoc.tcl &
gvim avsdpll.lib &
```

**vsdbabysoc.tcl**
- Modifying the contents to my path, remove -lib in read_lib commands, and replace MYCLK to clk since the clock used in the design is {clk}
- All of the commands have been inserted in gvim and the tool will run it once at a time.
   
  
  
 
```ruby
dc_shell
source vsdbabysoc.tcl
```
**Reports**

Report timing image is shown below.
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/67f12349-83d7-4173-89c1-9d716cc62e7f)

Report area image is shown below.
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/de033caa-df7c-4d86-b9ed-f795a5541921)

Report power image is shown below.
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/a20bb18f-3067-4f63-a471-5e582dca6cba)

**Output schematic**
file:///home/aviral.s/Desktop/Day20/schematic.png![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/298572ef-2cd5-4a39-8148-c71c440a9437)

**RVMYTH core**
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/7f32956f-c1a5-4b3c-a141-78cfa23b3061)


***Performing physical design***

```ruby
gvim top.tcl
gvim icc2_common_setup.tcl
gvim icc2_dp_setup.tcl
gvim init_design.read_parasitic_tech_example.tcl
gvim init_design.mcmm_example.auto_expanded.tcl
gvim pns_example.tcl
```
**Modified files**

1. top.tcl
   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/72ef5347-759a-4caa-a039-639fc203c08a)

2. icc2_common_setup.tcl
   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/b020db7c-3da6-434a-8646-4712ff8f45ea)

3. init_design.read_parasitic_tech_example.tcl
    ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/a8b49d87-818b-4b8d-8403-f27a87301727)

4. init_design.mcmm_example.auto_expanded.tcl
   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/19867c74-7f0c-4a18-b908-105ec7f49e22)
   
5. pns_example.tcl
   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/840567bf-f6de-4118-9233-9946fd57fd38)

**Observing for 40% of utilization**

***Output Layout***
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/7a4fbfb2-6c94-40ab-97d4-044362d8ae20)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/03a877e7-647c-47c6-a11a-0383cabeac4e)

```ruby
source top.tcl
```
Below screenshot displays the timing report showing slack = -2.72
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/50408935-ce66-4062-b4c1-8469236e8b27)

In icc2_shell

```ruby
set_propagated_clock [all_clocks]             (Converting clock object from ideal clock to propagated clock)
report_timing
```

**violators.rpt**
```ruby
gvim violators.rpt	     (Reviewing violations report within the design)
```
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/70d4408b-b50f-4421-8edb-afec779c7541)

**Observing for 50% of utilization**

*Slacks*

In icc2_shell

```ruby
set_propagated_clock [all_clocks]             (Converting clock object from ideal clock to propagated clock)
report_timing
```

Here observe that slack is getting increased.
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/5d72ce84-5942-4543-92d7-48c11254157e)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/b1468d4e-f906-45ac-a06d-2d5ac39c707a)

Here we can observe that slack is getting increased when core utilization is increased from 40% to 50%.
</details>

## Day-21 Placement CTS Routing
<details>
<summary>Theory</summary>

 - **Placement** : It refers to the process of determining the physical locations of various electronic components on an integrated circuit (IC) design. This 
 step is crucial in the overall IC design process, as it affects the final performance, power consumption, and manufacturability of the chip.The primary 
 objective of placement is to assign a physical position to each logic gate, flip-flop, or other components on the chip. The goal is to minimize wirelength, 
 reduce congestion, and optimize for factors like signal delay and power consumption.
 - **Routing** : Routing in VLSI (Very Large Scale Integration) design is the process of connecting the various components (logic gates, flip-flops, etc.) 
 placed on an integrated circuit (IC) with wires, also known as interconnects.The primary objective of routing is to create an efficient and reliable network of 
 interconnections between the components placed on the chip. This network must meet timing constraints, minimize wirelength, and avoid congestion.
 - **Clock Tree Synthesis** : Clock Tree Synthesis (CTS) is a crucial step in the design of digital integrated circuits, especially those with synchronous 
 logic, such as microprocessors and application-specific integrated circuits (ASICs). The primary purpose of CTS is to create a well-organized and optimized 
 distribution network for clock signals, ensuring that all sequential elements (like flip-flops) receive clock signals with minimum skew, low latency, and low 
 power consumption.
   
</details>
<Details>

 <summary>Labs</summary>

 - Analysing the ICC2_run at core utilization of 40%

 - In top.tcl we can see that
   
 	- create_placement is used to create placement for the design. floorplan option is selected to make the design planning styled as placement.
           ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/90c5857c-88b6-4788-88cb-f2ec11f3ccc4)    

 - **Reports generated from the run**

 	- check_design.pre_pin_placement

	![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/b09c3de3-081e-440c-a192-2f45c859c861)


 	- report_port_placement.rpt

        ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/15c634b7-1646-4085-8d52-2fc15d8d40df)



    **icc2_output.txt**

   - vsdbabysoc.post_estimated_timing.rpt

         ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/7b379a2e-e03f-4f11-a5b4-a0dec1b3c30c)


    - vsdbabysoc.post_estimated_timing.qor

         ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/b9cc1c58-53f5-4064-b12e-ffb7b3ee7e48)

  		
   - vsdbabysoc.post_estimated_timing.qor.sum
   - 
        ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/18f3a312-ddd1-4e8f-81d6-8fb0faf59c46)


    - Clock Tree Analysis

      GUI opens we need to go to window sections and in that we need to select clock tree synthesis analyser
 
    - PLL schematic with FANOUT

	![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/34ca2708-8a4d-445e-a5cf-7d64df5c24aa)

      </Details>


## Day 22 CTS Analysis

<details>

 <summary>Clock tree synthesis</summary>

 - Clock Tree Synthesis involves the generation of a clock distribution network that ensures a stable and synchronized clock signal throughout the entire chip or circuit.
 - CTS is performed for several importnant reasons :
   
   1.Synchronization: In digital circuits, synchronous operations are critical. A clock signal is used to coordinate the activities of various elements within the circuit, ensuring they work together harmoniously. CTS is done to 	 
     distribute this clock signal uniformly to all parts of the chip so that all operations occur in sync.

   2.Minimizing Clock Skew: Clock skew refers to the variation in arrival times of the clock signal at different parts of the chip. Excessive clock skew can lead to timing violations and impact the overall performance and reliability 
     of the circuit. CTS is employed to minimize clock skew, ensuring that the clock signal arrives at all elements at nearly the same time.

   3.Timing Closure: Achieving timing closure is a crucial objective in chip design. CTS helps in meeting timing constraints by distributing the clock signal efficiently. When the clock signal reaches all elements simultaneously, it 
     becomes easier to manage and control the timing of the circuit.

   4.Power Efficiency: CTS can be used to design a power-efficient clock distribution network. By strategically placing buffers and repeaters and optimizing clock tree topology, designers can minimize power consumption in the clock 
    distribution network, which is especially important in portable and battery-powered devices.

- Various Algorithms used for CTS

    H-Tree

   ```
   check_clock_tree
   ```
  ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/81fa23ca-67ab-461c-82dc-f550366d7523)

  <img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/caeb6e740b34772676d9e659f4be3df798637f47/day23/db%20AFTER%20OPTIMIZATION1.png">

 When we man CTS-904 
 
 ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/dfca9aea-8012-4712-b8fd-d281340076cb)
LEQ cells are absent for resizing. LEQ cells  are level Equivalence cells which are used to create logic gates or elements that have equivalent feature of different complexity. As a result the sizes of the cells can be easily resized by using a cell of differnt complexity.
 
 When we man CTS-019
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/2d5c522e-d329-47e8-a35b-63c6a899f80c)
It gives the info about mone than one clock can be propagated to output ports ,As default CTS behaviour is dependent on the constraint on the the output port as well

CTS-015 : It is a warning which comes up when we set_max_delay  or  set_min_delay  constraints are defined in the clock network.

Command used to see the clock buffers such that that efficient CTS could take palce 
  ```
set_lib_cell_purpose -include cts {sky130_fd_sc_hd_tt_025C_1V80/sky130_fd_sc_hd__clkbuf*}
synthesize_clock_tree
clock_opt
set_propagated_clock [all_clocks]
```

  2. **Clockwise multi-source clock tree synthesis (CTS) algorithm** : It is a specific approach to designing and optimizing the clock distribution network in digital integrated circuits. In this algorithm, multiple clock sources are considered, and the clock tree is designed to distribute clock signals from these sources in a clockwise direction.
 
 
  Steps:

  - Identify and specify the multiple clock sources in the design. These sources may be associated with different clock domains or regions of the chip.
  - Create a clock tree topology that outlines the placement of buffers and repeaters, the routing of clock lines, and the interconnection of clock network 
     elements. In a multi-source CTS, the tree should be designed to distribute clock signals from all selected sources.
  - Determine the type and sizes of buffers to be used in the clock tree. Sizing is crucial for optimizing power consumption, signal integrity, and clock skew. 
     Consider the characteristics of each clock source when sizing buffers.
  - Physically lay out the clock distribution network, including the placement of buffers and the routing of clock lines. Ensure that the routing accommodates 
     the distribution of clock signals from multiple sources in a clockwise manner
  - Implement clock gating cells as needed to selectively enable or disable clock signals to specific circuit portions when they are not in use. Ensure that 
    clock signals are synchronized as they traverse the clock tree.
  - Ensure that the clock tree meets timing constraints, such as setup and hold times, for all flip-flops and other clocked elements in the design. Adjust 
    buffer sizes and placement as necessary to achieve timing closure.
  - After synthesizing the clock tree, perform thorough verification, including simulations and static timing analysis, to ensure that the design requirements 
    are met and that clock signals are properly distributed from all sources. t's common to go through several iterations of clock tree synthesis to achieve the 
    desired performance, power efficiency, and timing closure. Fine-tune the clock tree as necessary based on the results of analysis and simulation.
</details>

<details>

 <summary>Labs</summary>
**Various CTS checks Performed**

 - Skew check
 - Pulse width check
 - Legality check
 - Delta Delay Quality check
 - Glitch Quality check Latency check

```
check_legality
```
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/3ab92892-2862-4afe-89ad-c7173eaa13d4)

```
report_clock_timing -type latency
```
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/ba387322-3571-441d-8211-370de9d293e7)

```
report_clock_timing -type skew
```
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/8657bb6b-df30-462f-90d9-b9c774ef9700)


```
report_clock_timing -type transition
```
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/1fe64294-0e02-414a-8561-aeb7b3be15be)


```
report_clock_timing -type summary
```
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/270c05fe-3294-49d7-97b2-c88a5161576c)

Here from the summary report of timing we explored some useful acronyms to analyze the the report properly
```
It gave two skew hold and setup , hold and setup latency, transistion values
rp-+ -> rising transition of propagated clock in the clock pin from launch to capture.

r --> Rising transition

f-->  Falling transition

p-->  Propagated clock to this pin

[ - ]    Launching transition

[ + ]    Capturing transition   
```
</details>
</details>

## Day-23 Clock gating technique

<details>
  <summary>Theory</summary>
  
**Advanced H-Tree for million flop clock end-points randomly placed**
  
 When CTS is performed, power consumption also needs to be taken care of, especially when designing a large number of clocks where the design might induce a larger power, as well as a larger power usage .A digital circuit with a lot of clocks would   be so huge with many buffers etc when designing its clock tree

In order to fix that, the whole chip is sectioned into smaller versions where each section will have its own clock tree, and managed to get a complete routed tree .Therefore, **Clock Gating (CG)** technique is introduced

**Basic Principle:**
Integrated Clock Gating is based on the fundamental concept that many digital circuits only need the clock signal when they are actively performing computations or when data needs to be transferred. When a circuit is idle, clocking its components consumes power unnecessarily. By selectively disabling the clock to idle components, you can significantly reduce power consumption.

### Introduction to Clock Gating technique
  
**What is Clock Gating (CG)?**
  
It is used to reduce the clock power consumption by cutting off the idle clock cycles

  
**Where/when clock gating is applied?**
  
It is being inserted in synthesis stage and being optimized in the implementation stage (Physical Design stage)
  
**Types of clock gating**

 There are two primary types of clock gating techniques:

   a. **Static Clock Gating:** In this approach, the clock gating conditions are determined during design time, and the gating logic remains fixed. This method is suitable for circuits with predictable and static gating conditions.

   b. **Dynamic Clock Gating:** Here, the gating conditions can change dynamically during the operation of the circuit. This approach is more versatile and is often used in complex designs with variable clock 

**Techniques**
* AND gate
* OR gate
* Universal AND gate
  
### Routing
    
The process of making physical connections between signal pins using metal layers
  
**Types of routing**
  
* P/G routing
* Clock routing
* Signal routing: Global & Detailed routing
  
**Basic flow of routing**
  
 Basically, **route_opt** command is used during routing stage
  
 **clock_opt** is used to synthesize and route the clocks, and then further optimize the design based on the propagated clock latencies

 **route_auto** is used to run global routing, trace assignment, and detailed routing at once/automatically

</details>

<details>
  <summary>Lab</summary>
 
### Routing 
  
**Script in routing stage**
  
*  P/G routing  
  
```
pns_example.tcl
```
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/62e2d171d3183a8fe3995f5b0af1142de7043e95/day23/pns_ex.png">
https://github.com/Avi991/Samsung-PD-training-/blob/62e2d171d3183a8fe3995f5b0af1142de7043e95/day23/pns_ex.png
```
modyfying top.tcl
```
we need to Update the top.tcl as shown below

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/caeb6e740b34772676d9e659f4be3df798637f47/day23/top.tcl%20.png">

```
place_opt
```
**set_lib_cell_purpose -include cts{sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__buf_*}**
With this we specify the library cells in the  tech_lib library(sky130_fd_sc_hd__tt_025C_1v80)  whose names start with "buf" should be used for clock tree synthesis.

**synthesize_clock_tree**
It synthesizes clock trees and updates  the  design  database with  the  compiled  clock  trees also the compilation of the clock tree is skew driven.

**set_propagated_clock[all_clocks]**

It Specifies that delays be propagated through the clock network to determine latency at register clock pins.

clock_opt

route_opt
```
We need to update the mcmm file to the 1.8 volts as the skywater 130 is meant to work for 1.8 volts

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/62e2d171d3183a8fe3995f5b0af1142de7043e95/mcmm.png">

Below shows the image of the Clock tree getting built with appropriate buffers used 
The clock buffers and ICG inserted in the circuit are as follows

```ruby

Buffer/Inverter reference list for clock tree synthesis:
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__buf_1
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__buf_12
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__buf_16
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__buf_2
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__buf_4
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__buf_6
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__buf_8
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__bufbuf_16
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__bufbuf_8
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkbuf_1
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkbuf_16
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkbuf_2
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkbuf_4
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkbuf_8
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkdlybuf4s15_1
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkdlybuf4s15_2
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkdlybuf4s18_1
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkdlybuf4s18_2
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkdlybuf4s50_1
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkdlybuf4s50_2
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlygate4sd1_1
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlygate4sd2_1
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__probe_p_8
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__probec_p_8
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__lpflow_clkbufkapwr_1
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__lpflow_clkbufkapwr_2
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__lpflow_clkbufkapwr_4
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__lpflow_clkbufkapwr_8
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__bufinv_16
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__bufinv_8
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkinv_1
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkinv_16
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkinv_2
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkinv_4
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkinv_8
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkinvlp_2
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__clkinvlp_4
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__inv_1
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__inv_12
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__inv_16
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__inv_2
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__inv_4
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__inv_6
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__inv_8
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__lpflow_clkinvkapwr_2
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__lpflow_clkinvkapwr_4
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__lpflow_clkinvkapwr_8

ICG reference list:
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlclkp_1
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlclkp_4
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdlclkp_1
   sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdlclkp_4
```
		
 
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/caeb6e740b34772676d9e659f4be3df798637f47/day23/db%20AFTER%20OPTIMIZATION1.png">

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/072b6ea3-b538-42ca-a389-df876cfe340a)


**TIMING REPPORT BEFORE AND AFTER OPTIMIZATION**
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/62e2d171d3183a8fe3995f5b0af1142de7043e95/day23/global%20time.png">

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/62e2d171d3183a8fe3995f5b0af1142de7043e95/day23/TIMING%20AFTER%20OPTIMIZATION.png">


</details>
