# Samsung-PD-training-
## Day-0-Installation

 <details>
 <summary> ICC2 </summary>

It appears that "icc2 compiler" might refer to an abbreviation of "Intel C++ Compiler 2," which would be the second version of Intel's C++ compiler. Intel's C++ Compiler is a tool used to compile C and C++ programs, optimizing them for Intel processors and architectures. It offers features like advanced vectorization, parallelization, and optimization techniques to enhance the performance of code on Intel-based systems.

I installed ICC2 using the following commands and Below is the screenshot showing sucessful launch:

<img width="1085" alt="ICC2" src="https://github.com/Avi991/Samsung-PD-training-/blob/cbd01432461cd5fbbf5f74a0625776a4dc6b082d/Samsung_PD_%23day0/icc2.png">
</details>
------------------------------

<details>
 <summary> lc_shell </summary>

LC_shell, also known as Design Compiler Graphical, is a part of the Synopsys suite of Electronic Design Automation (EDA) tools. It's used in the digital design flow for logic synthesis and optimization. Design Compiler Graphical is an advanced version of the original Design Compiler tool, providing additional features and a more user-friendly graphical interface.
I invoked lc_shell using the following commands and Below is the screenshot showing sucessful launch:

<img width="1085" alt="lc_shell" src="https://github.com/Avi991/Samsung-PD-training-/blob/cbd01432461cd5fbbf5f74a0625776a4dc6b082d/Samsung_PD_%23day0/lc.png">
</details>
-------------------------------
<details>
 <summary>dc_shell</summary>
Design Compiler is the command line interface of Synopsys synthesis tool. It includes innovative topographical technology that enables a predictable flow resulting in faster time to results.It is invoked using the command dc_shell    

Below is the screenshot showing the successful launch:

<img width="1085" alt="dc_shell" src="https://github.com/Avi991/Samsung-PD-training-/blob/857bc676cc691d6f1ca6e79cda309159fe38d58e/training_1/dc.png">
</details>

------------------------------

<details>
 <summary> pt_shell </summary>

"PrimeTime" is a widely used Electronic Design Automation (EDA) tool developed by Synopsys. It is used for static timing analysis, which is a crucial step in the digital design flow to ensure that the design meets its timing requirements. The "PrimeTime Shell" is the user interface through which engineers interact with the PrimeTime tool to perform timing analysis and optimization.
I invoked pt_shell using the following commands and Below is the screenshot showing sucessful launch:

<img width="1085" alt="pt_shell" src="https://github.com/Avi991/Samsung-PD-training-/blob/cbd01432461cd5fbbf5f74a0625776a4dc6b082d/Samsung_PD_%23day0/pt.png">
</details>



## Day-1-Introduction to Verilog RTL Design and Synthesis
<details>
 <summary> Introduction to RTL-Design, Test-bench, Simulators </summary>
-RTL Design : The RTL Design stands for Register Transfer Language. It sits between the high-level system specification and the lower-level gate-level implementation. This is a design abstraction which models the flow of digital signals between hardware registers, and the logical operations performed on those signals. RTL is preferred because it is easy to understand and implement compared to structural and behavioral models.

-HDL : A hardware description language (HDL) enables a precise, formal description of an electronic circuit that allows for the automated analysis and simulation of an electronic circuit.

-Simulator : Simulator is the tool used for checking adherence to the specification by simulating the design. iverilog is the tool used for RTL simulation. A simulator looks for change in the input signals and when no change in input, the output also doesn't change. It produces an output in the form of a .vcd file.

-Design : Design is the actual verilog code or set of Verilog codeswhich has the intended functionality to meet the required specifications. Design may have one or more primary inputs or primary outputs.  RTL design is the behavioral representation of the required specification.

<summary> Labs on examples of iverilog and gtkwave </summary>
We made a directory namely VLSI and inside that directory we cloned vsdflow and sky130RTLDesignAndSynthesisWorkshop repository. This repository consists of the required .lib files and verilog codes and its testbenches for practice.
I installed the needed tools and attached the required screenshots:

</details>

 
Below is the output wave form in gtkwave generated by performing a simulation of good_mux using iverilog.

The syntax of the code is: iverilog <RTL_code> <Its_Testbench>
 <details>
 <summary> GTK Wave </summary>

GTKWave is an open-source waveform viewer and analyzer primarily used in digital design and electronic design automation (EDA) workflows. It allows users to visualize and analyze the waveforms generated by digital simulations, making it a valuable tool for debugging and verifying digital designs.

I installed GTKwave using the following commands and Below is the screenshot showing sucessful launch:

<img width="1085" alt="GTKwave" src="https://github.com/Avi991/Samsung-PD-training-/blob/cbd01432461cd5fbbf5f74a0625776a4dc6b082d/Samsung_PD_%23day1/4.png">
</details>
<details>
 <summary> Yosys </summary>
Yosys is an open-source framework for Verilog RTL synthesis. RTL stands for Register Transfer Level, which is a high-level abstraction used to describe digital circuits at the level of registers and their interactions. Yosys is primarily used in the digital design and electronic design automation (EDA) community to convert RTL descriptions of digital circuits, written in languages like Verilog or SystemVerilog, into a netlist representation that can be further optimized, analyzed, and eventually implemented in hardware.

I installed Yosys using the following commands and Below is the screenshot showing sucessful launch:

<img width="1085" alt="yosys" src="https://github.com/Avi991/Samsung-PD-training-/blob/cbd01432461cd5fbbf5f74a0625776a4dc6b082d/Samsung_PD_%23day1/5.png">
</details>
<details>
<summary>Labs on Yosys </summary>
 We were given the overview of this tool and the basic files required to perform the experiment on 2:1 MUX. 
 
 **Procedure** : First we need to read the liberty file using the code
 
 **read_liberty -lib <path of the .lib>**
 
 Then we need read the RTL Design code

 **read_verilog <RTL_Design_file>**

 After this we need to perform synthesis 

 **synth -top <instance_name>**
 
 generating netlist

 **abc -liberty <.lib path>**
 
This Netlist can be viewed in the synthesized circuit form using the **show** command    

<img width="1085" alt="ckt" src="https://github.com/Avi991/Samsung-PD-training-/blob/d0c56f29c950594bf4d7302ad2fca09563c63e3c/Samsung_PD_%23day1/6.png">
<img width="1085" alt="ckt" src="https://github.com/Avi991/Samsung-PD-training-/blob/d0c56f29c950594bf4d7302ad2fca09563c63e3c/Samsung_PD_%23day1/7.png">
<img width="1085" alt="ckt" src="https://github.com/Avi991/Samsung-PD-training-/blob/d0c56f29c950594bf4d7302ad2fca09563c63e3c/Samsung_PD_%23day1/8.png">
<img width="1085" alt="ckt" src="https://github.com/Avi991/Samsung-PD-training-/blob/d0c56f29c950594bf4d7302ad2fca09563c63e3c/Samsung_PD_%23day1/9.png">
<img width="1085" alt="ckt" src="https://github.com/Avi991/Samsung-PD-training-/blob/d0c56f29c950594bf4d7302ad2fca09563c63e3c/Samsung_PD_%23day1/9a.png">

Simplified Netlist code 
<img width="1085" alt="netlist" src="https://github.com/Avi991/Samsung-PD-training-/blob/d0c56f29c950594bf4d7302ad2fca09563c63e3c/Samsung_PD_%23day1/9b.png">
</details>

## Day-2-Introduction to Timing libraries, Hierarchical vs flat synthesis, and flip flop coding
<details>
	
 <summary> Introduction to Timing Library File (.Lib),Hierarchical vs Flat Synthesis </summary>
 
Liberty File(.lib) contains all std cells used in IC design their specifications are stored in .lib file. Also, Liberty File(.lib) consists of ASCII representations of Timing, Area, and Power associated with the Standard cell. The Naming convention in the timing file follows technology node and PVT format (Process, Voltage, Temperature).The Standard library used in our case was sky130_fd_sc_hd_tt_025C_1v8, File description 130 depicts technology node 130nm process is typical(tt), temperature is 25C, and 1v8 represents the 1.8V Voltage .
Screenshot of a standard library file shown below: 
<img width="1085" alt="lib" src="https://github.com/Avi991/Samsung-PD-training-/blob/e80dfe2463278a272ef026609f0bf2b1e7826dc4/Samsung_PD_%23day2/2.png">
	
The Liberty File also consists of the technology used for standard cells as in the above example it is CMOS, it also specifies the delay model, unit of time, unit of voltage, unit of resistance, and many other units.
All the data i.e std cells delays, leakage power, capacitance is stored in form of lookup tables(LUTs). For each gate cell based on the number of inputs(N), there will be 2^N combinations, and for each combination leakage power, area, delay, and all related parameters are mentioned. 

The timing file consists of many different variations of the same gate cells. As we move toward faster cell (cell with higher drive strength) the area and power increases. In liberty file area, power, timing values are given for same cell of different drive strength and it also consist if the inform about leakage power of all the possible logic of different configration shown below.
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/e80dfe2463278a272ef026609f0bf2b1e7826dc4/Samsung_PD_%23day2/2.png">
</details>

<details>
 <summary> Hierarchical vs Flat synthesis in Yosys </summary>
Hierarchical synthesis : The basic flow of hierarchical design is Dividing a design into multiple blocks (i.e. sub-chips, sub-blocks, modules, hierarchical blocks, etc.) which can also be user defined. Hierarchial design has blocks, subblocks in an hierarchy.
In Yosys we have done synthesis of a multimodule combinational circuit which consists of two sub_modules one that of ** AND ** gate and other of ** OR ** gate. Below is the RTL Design code of multimodules is gvien below:
	<img width="1085" alt="lib" src="https://github.com/Avi991/Samsung-PD-training-/blob/e80dfe2463278a272ef026609f0bf2b1e7826dc4/Samsung_PD_%23day2/4.png">

We do synthesis in yosys it generates the following gate level netlist :

<img width="1085" alt="lib" src="https://github.com/Avi991/Samsung-PD-training-/blob/e80dfe2463278a272ef026609f0bf2b1e7826dc4/Samsung_PD_%23day2/5(synthesis).png">

The yosys considers the module hierarchy and does mapping according to the instantiation i.e by using sub blocks.The netlist code for hierarchical implementation of the multiple_modules.

<img width="1085" alt="lib" src="https://github.com/Avi991/Samsung-PD-training-/blob/e80dfe2463278a272ef026609f0bf2b1e7826dc4/Samsung_PD_%23day2/7(synthesisize%20hier).png">

In the netlist it can observed that separate modules namely sub_module1 sub_module2 are created  i.e submodules are getting instanstiated not the std cells present in library

<img width="1085" alt="lib" src="https://github.com/Avi991/Samsung-PD-training-/blob/e80dfe2463278a272ef026609f0bf2b1e7826dc4/Samsung_PD_%23day2/6(show%20hier).png">

Flat synthesis : In Flat synthesis the hierarchies the flattened out and every submodule is created using std cells. We apply flat synthesis on the same design mentioned above. The command used to perform Flat synthesis from yosys are as follows :

--- read_liberty -lib <path of the .lib>

--- read_verilog <RTL_file>

--- synth -top <instance_name>

--- abc -liberty <.lib_path>

--- flatten

--- write_verilog -noattr <.v_File_name>
The synthesized circuit for a flattened netlist is shown in the below: 
<img width="1085" alt="lib" src="https://github.com/Avi991/Samsung-PD-training-/blob/e80dfe2463278a272ef026609f0bf2b1e7826dc4/Samsung_PD_%23day2/8(synthesized%20op%20flat).png">
<img width="1085" alt="lib" src="https://github.com/Avi991/Samsung-PD-training-/blob/e80dfe2463278a272ef026609f0bf2b1e7826dc4/Samsung_PD_%23day2/9(show%20flat).png">
</details>

<details>
 <summary> Flip-flop Coding Styles </summary>
 Flip-flops :A flip-flop is a sequential digital electronic circuit having two stable states that can be used to store one bit of binary data. Flip-flops are the fundamental building blocks of all memory devices.

 The complexity of cobinational circuit increases the chance of glitch, hence FFs are used to avoid it and it stable output.

 Asynchronous Reset D Flop: 
 
 Here the output signal goes low when the reset signal is high , irrespective of the clock's edge(+ve,-ve edge ).
 RTL code of positive edge trigerred asynchronous reset D FF:
 ```
module dff_asyncres ( input clk ,  input async_reset , input d , output reg q );
	always @ (posedge clk , posedge async_reset)
	begin
		if(async_reset)
			q <= 1'b0;
		else	
			q <= d;
	end
endmodule
```
Its gtkwave :<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/b3717ddc1a24961d4e335d766f7df6fea792b6b1/Samsung_PD_%23day2/10(dff_async_gtk).png">
Its Yosys synthesised netlist:
<img width="1085" alt="lib1" src="https://github.com/Luffy-7744/Samsung-PD-Training-/blob/7b832441e73dd5c5bc078425a1f34ee4dea508fd/PD%23Day2/asyn_rst_synth.png">

Asynchronous set D Flop:

Here the output signal goes high when the reset signal is high , irrespective of the clock's edge(+ve,-ve edge ).
 RTL code of positive edge trigerred asynchronous set D FF:
 ```
module dff_async_set ( input clk ,  input async_set , input d , output reg q );
	always @ (posedge clk , posedge async_set)
	begin
		if(async_set)
			q <= 1'b1;
		else
			q <= d;
	end
endmodule
```
Its GTKwave :
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/b3717ddc1a24961d4e335d766f7df6fea792b6b1/Samsung_PD_%23day2/11(async_set).png">

Its Yosys synthesised netlist:
we used **dfflibmap -liberty** <> command to look from only flop library to for d flip flops
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/5dac4460dd9d997d4620d6b16521449a1ec30edd/Samsung_PD_%23day2/12(map).png">
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/5dac4460dd9d997d4620d6b16521449a1ec30edd/Samsung_PD_%23day2/13(dff%20net).png">

Its GTKwave :
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/5dac4460dd9d997d4620d6b16521449a1ec30edd/Samsung_PD_%23day2/11(async_set).png">

Its Yosys synthesised netlist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/5dac4460dd9d997d4620d6b16521449a1ec30edd/Samsung_PD_%23day2/14(async%20set%20netl).png">


Synchronous reset D Flop :

The reset depend on the clock edge. Here the output signal goes low whenever the reset signal is high and at the clock edge(positive or negative)
RTL code of positive edge trigerred synchronous reset D FF:
```
module dff_syncres ( input clk , input async_reset , input sync_reset , input d , output reg q );
	always @ (posedge clk )
	begin
		if (sync_reset)
			q <= 1'b0;
		else	
			q <= d;
	end
endmodule
```
Its GTKwave :
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/d249e61b0031a5effcc73aa6e54e0459942414af/Samsung_PD_%23day2/synch%20res%20gtk.png">

Its Yosys synthesised netlist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/d249e61b0031a5effcc73aa6e54e0459942414af/Samsung_PD_%23day2/sync%20net.png">
</details>

<details>
 <summary> Optimization Techniques </summary>
	
 The Optimization involves the reducing hardware in the design such that to improve area, power and speed. Two example where given:
 1. a*2
Consider a case where 3 bit number is multiplied by 2 in this case we dont need any additional hardware and only needs connecting bits to the output and grounding the LSB bit,same is realized by yosys. When binary number is multiplied by 2^n then result will gave same number by appending zero in LSB by n times.
RTL code:
	
```
	module mul2 (input [2:0] a, output [3:0] y);
	assign y = a * 2; // assign y={a,1'b0}
	endmodule
```

Yosys Synthesis result : 
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/4aa1beeae13c1dcd880195cfe9758467617731a4/Samsung_PD_%23day2/15(mult%20%20synth).png">

 2. a*9
Multiplying a 3 bit number by 9, gives results as concatination of same number twice {a,a}.
a*[8+1]= {a,0,0,0} + a(3bit)={a,a}

RTL code:

```
module mul8 (input [2:0] a, output [5:0] y);
	assign y = a * 9; // assign y={a,a}
endmodule
```

Yosys Synthesis result :

<img width="1085" alt="lib8" src="https://github.com/Avi991/Samsung-PD-training-/blob/4aa1beeae13c1dcd880195cfe9758467617731a4/Samsung_PD_%23day2/16(mult8).png">

</details>

## Day-3- Combinational and sequential optmizations
![dffconst(net)](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/43154f44-cfb6-459d-ae97-45873fef14df)

<details>
 <summary> Combinational Optimization </summary>
Optimising the combinational logic circuit means squeezing the logic to get the most optimized digital design so that optimized circuit area and power is saved. Various techniques and gives us the most optimized circuit.Implemented using synthesis tools
Command to optimize the circuit by yosys is ** yosys> opt_clean -purge ** to remove unused nets
We have done synthesis using yosys for few examples:
	![dffconst(net)](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/43154f44-cfb6-459d-ae97-45873fef14df)

**Example 1**
```
module opt_check (input a , input b , output y);
	assign y = a?b:0;
endmodule
```
yosys generated netlist :
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/opt1.png">
From the output we inferred that above mux implementation can be optimized to two input AND gate

**Example 2**
```
module opt_check2 (input a , input b , output y);
	assign y = a?1:b;
endmodule
```
yosys generated netlist :
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/opt2.png">
From the output we inferred that above mux implementation can be optimized to two input OR gate which is also realised using inverter and NAND gate as stacking of PMOS will result in more area

**Example 3**
```
module opt_check3 (input a , input b, input c , output y);
	assign y = a?(c?b:0):0;
endmodule
```
yosys generated netlist :
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/opt3.png"> 
From the output we inferred that above mux implementation can be optimized to 3 input gate

**Example 4**
```
module opt_check4 (input a , input b , input c , output y);
	assign y = a?(b?(a & c ):c):(!c);
endmodule
```
yosys generated netlist :
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/opt4.png">   
From the output we inferred that above mux implementation can be optimized to two input xnor gate

**Example 5**
Here there is multiple modules present so we will verify whether those module are being used or not and we use flatten for submudules commands to perform that
**read_liberty -lib <library_path>**
**read_verilog <verilog_file>**
**synth -top <module_name>**
**opt_clean -purge**
**abc -liberty <library_path>**
**flatten**
```
module sub_module1(input a , input b , output y);
	 assign y = a & b;
	endmodule

	module sub_module2(input a , input b , output y);
	 assign y = a^b;
	endmodule

	module multiple_module_opt(input a , input b , input c , input d , output y);
	wire n1,n2,n3;
	sub_module1 U1 (.a(a) , .b(1'b1) , .y(n1));
	sub_module2 U2 (.a(n1), .b(1'b0) , .y(n2));
	sub_module2 U3 (.a(b), .b(d) , .y(n3));

	assign y = c | (b & n1); 
	endmodule
```
Generated nelist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/mult_opt1.png"> 
Sub module 1 is an AND gate , Sub module 2 is an OR gate once optimization is done

**Example 6**

```
module sub_module(input a , input b , output y);
	assign y = a & b;
endmodule

module multiple_module_opt2(input a , input b , input c , input d , output y);
	wire n1,n2,n3;
	sub_module U1 (.a(a) , .b(1'b0) , .y(n1));
	sub_module U2 (.a(b), .b(c) , .y(n2));
	sub_module U3 (.a(n2), .b(d) , .y(n3));
	sub_module U4 (.a(n3), .b(n1) , .y(y));
endmodule
```

Generated nelist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/mult_opt2.png">   Sub module is an and gate after realization output comes out to be zero
</details>

<details>
 <summary> Sequential Optimization </summary>
There are various techniques for Sequential Logic Optimization

    - Sequentialal constant propagation

    - Advanced

        - State Optimization

        - Retiming

        - Sequential Logic cloning

Sequential Constant Propogation

For understanding we took asynchronous reset D Flip-flop is fed with d = 0(i.e GND) always so the output will always be 0 irrespective of the clock or circuit.

Advanced

State Optimisation: This is optimisation of unused state. Using this technique we can come up with most optimised state machine.

Cloning : It is an optimization technique that replicates a cell to reduce the load on heavily loaded cell. This technique is usually preffered while performing PHYSICAL AWARE SYNTHESIS. Lets consider a flop A which is connected to flop B and flop C through a combination logic. If B and C are placed far from A in the floorplan, there is a routing path delay. To avoid this, we connect A to two intermediate flops and then from these flops the output is sent to B and C thereby decreasing the delay. This phenomenon is called cloning since we are generating two new flops with same functionality as A.

Retiming : Sequential circuits can be optimised by retiming. The combinational section of the circuitry is unaffected as it only rearranges the registers in the circuit. It is a powerful sequential optimization technique used to move registers across the combinational logic or to optimize the number of registers to improve performance via power-delay trade-off, without changing the input-output behavior of the circuit.

**Example 1**
```
module dff_const2(input clk, input reset, output reg q);
	always @(posedge clk, posedge reset)
	begin
		if(reset)
			q <= 1'b1;
		else
			q <= 1'b1;
	end
endmodule
```
GTK Wave:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst1(gtkwave).png">   


Yosys generated netlist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst(net).png">   
As we know the above code is for a d flipflop with an asynchronous reset this is used to reset the system asynchronously and later the system comes into normal oprtaion for next 1 clk that is synchronously so this system cannot be further optimized and a flipflop is generated 

**Example 2**
```
module dff_const2(input clk, input reset, output reg q);
	always @(posedge clk, posedge reset)
	begin
		if(reset)
			q <= 1'b1;
		else
			q <= 1'b1;
	end
endmodule
```
GTK Wave:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst2(gtkwave).png">


Yosys generated netlist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst2(net).png">
From the output we can say the optimization can be done as the q value is always 1 hence no flop is generated and the optimization is done

**Example 3**
```
module dff_const3(input clk, input reset, output reg q);
	reg q1;

	always @(posedge clk, posedge reset)
	begin
		if(reset)
		begin
			q <= 1'b1;
			q1 <= 1'b0;
		end
		else
		begin
			q1 <= 1'b1;
			q <= q1;
		end
	end
	endmodule
```

GTK Wave:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst3(gtkwave).png">   


Yosys generated netlist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst3(net).png">   

**Example 4**
```
module dff_const4(input clk, input reset, output reg q);
	reg q1;

	always @(posedge clk, posedge reset)
	begin
		if(reset)
		begin
			q <= 1'b1;
			q1 <= 1'b1;
		end
	else
		begin
			q1 <= 1'b1;
			q <= q1;
		end
	end
	endmodule
```

GTK Wave:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst4(gtkwave).png">   


Yosys generated netlist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst4.png"> 

**Example 5**
```
module dff_const5(input clk, input reset, output reg q);
	reg q1;
	always @(posedge clk, posedge reset)
		begin
			if(reset)
			begin
				q <= 1'b0;
				q1 <= 1'b0;
			end
		else
			begin
				q1 <= 1'b1;
				q <= q1;
			end
		end
	endmodule
```
GTK Wave:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffcosnt5(gtkwave).png">   


Yosys generated netlist:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/dffconst5(net).png"> 
No scope of further optimization as the outputs a constant value is seen in all conditions therefore two flipflops getting generated
</details>


<details>
 <summary> Optimization Examples </summary>
	
**Example 1**
```
   module counter_opt (input clk , input reset , output q);
   reg [2:0] count;
   assign q = count[0];
   always @(posedge clk ,posedge reset)
   begin
   	if(reset)
   		count <= 3'b000;
   	else
   		count <= count + 1;
   end
   endmodule
```
   
GTK wave:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/gtkwave(counter%20opt).png"> 

Yosys generated netlist
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/9220aa9dc26021df6e5a1b6ada51b54e987adb1f/Samsung_PD_%23day3/count_opt(netlist).png">
As the 0th bit is only used for the output hence during the synthesis only one flipflop is generated with inverter for the toggle oprtaion 
Remaining bits are unused so their respective flops are not generated
</details>

## Day-4- GLS Blocking vs Non-Blocking And Synthesis-Simulation Mismatch 
<details>
<summary> GLS Concepts And Flow Using Iverilog </summary>

-- What is GLS- Gate Level Simulation?:
GLS is generating the simulation output by running test bench with netlist file generated from synthesis as design under test. Netlist is logically same as RTL code, hence, same test bench can be used for it.

-- Why GLS?:
We perform this to verify logical correctness of the design after synthesizing it. 

If GLS is run with delay annotion then it can be used for timing analysis 

**Synthesis Simulation Mismatch** 

Synthesis simulation mismatch denotes the discrepancy between the actual behavior of a circuit as simulated during design and its real-world performance after synthesizing the design. 

Synthesis simulation mismatched are mainly caused because of the following reasons 

- Missing sensitivity list
- Blocking vs Non Blocking assignments
- Non standard verilog code

**Missing sensitivity list**
The absence of a complete sensitivity list in VLSI design can give rise to problems. In hardware description languages (HDL) like Verilog, a sensitivity list is utilized to specify the inputs that should activate the execution of a specific process or code block. Inadequate or missing signals in the sensitivity list can lead to inaccurate or unforeseen behavior of the circuit during synthesis or simulation. Ensuring an accurate representation of inputs impacting the logic within a process is vital.

As the synthesizer does not look for sensitivity list and it looks only statements in the procedural block , it infers correct circuit and if we simulate the netlist code , there will be synthesis simulation mismatch. In to order tackle this issue this issue it is important to check the behaviour of the circuit first and then match it with the expected output seen in the simulation. 

**Blocking Vs Non Blocking Assignments**

Blocking statements execute the will wait for the current one to finish.i.e. sequentially inside the always block. 
Non-Blocking statements execute all the assignment parallelly inside a always block.First all the RHS is evaluated and then assigned
This will give mismatch as sometimes, improper use of blocking statements can create latches. 

Missing sensitivity list in always block:
Lets take example of mux having inputs as i0,i1 and sel and output as y.
```
always @(sel)                  always @(*)
//It will infer a latch        // It will infer a mux.
```
If i0 and i1 change in activity will not be reflected in always block.
To avoid the synthesis and simulation mismatch. It is very important to check the behaviour of the circuit first and then match it with the expected output seen in simulation and make sure there are no synthesis and simulation mismatches. This is why we use GLS.
</details>

<details>
<summary> LABs </summary>
	
**Case 1**

```
module ternary_operator_mux (input i0 , input i1 , input sel , output y);
   assign y = sel?i1:i0;
endmodule
```
Gtkwave :
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/rtlgtk1.png">

Hardware
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/ter_mux2.png">

Yosys result: 
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/ter_net.png">

GLS Simulation:
I used the below commands to carry out GLS of ternary_operator_mux.v:
```
iverilog <path to verilog model: ../mylib/verilog_model/primitives.v> <path to sky130_fd_sc_hd__tt_025C_1v80.lib: ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib> <name netlist: ternary_operator_mux_net.v> <name testbench: tb_ternary_operator_mux.v>
./a.out
gtkwave tb_ternary_operator_mux.vdc
```
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/gls%20_ter.png">

In this example there is no mismatch between the RTL Design simulated wave and Netlist simulated wave.

**Case 2**
```
module bad_mux (input i0 , input i1 , input sel , output reg y);
	always @ (sel)
	begin
		if(sel)
			y <= i1;
		else 
			y <= i0;
	end
endmodule
```
Gtkwave:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/badmux%20gtk.png">

Hardware
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/badmux%20rep.png">

GLS Simulation:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/bad_gls%20gtk.png">

From the output we can infer the netlist simulation which corrects the bad_mux design which was only changing waveform when sel was triggered while for a mux to work properly it should be sensitivity to all the input signals. No change in activities of input signal is recorded
On comapring the simulation reults it is observed that the RTL simulation and GLS is totally different

**Case 3**
```
module blocking_caveat (input a , input b , input  c, output reg d); 
reg x;
always @ (*)
	begin
	d = x & c;
	x = a | b;
end
endmodule
```
From the above code it's found that q0 value (previous) which is not updated which appears a flop delay hence the output is one clock cycle delayed which is observed in the simulation result 

Gtkwave:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/blocking%20cav%20gtk.png">

Hardware
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/block%20rep.png">

GLS Simulation:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/a8fc691a86189ac01811737e55d04458dbb4ec4a/Samsung_PD_%23day%204/blockgtk_gls.png">

The GLS we can see the output is different from that of the Simulation result there is flop delay visible and we got the output to be a proper OR & AND gated output. To avoid this kind of issue we are supposed to run the GLS to make sure there are no Synthesis and SImulation mismatches

</details>

## Day-6-Introduction to logic synthesis in DC

<details>
<summary> Introduction </summary>

**Synthesis**
-RTL to Gate level translation.

-The design is converted inta gate and connections are made betn the gates.

-INPUT to Synthesis :     (1) RTL    (2) .lib

**Contents of .lib**
A typical Liberty file contains detailed information about the behaviour of standard cells, including :
    *Timing Information : This includes delay, transition and capacitance values associated with the standard cells. Timing information specifies how the cells behave under different input conditions.
    
    *Optimization : Synthesis tools perform optimization to improve the design's performance, area, and power consumption.Logic optimization algorithms identify redundant logic and simplify the gate-level 
     representation to achieve a more efficient implementation.
     
    *Technology Mapping : During synthesis, the design is mapped to a specific target technology library that contains the available gates and flip-flops for the manufacturing process being used (e.g., 28nm, 
      7nm, etc.).The choice of gates from the library is critical in determining the final characteristics of the integrated circuit.
      
    *Power Information : Liberty file also provides data on power consumption , including static power and dynamic power characteristics. This information is crucial for optimizing the power consumption in IC.
  
    *Functional Behaviour : Descriptions of the logical functionality of standard cells, such as input and output pins and logical equations and any additional attributesthat define their operation.
    
    *Operating Conditions : Liberty files may include information about different operating condition in terms of process , voltage and temperature under which all cells are characterized.
     
    *Output for Further Stages : The gate-level netlist produced by synthesis serves as the input for subsequent stages of the design flow, including physical design, place-and-route, and manufacturing.
    

**Need of Liberty files**:

Timing Analysis : EDA tools use Liberty files to perform static timing analysis, ensuring that the IC design meets specified timing constraints. This is critical for achieving desired performance targets.

Power Optimization : Power consumption is a significant concern in modern IC design. Liberty files provide power data that allows designers to optimize power usage and meet energy efficiency goals.

Design Closure : During the design process, designers use Liberty files to guide the synthesis, placement, and routing of standard cells. The data in these files helps achieve design closure by ensuring that the design meets performance, power, and area targets.

Variability Handling : Variability in manufacturing processes can impact the behavior of standard cells. Liberty files may include data for different process corners to account for manufacturing variations.


**Constraints**
Constraints are the instructions that the designer apply during various step in VLSI chip implementation, such as logic synthesis, clock tree synthesis, Place and Route, and Static Timing Analysis. They define what the tools can or cannot do with the design or how the tool behaves. In VLSI design, constraints are essential parameters and limitations that guide the development process to ensure that the resulting integrated circuits (ICs) meet specific performance, timing, and functionality requirements. These constraints play a crucial role in achieving a successful VLSI design.

</details>

<details>
<summary> DC Complier </summary>

Design Compiler ,  is a high-level synthesis tool developed by Synopsys, a leading provider of EDA solutions. It plays a pivotal role in the process of designing complex integrated circuits (ICs) and is an integral part of modern VLSI design flows.

Important terms used

- Synopsys Design Constraints(SDC) : These are the design constraints which are supplied to DC to enable appropriate optimization suitable for achieving the best implementation.
- .lib : Design Library which contains the Standard cells.
- .db : Same as .lib but in a different format. DC understands libraries in .db format
- .ddc : Synopsys propreitary format for storing the design information. DC can write out and read in DDC.
- Design : RTL files which has the behavioral model of the design.

```
        Step 1     Read STD Cell/tech.lib
			 
	Step 2	Read Design (Verilog and Design.lib)
			 
	Step 3	Read SDC
			 
	Step 4	Link the Design
			 
	Step 5	Synthesize
			 
        Step 6  Generate Report and analyse QoR
			 
        Step 7  Write out the Netlist
```

The DC compiler does not understand .lib , so the .lib is converted to .db format. lib format is for user reference.

</details>

<details>
<summary> Labs on DC Complier </summary>

 Invoking dc_shell. Then we echo target library and link_library which returns an vitual library named as your library, which needs to be set.
```
 echo $target_library
 echo $link_library
```
 
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/243be2c0a382f6f00b0ca5a9868387bb46d55db9/Samsung_PD_%23day6/2.png">

The RTL design code is 
```
module lab1_flop_with_en ( input res , input clk , input d , input en , output reg q);
always @ (posedge clk , posedge res)
begin
	if(res)
		q <= 1'b0;
	else if(en)
		q <= d;	
end
endmodule
```
Synthesis of this design code can be done using the following commands
```
read_verilog <path of design file>
read_db <path of .db>
write -f verilog -out <net_filename>
```
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/243be2c0a382f6f00b0ca5a9868387bb46d55db9/Samsung_PD_%23day6/1.png">
Below is the screenshot of the output window after compile This generates the netlist file but it consists of some seqgen library as shown in the figure and not the .db file even though we have read the .db file, This is beacuse we didn't set link and target library,
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/243be2c0a382f6f00b0ca5a9868387bb46d55db9/Samsung_PD_%23day6/2.png">
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/243be2c0a382f6f00b0ca5a9868387bb46d55db9/Samsung_PD_%23day6/3.png">


To set the link_library and target_library we use the following commands:
```
set target_library <path of .db>
set link_library { * path of the .db }
link
compile
write -f verilog -out <net_filename>
```
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/243be2c0a382f6f00b0ca5a9868387bb46d55db9/Samsung_PD_%23day6/5.1.png">
The generated netlist
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/243be2c0a382f6f00b0ca5a9868387bb46d55db9/Samsung_PD_%23day6/6.png">

**Comparing the both the netlist before and after proper mapping of library files**
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/243be2c0a382f6f00b0ca5a9868387bb46d55db9/Samsung_PD_%23day6/9.png">

**Labs on Design Vision**
To launch Design Vision we need to enable c shell and then give design Vision:
```
csh
design_vision
```
After launching the design_vison first we need to the net to .ddc which is read by Design_vision tool which can be done by using the below command
```
set target_library /Path_to_library(.db)
set link_library {* /Path_to_library(.db)}
link
compile
write -f verilog -out file.v
write -f ddc -out file.ddc

```
Then we can start GUI and then read the .ddc file generated above. This ddc file contains all the information of the tool memory of that particular session. ddc is synopys proprietary format i.e it can be read only br synopsys tools.When the .db is read it automatically reads the linked .db file.
If we have an RTL design that we want to synthesize and we have the Verilog code available, we would typically use read_verilog to start the synthesis process. However, if we have a DDC-formatted design from a previous run or from another tool in the Synopsys toolchain, we would use read_ddc to work with that design in Design Compiler's GUI or command-line environment.
When we click lab1 and then schematic we get the schematic view of the Design show below:
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/243be2c0a382f6f00b0ca5a9868387bb46d55db9/Samsung_PD_%23day6/11.png">

**Lab on DC Setup**
The .synopys_dc.setup file for the above example of mux and d flip flop is as follows :

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/2a5a8c27-4485-4be0-8d3f-e1148c4fa01c)

```
set target_library /home/aviral.s/DC_WORKSHOP/lib/sky130_fd_sc_hd_tt_025c_1v80.db
set link_library {* $target_library }
```
</details>


<details>
<summary> Labs on TCL </summary>
Tcl (Tool Command Language) is a scripting language used for automating tasks. In EDA, it's used to automate design processes. Here are loops in Tcl:
	
1. While Loop:
while is used for repeating a block of code as long as a condition is true.

Example:

```
set i 0
while {$i < 5} {
    puts "Iteration $i"
    incr i
	}
```

2. For Loop:
for is used for iterating over a range or a list.

Example:
```
for {set i 0} {$i < 5} {incr i} {
    puts "Iteration $i"
}
```

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/b9492c99-82c1-4260-ae77-3eda1b29ad0a)

**Example**
These codes can be written in tickle file

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/dee74a60-34c2-43ab-bfd8-ea4f7bbc9c86)

Result

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/530cfe98-a82a-4071-93f3-00a36a580271)

Key Points
1. set is used for creating and storing information in the variables
2. We use $ to use any variable that is set when required to be seen as operating
3. Square brackets are used for nesting of commands in TCL.
4. Make sure there are spaces before "{" and after "}" to avoid any errors
5. Wrong manipulation might lead to infinite loop so make sure you use the variables properly.
6. "\" is used if we need write in next line in tcl file but to be considered as continuation of the current line according to the code.
7. foreach_in_collection is specific to synopsys not common in TCL.
8. We can differentiate between list and collection by printing them if it has {} at start and end it is a collection else it is a list.

</details>


## Day-7-Basic of STA

<details>
<summary> Introduction to STA </summary>

Delay in digital circuits is indeed dependent on input transition and output load. Let's explore how these factors affect delay:

1. **Input Tran (Signal Slope):**

   Definition: It refers to the rate of change of a digital input signal, often measured as the time it takes for the signal to transition from one logic level to another (e.g., from low to high or high to 
     low).

   - **Impact on Delay:**
     Faster Transitions : A faster input transition (slope is more) results in lesser delay because it takes less time for the signal to reach the threshold voltage of the mosfet

     Slower Transitions : Conversely, a slower input transition (slope is less) results in higher delay as it takes more time for the signal to cross the switching threshold.

2. **Output Load (Capacitance):**

   Definition : Output load, often represented as load capacitance , represents the electrical load that an output signal must drive. It includes the inherent capacitance of nets and the input capacitance of 
 gates or components connected to the output.

   - **Effect on Delay:**
     High Load : A higher output load capacitance results in more delay, as it takes more time to charge or discharge capacitance, slowing down the signal transition.
     
     Less Load : A lesser output load capacitance leads to less delay, as there is less capacitance to charge or discharge.

STA breaks down the design into time pathways before doing timing analysis. The following factors make up each time path:

Startpoint: The beginning of a timing route in which data is launched by a clock edge or must be ready at a certain moment. Every startpoint must be a register clock pin or an input port.

Combinational logic network: It includes elements with no internal state or memory. AND, OR, XOR, and inverter elements are allowed in combinational logic, but flip-flops, latches, registers, and RAM are not.

Endpoint: When data is caught by a clock edge or when it needs to be provided at a specified moment, this is the end of a timing path. A register data input pin or an output port must be present at each endpoint.

Static timing analysis calculates a maximum delay using the longest way and a minimum delay using the shortest path.

A Setup time (Max Delay Constraint) : It refers to a design specification or requirement that imposes an upper limit on the delay a signal can experience while propagating through a specific path or circuit within an integrated circuit. Consider a example of 2 registers connected with a combinational logic in between them.

**Tclk >= Tcq + Tcomb + Tsu**

Hold time (Min Delay constraint) : It's the minimum time after the clock's rising edge when data must remain stable at the input of a flip-flop to prevent data corruption.

**Thold < Tcq + Tcomb**

**Timing Arc**

 A timing arc defines the propagation of signals through logic gates/nets and defines a timing relationship between two related pins. Timing arc is one of the components of a timing path. Static timing analysis 
 works on the concept of timing paths. 
 
 Each path starts from either primary input or a register and ends at a primary output or a register. In-between, the path traverses through what are known as timing arcs. We can define a timing arc as an 
 indivisible path/constraint from one pin to another that tells EDA tool to consider the path/relationship between the pins. As in purely combinational logic, AND, NAND, NOT, full adder cell etc. gates have 
 arcs from each input pin to each output pin.

 **Combinational Timing Arcs:** These arcs describe the propagation of signals through combinational logic elements like gates.

  ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/b3431df4-1fe2-4bc3-b41c-a31b0d889505)

 **Sequential Timing Arcs:** Sequential elements like flip-flops introduce clock signals into our design. Sequential timing arcs account for clock-to-Q delays, setup times, and hold times to ensure proper 
   operation
     ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/522ef9c8-40d5-4dab-8eec-ae5dd95294bd)

   Timing paths in VLSI design are specific routes or signal paths within a digital circuit where the timing characteristics, including signal propagation delays, setup times, hold times, and clock-to-q delays, 
   are analyzed to ensure the circuit's correct and reliable operation. These paths are crucial for timing analysis and play a central role in achieving the desired performance and functionality of the 
   integrated circuit. Timing paths typically include a starting point (often a flip-flop or input pin), a set of logic gates and interconnections, and an ending point (another flip-flop or output pin).

**Start points of timing path**

Input ports
Clock pins of regs
End point of timing path

Output ports
D pin of D flip flop / D Latch
Always the timing path start at one of the start point and ends at one of the end point

Clock -> D (Reg 2 Reg)

Clock -> Output port (I/O timing path)

input port -> D (I/O timing path)

input port -> Output port (These should not be present)
</details>

<details>
<summary> Labs </summary>
Timing File (.lib) consists of ASCII representations of Timing, Area, and Power associated with the Standard cell. The Naming convention in the timing file follows PVT format (Process, Voltage, Temperature). For example, the standard library used in our case was sky130_fd_sc_hd_tt_025C_1v8, this name suggests that we are using 130 nm technology and the process is typical, temperature is 25C, and 1.8 V represents the voltage.
The common part of Lib file contains
- Library name and technology name
- Units (of time, power, voltage, current, resistance and capacitance)
- Value of operating condition ( process, voltage and temperature) â€“ Max, Min and Typical 

<img width="1085" alt="lib1" src="">

Based on operating conditions there are three different lib files for Max, Min and Typical corners. In the second part of Lib file, it contains cell-specific information for each cell. 

Cell-specific information in Lib file is mainly
  Cell name
  Pin name
  Area of cell
  Leakage power in respect of input pins logic state.

Also It contains Pins details like
  Pin name
  Pin direction
  Internal power
  Capacitance
  Rise capacitance
  Fall Capacitance
  Fanout load
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/ed9ec95d7da99f2c07912ebd2b3be4a10d103b0c/Samsung_PD_%23day7/1.png">

A Look-Up Table (LUT) in a Liberty file is a component that defines the logical behavior and timing characteristics of a combinational logic cell within a digital library.LUT can be both with respect to timing as well as power

index1[row] represents input transition , index2[column] represeents output load capacitance

example of and2_1 gate index table
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/ed9ec95d7da99f2c07912ebd2b3be4a10d103b0c/Samsung_PD_%23day7/2.png">

**Pin Attributes**
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/ed9ec95d7da99f2c07912ebd2b3be4a10d103b0c/Samsung_PD_%23day7/3(pin%20attributes).png">

Sequential flops have clock pin as **true**

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/ed9ec95d7da99f2c07912ebd2b3be4a10d103b0c/Samsung_PD_%23day7/4(flop).png">

**Unateness**
A function is said to be unate if the rise transition on the positive unate input variable causes the ouput to rise or no change and vice versa.

Negative unateness means cell output logic is inverted version of input logic. eg. In inverter having input A and output Y, Y is -ve unate w.r.t A. Positive unate means cell output logic is same as that of input.
These +ve ad -ve unateness are constraints defined in library file and are defined for output pin w.r.t some input pin.

A clock signal is positive unate if a rising edge at the clock source can only cause a rising edge at the register clock pin, and a falling edge at the clock source can only cause a falling edge at the register clock pin.

A clock signal is negative unateÂ if a rising edge at the clock source can only cause a falling edge at the register clock pin, and a falling edge at the clock source can only cause a rising edge at the register clock pin. In other words, the clock signal is inverted.

A clock signal is not unate if the clock sense is ambiguous as a result of non-unate timing arcs in the clock path.

Unnateness of D flip flop positive edge triggered

```
                related_pin : "CLK_N";
                rise_transition ("del_1_7_7") {
                    index_1("0.0100000000, 0.0230506000, 0.0531329000, 0.1224740000, 0.2823110000, 0.6507430000, 1.5000000000");
                    index_2("0.0005000000, 0.0013189500, 0.0034792400, 0.0091778800, 0.0242103000, 0.0638642000, 0.1684670000");
                    values("0.0232978000, 0.0295765000, 0.0465064000, 0.0946410000, 0.2265447000, 0.5754117000, 1.5026856000", \
                        "0.0234848000, 0.0296225000, 0.0464747000, 0.0944869000, 0.2264113000, 0.5750624000, 1.5045718000", \
                        "0.0233643000, 0.0295607000, 0.0464747000, 0.0945168000, 0.2263061000, 0.5753233000, 1.5028371000", \
                        "0.0235687000, 0.0297767000, 0.0466145000, 0.0944561000, 0.2259604000, 0.5746931000, 1.5046934000", \
                        "0.0235661000, 0.0295917000, 0.0466156000, 0.0945248000, 0.2261588000, 0.5747037000, 1.5006447000", \
                        "0.0236305000, 0.0297841000, 0.0466114000, 0.0943436000, 0.2264104000, 0.5749078000, 1.5007792000", \
                        "0.0234834000, 0.0296178000, 0.0466203000, 0.0946091000, 0.2266867000, 0.5748321000, 1.5022009000");
                }
                timing_sense : "non_unate";
                timing_type : "falling_edge";
            }
```


Unateness of D latch positive edge triggered
```
                related_pin : "GATE_N";
                rise_transition ("del_1_7_7") {
                    index_1("0.0100000000, 0.0230506000, 0.0531329000, 0.1224740000, 0.2823110000, 0.6507430000, 1.5000000000");
                    index_2("0.0005000000, 0.0013104500, 0.0034345500, 0.0090016200, 0.0235923000, 0.0618331000, 0.1620580000");
                    values("0.0290359000, 0.0360989000, 0.0537774000, 0.1023029000, 0.2327008000, 0.5800371000, 1.4992581000", \
                        "0.0290669000, 0.0360541000, 0.0537217000, 0.1023566000, 0.2325888000, 0.5812102000, 1.5037938000", \
                        "0.0289580000, 0.0359722000, 0.0537431000, 0.1023093000, 0.2327867000, 0.5797032000, 1.5054989000", \
                        "0.0289144000, 0.0360224000, 0.0538419000, 0.1022993000, 0.2324767000, 0.5806629000, 1.5049062000", \
                        "0.0289832000, 0.0360823000, 0.0537268000, 0.1023169000, 0.2327650000, 0.5794586000, 1.5054222000", \
                        "0.0290149000, 0.0360945000, 0.0537585000, 0.1023309000, 0.2324873000, 0.5810031000, 1.4970503000", \
                        "0.0289586000, 0.0360057000, 0.0538139000, 0.1022934000, 0.2326491000, 0.5787922000, 1.5045210000");
                }
                timing_sense : "non_unate";
                timing_type : "falling_edge";
            }
```


**Lab on .lib in dc_compiler**

 **To print all the sequential gates**
```
dc_shell> echo $target_library 
DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db
dc_shell> get_lib_cells */* -filter "is_sequential == true"
{sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfbbn_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfbbn_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfbbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfrbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfrbp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfrtn_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfrtp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfrtp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfrtp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfsbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfsbp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfstp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfstp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfstp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfxbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfxbp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfxtp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfxtp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dfxtp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlclkp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlclkp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlclkp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrbn_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrbn_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrbp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrtn_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrtn_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrtn_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrtp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrtp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlrtp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlxbn_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlxbn_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlxbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlxtn_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlxtn_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlxtn_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__dlxtp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__edfxbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__edfxtp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__lpflow_inputisolatch_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfbbn_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfbbn_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfbbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfrbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfrbp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfrtn_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfrtp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfrtp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfrtp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfsbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfsbp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfstp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfstp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfstp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfxbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfxbp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfxtp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfxtp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdfxtp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdlclkp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdlclkp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sdlclkp_4 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sedfxbp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sedfxbp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sedfxtp_1 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sedfxtp_2 sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__sedfxtp_4}
```

**To Prints the library linked**
```
dc_shell> list_lib
Logical Libraries:
-------------------------------------------------------------------------
Library		File			Path
-------		----			----
  sky130_fd_sc_hd__tt_025C_1v80 sky130_fd_sc_hd__tt_025C_1v80.db /home/prakhar.g2/Samsung-PD-Training-/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib
1
```

Ex 3 : the list of cells from the collection
```
dc_shell> foreach_in_collection my_lib_cell [get_lib_cells */*and*] {                                                                                                                                                                      set my_lib_cell_name [get_object_name $my_lib_cell];                                                                                                                                                               echo $my_lib_cell_name;                                                                                                                                                                                            }
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2_0
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2b_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2b_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2b_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and3_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and3_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and3_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and3b_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and3b_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and3b_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4b_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4b_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4b_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4bb_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4bb_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and4bb_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand2_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand2_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand2_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand2_8
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand2b_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand2b_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand2b_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_2
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_4
```


**Prints the functionality of a particular cell**
```
dc_shell> foreach_in_collection my_pins [get_lib_pins sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/*] {
set my_pin_name [get_object_name $my_pins];
set pin_dir [get_lib_attribute $my_pin_name direction];
echo $my_pin_name $pin_dir;
}
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/A'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/A 1
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/B'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/B 1
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/C'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/C 1
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/D'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/D 1
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/Y 2
dc_shell> get_lib_attribute sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/Y function
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/Y'. 
(!A) | (!B) | (!C) | (!D)
```
**To find the output pin name and its functionality for multiple cells**

First make vim file by name my_script.tcl , then inside gvim file write :
```
set my_list [list sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4 \
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1 ]



#For each cell in  the list, find the output pin name and its functionality


foreach my_cell $my_list {
foreach_in_collection my_lib_pin [get_lib_pins ${my_cell}/*] {
set my_lib_pin_name [get_object_name $my_lib_pin];
set a [get_lib_attribute $my_lib_pin_name direction];
if {$a > 1} {
set fn [get_lib_attribute $my_lib_pin_name function];
echo $my_lib_pin_name $a $fn;
}
}

}
```
Then Source the file 

dc_shell> source my_script.tcl

```
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1/A'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1/Y 2 (!A) | (!B) | (!C)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2/A'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2/Y 2 (!A) | (!B) | (!C)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4/A'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4/Y 2 (!A) | (!B) | (!C)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1/A_N'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1/Y 2 (A_N) | (!B) | (!C)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2/A_N'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2/Y 2 (A_N) | (!B) | (!C)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4/A_N'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4/Y 2 (A_N) | (!B) | (!C)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1/A'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1/D'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1/Y 2 (!A) | (!B) | (!C) | (!D)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/A'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/D'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_2/Y 2 (!A) | (!B) | (!C) | (!D)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4/A'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4/D'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_4/Y 2 (!A) | (!B) | (!C) | (!D)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1/A_N'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1/D'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_1/Y 2 (A_N) | (!B) | (!C) | (!D)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2/A_N'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2/D'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_2/Y 2 (A_N) | (!B) | (!C) | (!D)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4/A_N'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4/B'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4/D'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4b_4/Y 2 (A_N) | (!B) | (!C) | (!D)
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1/A_N'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1/B_N'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1/C'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1/D'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1/Y'. 
Performing get_lib_attribute on library object 'sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1/Y'. 
sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4bb_1/Y 2 (A_N) | (B_N) | (!C) | (!D)
```
Everywhere its showing its pin name and functionality.
Similarly , We can do for other attributes like area, capacitance, clock etc.
To find the attributes :

dc_shell> list_attributes -app > a

dc_shell> sh gvim a &
</details>


## Day-8 -ADVANCED CONSTRAINTS 

<details>
<summary>Clock & Timing Terminologies</summary>


Before understanding the terms related to clock.First we"ll look the sources of clocks used in general
 
Clock Generators they generate clock signals from which we control the timing of digital operations within the IC. Clock generators are designed to produce clock signals with attributes such as frequency,duty cycle,and phase,to meet the timing requirements of design

**Types of clock generators**

    - Oscillators: These are widely used as clock generators. They generate continuous periodic signals without an external input. Common types include RC oscillators, LC oscillators, and crystal oscillators.

    - Phase-Locked Loops (PLLs): PLLs are versatile clock generators that can generate clock signals with adjustable frequency and phase. They are often used for clock synchronization and multiplication.

    - Ring Oscillators: These are simple but effective oscillators often used for generating clock signals with relatively low frequencies.

    - Crystal Oscillators: They are highly stable and accurate oscillators that use piezoelectric crystals to generate clock signals.

 Clock is constrained ??  
 
 Actually clock period gets constrained , which in turn limits the combinational delay 
 i.e 

   **Tclk [Clock period] >= Tc2q [contamination Delay] + Tcomb [Combination Delay] + Tsu [Setup Time]**

   **Tcomb <= Tclk - (Tc2q + Tsu)**

 
In practical clock never arrives at  two flip flops at same time.Therwe will always be some difference and that difference in clock arrival is called skew.

 **Global Clock Skew**
 
 Global clock skew refers to the difference in arrival times of a clock signal at various points across the entire chip. It affects all elements of the chip and can lead to synchronization issues between different clock domains. Managing global       clock skew is a critical aspect of clock distribution in large and complex integrated circuits. Global skew can be reduced by careful clock tree synthesis and by minimizing the length of critical paths in the design.

 **Local Clock Skew**
 
 Local clock skew is specific to a particular region or block within the chip. It can result from variations in the lengths of wires or traces that carry the clock signal to different parts of a block. Local skew is often easier to manage than        global skew because it affects a smaller portion of the chip. Techniques like buffer insertion and clock gating can be used to mitigate local clock skew.

 Furthermore it can be classified as
          
	  Positive Skew: Positive skew occurs when clock signals arrive at clock pin later than the ideal clock edge. It results in setup time violations.
          
	  Negative Skew: Negative skew occurs when clock signals arrive at clock pin earlier than the ideal clock edge at different destinations. It result in hold time violations.
   </details>

 <details>
<summary>Clock Tree Distribution Model</summary>

	 
The clock distribution network ensures that the clock signal is delivered accurately and with minimal skew to all the sequential elements (like flip-flops) within the chip. Important aspect considering while modeling a clock distribution network in a design:

 **Clock Source:** 
    Determine the source of the clock signal, whether it's generated on-chip or received from an external source,such as oscillator.
   
 **Clock Domain:** 
    Identify and partition the design into clock domains if multiple clock frequencies or asynchronous clock domains are involved.

 **Clock Tree Synthesis (CTS):** 
    Use CTS tools to automatically generate a clock distribution network that meets the design requirements.
   
 **Clock Buffers:**
    Design clock buffers to drive the clock signal through the clock distribution network. Sizing and placing these buffers is very crucial as per the requirement we insert in the path.
   
 **Clock Routing:**
    Plan the routing of clock lines carefully to minimize wirelength and optimize signal delivery. Clock lines should be short and of equal length.
   
 **Clock Distribution Topology:**
 Choose an appropriate topology for the clock distribution network. Common topologies include tree, mesh, or hybrid structures, depending on the chip's layout and size. There are two models H-TREE , I-TREE . Mostly H-TREE is incorporated in the      design
  
 **Clock Synchronization:**
     Implement clock synchronization techniques when dealing with multiple clock domains, ensuring that data is correctly transferred between domains.

 **Clock Domain Crossing (CDC):**
     Handle clock domain crossing issues, where data crosses between different clock domains.Synchronization is required.It will help in avoiding metastability

 **Clock Redundancy:**
     Introduce redundancy in the clock network to improve reliability and fault tolerance.

Designing a clock distribution network to ensure proper functioning and performance of the integrated circuit.

Practical aspects with respect to clock. Source latency, network latency, clock period, and different types of jitter (duty cycle jitter and period jitter) in the context of VLSI clock design:

**Source Latency:**
    Source latency refers to the delay introduced by the clock source, which could be an on-chip oscillator or an external clock input. This latency includes the time it takes for the clock signal to propagate from the source to the point where it enters the clock distribution network. Minimizing source latency is essential to ensure that the clock arrives at the clock distribution network with minimal delay.

 **Network Latency:**
    Network latency is the cumulative delay introduced by the clock distribution network as the clock signal propagates from the source to the various clock pins (e.g., flip-flops). It includes the delay through clock buffers, wires, and routing resources. Minimizing network latency is crucial to ensure that all clock sinks receive the clock signal within the required time window.

 **Clock Period:**
    The clock period, often denoted as T_clk, is the time interval between consecutive rising or falling edges of the clock signal. It is inversely related to the clock frequency (f_clk) by the equation T_clk = 1 / f_clk. The clock period directly affects the maximum achievable operating frequency of the chip and the timing constraints of the design. Designers must ensure that the clock period meets the setup and hold time requirements of the flip-flops.

 **Jitter:**
    Jitter is the variation in the timing of clock edges compared to their ideal or expected positions. It can be caused by various factors and can manifest in different forms such as temprature , noise , process variations .

Commands used in synopsys for modelling the clock

 **`create_clock`**:
   
    This command is used to define clock signals in the design.

    
 **Syntax**
     
     ```tcl
     create_clock -period <clock_period> -name <clock_name> [get_pins <clock_port>]
     ```
       clock_period: Specifies the clock period in nanoseconds.
       clock_name : Assigning a name to the clock signal.

   **Working**:
     - The `create_clock` until and unless we don't define. Error will be there no clock found
     - It is essential for correctly setting up constraints for the design's clock network.


 **`set_clock_latency -source`**:

    This command sets the source latency for a clock signal.

   **Syntax**:
   
     ```tcl
     set_clock_latency -source <latency_value> [get_clocks <clock_name>]
     ```
     latency_value: Specifies the source latency in nanoseconds.
     clock_name: Specifies the clock to which the source latency is applied (optional if not explicitly defined in `create_clock`).

**Working**:
      Source latency accounts for the delay introduced by the clock source (e.g., oscillator) before the clock signal reaches the chip.
    

**`set_clock_latency (network)`**:

   This command sets network latency for a clock signal.
 
 **Syntax**:
 
     ```tcl
     set_clock_latency -network <latency_value> [get_clocks <clock_name>]
     ```
   latency_value : Specifies the network latency in nanoseconds.
    
**Working**:
     Network latency represents the cumulative delay introduced by the clock distribution network (buffers, wires, routing).
    

**`set_clock_uncertainty (setup or hold)`**:
    
     These commands set the uncertainty (jitter and skew) for setup or hold analysis.

    **Syntax**:
     ```tcl
     set_clock_uncertainty -setup <uncertainty_value> -hold <uncertainty_value> [get_clocks <clock_name>]
     ```
     uncertainty_value: Specifies the uncertainty (jitter and skew) in nanoseconds for setup or hold analysis.
  

   - **Working**:

      Setup uncertainty holds  for variations in clock arrival times, affecting flip-flop data input setup times.
      Hold uncertainty holds for variations in clock and data arrival times, affecting flip-flop data input hold times.
      Jitter represents random variations in clock edges, and skew represents systematic variations in clock arrival times.
     
 **`report_clocks`**:
        This command generates a report of clock-related information.

    **Syntax**:
     ```tcl
     report_clocks [-sort_by {name | period | latency}]
     ```
  **Working**:
      The `report_clocks` command provides information about the defined clocks in the design, including their periods and latencies.

      </details>
     
   
</details>


<details>
<summary> Labs on Advanced Constrains </summary>

**Checking the target and link Library**
```
dc_shell> echo $target_library 
DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db

dc_shell> echo $link_library 
*$target_library
```
**Reading and linking verilog file**

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/073235cdc409365758081db5def941b84631488a/Samsung_PD_%23day%208/1(design%20under%20analysis).png">

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/073235cdc409365758081db5def941b84631488a/Samsung_PD_%23day%208/2.png">

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/073235cdc409365758081db5def941b84631488a/Samsung_PD_%23day%208/3(compile).png">


  Linking design 'lab8_circuit'
  Using the following designs and libraries:
  --------------------------------------------------------------------------
  lab8_circuit   /home/aviral.s/Samsung-PD-Training-/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/verilog_files/lab8_circuit.db
  sky130_fd_sc_hd__tt_025C_1v80 (library) /home/aviral.s/Samsung-PD-Training-/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db


**dc_shell> compile_ultra**
Loading db file '/home/synopsys/DC/syn_vT-2022.03-SP5-1/libraries/syn/dw_foundation.sldb'
Warning: DesignWare synthetic library dw_foundation.sldb is added to the synthetic_library in the current command. (UISN-40)
Information: Performing power optimization. (PWR-850)
Analyzing: "/home/aviral.s/Samsung-PD-Training-/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db"
Library analysis succeeded.
Information: Evaluating DesignWare library utilization. (UISN-27)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/f6fd4cf1-7a3d-4883-bd0f-f95a1ca1a90a)


**Listing ports in design**

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/073235cdc409365758081db5def941b84631488a/Samsung_PD_%23day%208/4(ports%20list).png

```
dc_shell> get_ports 
{rst clk IN_A IN_B OUT_Y out_clk}
# returns all the ports present in the design


dc_shell> foreach_in_collection my_port [get_ports *] {
set my_port_name [get_object_name $my_port];
echo $my_port_name;
}
rst
clk
IN_A

OUT_Y
out_clk
```
**Listing port with direction**

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/073235cdc409365758081db5def941b84631488a/Samsung_PD_%23day%208/5(ports%20dir).png">
```
dc_shell> foreach_in_collection my_port [get_ports *] {                                                                                                                                                                            set my_port_name [get_object_name $my_port];
                 set dir [get_attribute [get_ports $my_port_name] direction];
                 echo $my_port_name $dir;
                 }                                                                                                                                                                                               
rst in
clk in
IN_A in
IN_B in
OUT_Y out
out_clk out
```
**4. Listing Cells in design**
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/073235cdc409365758081db5def941b84631488a/Samsung_PD_%23day%208/6(ref%20name%20of%20cell).png">

```
dc_shell> get_cells *
 {REGA_reg REGB_reg REGC_reg U9 U10 U11 U12 U13 U14}

By default system gives hierarchical cells:
dc_shell> get_cells * -hier -filter "is_hierarchical == false"
{REGA_reg REGB_reg REGC_reg U9 U10 U11 U12 U13 U14}


For listing Reference cells :

dc_shell> foreach_in_collection my_cell [get_cells * -hier] {
 set my_cell_name [get_object_name $my_cell];
 set rname [get_attribute [get_cells $my_cell_name] ref_name];
echo $my_cell_name $rname;
}

REGA_reg sky130_fd_sc_hd__dfrtp_1
REGB_reg sky130_fd_sc_hd__dfrtp_1
REGC_reg sky130_fd_sc_hd__dfrtp_1
U9 sky130_fd_sc_hd__clkinv_1
U10 sky130_fd_sc_hd__clkinv_1
U11 sky130_fd_sc_hd__nor2_1
U12 sky130_fd_sc_hd__a21oi_1
U13 sky130_fd_sc_hd__clkinv_1
U14 sky130_fd_sc_hd__nand2_1

```

Now we convert our design into ddc

dc_shell> write -f ddc -out verilog_files/lab8_circuit.ddc

Then open design_vision gui in another tab read ddc file of lab8.
The schematic of lab8_circuit.ddc as gvien below:

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/073235cdc409365758081db5def941b84631488a/Samsung_PD_%23day%208/7(design%20schematic%20and%20net%20connection).png">

```
design_vision> foreach_in_collection my_pin [all_connected n5] {
set pin_name [get_object_name $my_pin];
set dir [get_attribute [get_pins $pin_name] direction];
echo $pin_name $dir;
}
U11/Y out
U13/A in
U12/B1 in
```
**Getting Pin of Design**

```
dc_shell> get_pin *
{REGA_reg/D REGA_reg/CLK REGA_reg/RESET_B REGA_reg/Q REGB_reg/D REGB_reg/CLK REGB_reg/RESET_B REGB_reg/Q REGC_reg/D REGC_reg/CLK REGC_reg/RESET_B REGC_reg/Q U9/A U9/Y U10/A U10/Y U11/A U11/B U11/Y U12/A1 U12/A2 U12/B1 U12/Y U13/A U13/Y U14/A U14/B U14/Y}

Listing it vertically:
dc_shell> foreach_in_collection my_pin [get_pins *] {
set pin_name [get_object_name $my_pin];
echo $pin_name;
}
REGA_reg/D
REGA_reg/CLK
REGA_reg/RESET_B
REGA_reg/Q
REGB_reg/D
REGB_reg/CLK
REGB_reg/RESET_B
REGB_reg/Q
REGC_reg/D
REGC_reg/CLK
REGC_reg/RESET_B
REGC_reg/Q
U9/A
U9/Y
U10/A
U10/Y
U11/A
U11/B
U11/Y
U12/A1
U12/A2
U12/B1
U12/Y
U13/A
U13/Y
U14/A
U14/B
U14/Y
```
If pin is input pin  the list it:

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/073235cdc409365758081db5def941b84631488a/Samsung_PD_%23day%208/2(find%20clock%20pin).png">

After Sourcing tcl file we get this result:
```
dc_shell> source  query_clock_pin.tcl 
REGA_reg/CLK
REGB_reg/CLK
REGC_reg/CLK
```
**Creating Clock**

```
dc_shell> create_clock -name MYCLK -per 10 [get_ports clk]
1
dc_shell> get_clocks *
{MYCLK}


## Reporting Clock
dc_shell> report_clock *
Information: Updating graph... (UID-83)
 
****************************************
Report : clocks
Design : lab8_circuit
Version: T-2022.03-SP5-1
Date   : Tue Sep 12 15:12:44 2023
****************************************

Attributes:
    d - dont_touch_network
    f - fix_hold
    p - propagated_clock
    G - generated_clock
    g - lib_generated_clock

Clock          Period   Waveform            Attrs     Sources
--------------------------------------------------------------------------------
MYCLK           10.00   {0 5}                         {clk}
--------------------------------------------------------------------------------
1

dc_shell> get_attribute [get_ports out_clk] clocks --------> It tells what are clocks reaching the pin.
{MYCLK}                       
dc_shell> get_attribute [get_ports out_clk] clock ---------> It tells is the pin meant to be a clock pin or not.
Warning: Attribute 'clock' does not exist on port 'out_clk'. (UID-101)
```
Creating different types of clock :
```
dc_shell> create_clock -name MYCLK -per 10 [get_ports clk] -wave {5 10} -----> Clock with rising edge at 5 and falling edge at 10. 50% duty cucle.
dc_shell> create_clock -name MYCLK -per 10 [get_ports clk] -wave {0 2.5} -----> Clock with rising edge at 0 and falling edge at 2.5. 25% duty cycle.
dc_shell> create_clock -name MYCLK -per 10 [get_ports clk] -wave {15 20} ----> rising edge at 15, before 15ns no clock.
```

To remove clock :

dc_shell> remove_clock <clock_name>

**Report_timing**

In report timing it says (Path is unconstrained) because clock is not present.
So, we create a clock first...
```
dc_shell> create_clock -name MYCLK -per 10 [get_ports clk]
1


dc_shell> report_timing -to REGC_reg/D
Information: Updating design information... (UID-85)
 
****************************************
Report : timing
        -path full
        -delay max
        -max_paths 1
Design : lab8_circuit
Version: T-2022.03-SP5-1
Date   : Tue Sep 12 15:54:55 2023
****************************************

Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
Wire Load Model Mode: top

  Startpoint: REGB_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Endpoint: REGC_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Path Group: MYCLK
  Path Type: max

  Point                                                   Incr       Path
  --------------------------------------------------------------------------
  clock MYCLK (rise edge)                                 0.00       0.00
  clock network delay (ideal)                             0.00       0.00
  REGB_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                 0.00       0.00 r
  REGB_reg/Q (sky130_fd_sc_hd__dfrtp_1)                   0.29       0.29 r
  U14/Y (sky130_fd_sc_hd__nand2_1)                        0.04       0.34 f
  REGC_reg/D (sky130_fd_sc_hd__dfrtp_1)                   0.00       0.34 f
  data arrival time                                                  0.34

  clock MYCLK (rise edge)                                10.00      10.00
  clock network delay (ideal)                             0.00      10.00
  REGC_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                 0.00      10.00 r
  library setup time                                     -0.12       9.88
  data required time                                                 9.88
  --------------------------------------------------------------------------
  data required time                                                 9.88
  data arrival time                                                 -0.34
  --------------------------------------------------------------------------
  slack (MET)                                                        9.55
```
This report timing will show the arival time and required time with slack. It will not show uncertanity , input and output external delay, latency because we have not modeled it yet.

```
dc_shell> set_clock_latency -source 2 [get_clocks MYCLK]
1
dc_shell> set_clock_latency 1 [get_clocks MYCLK]
1
dc_shell> set_clock_uncertainty -setup 0.5 [get_clocks MYCLK]
1
dc_shell> set_clock_uncertainty -hold 0.5 [get_clocks MYCLK]
1
```

**FOR  SETUP**
```
dc_shell> report_timing -to REGC_reg/D 
Information: Updating design information... (UID-85)
 
****************************************
Report : timing
        -path full
        -delay max
        -max_paths 1
Design : lab8_circuit
Version: T-2022.03-SP5-1
Date   : Tue Sep 12 16:02:40 2023
****************************************

Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
Wire Load Model Mode: top

  Startpoint: REGB_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Endpoint: REGC_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Path Group: MYCLK
  Path Type: max

  Point                                                   Incr       Path
  --------------------------------------------------------------------------
  clock MYCLK (rise edge)                                 0.00       0.00
  clock network delay (ideal)                             3.00       3.00            { changed from 0 to 3 clock network latency =source latency + nwetwork latency = 2 + 1=3}
  REGB_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                 0.00       3.00 r
  REGB_reg/Q (sky130_fd_sc_hd__dfrtp_1)                   0.29       3.29 r
  U14/Y (sky130_fd_sc_hd__nand2_1)                        0.04       3.34 f
  REGC_reg/D (sky130_fd_sc_hd__dfrtp_1)                   0.00       3.34 f
  data arrival time                                                  3.34

  clock MYCLK (rise edge)                                10.00      10.00
  clock network delay (ideal)                             3.00      13.00            {changed from 0 to 3 clock network latency =source latency + nwetwork latency = 2 + 1=3}
  clock uncertainty                                      -0.50      12.50            {Uncertanity is getting subtracted}
  REGC_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                 0.00      12.50 r
  library setup time                                     -0.12      12.38
  data required time                                                12.38
  --------------------------------------------------------------------------
  data required time                                                12.38
  data arrival time                                                 -3.34
  --------------------------------------------------------------------------
  slack (MET)                                                        9.05        --------------------> slack went down from 9.55 to 9.05
```


**FOR HOLD**

```
dc_shell> report_timing -to REGC_reg/D -delay_type min
 
****************************************
Report : timing
        -path full
        -delay min
        -max_paths 1
Design : lab8_circuit
Version: T-2022.03-SP5-1
Date   : Tue Sep 12 16:09:25 2023
****************************************

Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
Wire Load Model Mode: top

  Startpoint: REGA_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Endpoint: REGC_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Path Group: MYCLK
  Path Type: min

  Point                                                   Incr       Path
  --------------------------------------------------------------------------
  clock MYCLK (rise edge)                                 0.00       0.00
  clock network delay (ideal)                             3.00       3.00
  REGA_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                 0.00       3.00 r
  REGA_reg/Q (sky130_fd_sc_hd__dfrtp_1)                   0.29       3.29 r
  U14/Y (sky130_fd_sc_hd__nand2_1)                        0.04       3.33 f
  REGC_reg/D (sky130_fd_sc_hd__dfrtp_1)                   0.00       3.33 f
  data arrival time                                                  3.33

  clock MYCLK (rise edge)                                 0.00       0.00
  clock network delay (ideal)                             3.00       3.00
  clock uncertainty                                       0.50       3.50     {Here Uncertainity is getting added}
  REGC_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                 0.00       3.50 r
  library hold time                                      -0.05       3.45
  data required time                                                 3.45
  --------------------------------------------------------------------------
  data required time                                                 3.45
  data arrival time                                                 -3.33
  --------------------------------------------------------------------------
  slack (VIOLATED)                                                  -0.12
```
   
**8. Modeling IO delays**

When we do report_timing -from **IN_A** we get path is unconstrained. We set IO Constrains :
```
dc_shell> set_input_delay -max 5 -clock [get_clocks MYCLK] [get_ports IN_A]
1
dc_shell> set_input_delay -max 5 -clock [get_clocks MYCLK] [get_ports IN_B]
1
dc_shell> set_input_delay -min 1 -clock [get_clocks MYCLK] [get_ports IN_B]
1
dc_shell> set_input_delay -min 1 -clock [get_clocks MYCLK] [get_ports IN_A]
1
dc_shell> set_input_transition -max 0.3 [get_ports IN_A]
1
dc_shell> set_input_transition -max 0.3 [get_ports IN_B]
1
dc_shell> set_input_transition -min 0.1 [get_ports IN_B]
1
dc_shell> set_input_transition -min 0.1 [get_ports IN_A]
1
```

We get report_timing as :

FOR SETUP :

```
dc_shell> report_timing -from IN_A -trans -net -cap -nosplit 
 
****************************************
Report : timing
        -path full
        -delay max
        -nets
        -max_paths 1
        -transition_time
        -capacitance
Design : lab8_circuit
Version: T-2022.03-SP5-1
Date   : Tue Sep 12 16:20:38 2023
****************************************

Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
Wire Load Model Mode: top

  Startpoint: IN_A (input port clocked by MYCLK)
  Endpoint: REGA_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Path Group: MYCLK
  Path Type: max

  Point                                       Fanout       Cap     Trans      Incr       Path
  ----------------------------------------------------------------------------------------------
  clock MYCLK (rise edge)                                                     0.00       0.00
  clock network delay (ideal)                                                 3.00       3.00
  input external delay                                                        5.00       8.00 f
  IN_A (in)                                                         0.30      0.00       8.00 f
  IN_A (net)                                    2         0.00                0.00       8.00 f
  U11/Y (sky130_fd_sc_hd__nor2_1)                                   0.16      0.22       8.22 r
  n5 (net)                                      2         0.01                0.00       8.22 r
  U13/Y (sky130_fd_sc_hd__clkinv_1)                                 0.05      0.07       8.29 f
  N0 (net)                                      1         0.00                0.00       8.29 f
  REGA_reg/D (sky130_fd_sc_hd__dfrtp_1)                             0.05      0.00       8.29 f
  data arrival time                                                                      8.29

  clock MYCLK (rise edge)                                                    10.00      10.00
  clock network delay (ideal)                                                 3.00      13.00
  clock uncertainty                                                          -0.50      12.50
  REGA_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                                     0.00      12.50 r
  library setup time                                                         -0.13      12.37
  data required time                                                                    12.37
  ----------------------------------------------------------------------------------------------
  data required time                                                                    12.37
  data arrival time                                                                     -8.29
  ----------------------------------------------------------------------------------------------
                                                                                         4.08   ----------------> Setup slack is reduced due input trans.

```

FOR HOLD : 
```
dc_shell> report_timing -from IN_A -trans -net -cap -nosplit -delay_type min
 
****************************************
Report : timing
        -path full
        -delay min
        -nets
        -max_paths 1
        -transition_time
        -capacitance
Design : lab8_circuit
Version: T-2022.03-SP5-1
Date   : Tue Sep 12 16:25:15 2023
****************************************

Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
Wire Load Model Mode: top

  Startpoint: IN_A (input port clocked by MYCLK)
  Endpoint: REGB_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Path Group: MYCLK
  Path Type: min

  Point                                       Fanout       Cap     Trans      Incr       Path
  ----------------------------------------------------------------------------------------------
  clock MYCLK (rise edge)                                                     0.00       0.00
  clock network delay (ideal)                                                 3.00       3.00
  input external delay                                                        1.00       4.00 r
  IN_A (in)                                                         0.10      0.00       4.00 r
  IN_A (net)                                    2         0.00                0.00       4.00 r
  U12/Y (sky130_fd_sc_hd__a21oi_1)                                  0.04      0.07       4.07 f
  N1 (net)                                      1         0.00                0.00       4.07 f
  REGB_reg/D (sky130_fd_sc_hd__dfrtp_1)                             0.04      0.00       4.07 f
  data arrival time                                                                      4.07

  clock MYCLK (rise edge)                                                     0.00       0.00
  clock network delay (ideal)                                                 3.00       3.00
  clock uncertainty                                                           0.50       3.50
  REGB_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                                     0.00       3.50 r
  library hold time                                                          -0.05       3.45
  data required time                                                                     3.45
  ----------------------------------------------------------------------------------------------
  data required time                                                                     3.45
  data arrival time                                                                     -4.07
  ----------------------------------------------------------------------------------------------
  slack (MET)                                                                            0.62

```
Setting Output Delay 

```
dc_shell> set_output_delay -max 5 -clock [get_clock MYCLK] [get_ports OUT_Y]
1
dc_shell> set_output_delay -min 1 -clock [get_clock MYCLK] [get_ports OUT_Y]
1
```
Report timing :

```
dc_shell> report_timing -to OUT_Y -cap -trans -nosplit
Information: Updating design information... (UID-85)
 
****************************************
Report : timing
        -path full
        -delay max
        -max_paths 1
        -transition_time
        -capacitance
Design : lab8_circuit
Version: T-2022.03-SP5-1
Date   : Tue Sep 12 16:30:24 2023
****************************************

Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
Wire Load Model Mode: top

  Startpoint: REGC_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Endpoint: OUT_Y (output port clocked by MYCLK)
  Path Group: MYCLK
  Path Type: max

  Point                                          Cap     Trans      Incr       Path
  ------------------------------------------------------------------------------------
  clock MYCLK (rise edge)                                           0.00       0.00
  clock network delay (ideal)                                       3.00       3.00
  REGC_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                 0.00      0.00       3.00 r
  REGC_reg/Q (sky130_fd_sc_hd__dfrtp_1)         0.00      0.04      0.34       3.34 f
  U10/Y (sky130_fd_sc_hd__clkinv_1)             0.00      0.01      0.03       3.36 r
  OUT_Y (out)                                             0.01      0.00       3.36 r
  data arrival time                                                            3.36

  clock MYCLK (rise edge)                                          10.00      10.00
  clock network delay (ideal)                                       3.00      13.00
  clock uncertainty                                                -0.50      12.50
  output external delay                                            -5.00       7.50
  data required time                                                           7.50
  ------------------------------------------------------------------------------------
  data required time                                                           7.50
  data arrival time                                                           -3.36
  ------------------------------------------------------------------------------------
  slack (MET)                                                                  4.14
```

After setting load
```
dc_shell> set_load -max 0.4 [get_ports OUT_Y]
1
dc_shell> set_load -min 0.1 [get_ports OUT_Y]
1
```

Report Timing

```
dc_shell> report_timing -to OUT_Y -cap -trans -nosplit
 
****************************************
Report : timing
        -path full
        -delay max
        -max_paths 1
        -transition_time
        -capacitance
Design : lab8_circuit
Version: T-2022.03-SP5-1
Date   : Tue Sep 12 16:33:26 2023
****************************************

Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
Wire Load Model Mode: top

  Startpoint: REGC_reg (rising edge-triggered flip-flop clocked by MYCLK)
  Endpoint: OUT_Y (output port clocked by MYCLK)
  Path Group: MYCLK
  Path Type: max

  Point                                          Cap     Trans      Incr       Path
  ------------------------------------------------------------------------------------
  clock MYCLK (rise edge)                                           0.00       0.00
  clock network delay (ideal)                                       3.00       3.00
  REGC_reg/CLK (sky130_fd_sc_hd__dfrtp_1)                 0.00      0.00       3.00 r
  REGC_reg/Q (sky130_fd_sc_hd__dfrtp_1)         0.00      0.05      0.30       3.30 r
  U10/Y (sky130_fd_sc_hd__clkinv_1)             0.40      3.07      2.32       5.62 f
  OUT_Y (out)                                             3.07      0.00       5.62 f
  data arrival time                                                            5.62

  clock MYCLK (rise edge)                                          10.00      10.00
  clock network delay (ideal)                                       3.00      13.00
  clock uncertainty                                                -0.50      12.50
  output external delay                                            -5.00       7.50
  data required time                                                           7.50
  ------------------------------------------------------------------------------------
  data required time                                                           7.50
  data arrival time                                                           -5.62
  ------------------------------------------------------------------------------------
  slack (MET)                                                                  1.88

```

Due to increase in load from 0 to 0.4 the transition time icreased, due to which we have more delay. Slack is also reduced. 

 **Generated Clock**

A generated clock  refers to a clock signal that is derived or generated from a primary clock source rather than being the primary clock signal itself. 

**Frequency Division**: 

Generated clocks are often used to create lower-frequency clocks from a higher-frequency master clock. This is achieved by dividing the frequency of the primary clock using digital counters or dividers. It allows different parts of the circuit to operate at slower clock speeds for power savings or to meet timing requirements.

**Frequency Multiplication**: 

Conversely, generated clocks can be used to create higher-frequency clocks from a lower-frequency source. This is often done using PLLs (Phase-Locked Loops) or DLLs (Delay-Locked Loops). Frequency multiplication is useful for driving specific high-speed components or meeting timing constraints.

**Clock Skew Control**: 

Generated clocks can be employed to control clock skew, which is the variation in arrival times of clock signals across the chip. By generating clocks with adjusted phases, designers can minimize clock skew and ensure that data is captured reliably in flip-flops and latches.
  
**Clock Gating** : Clock gating is a power-saving technique where clocks to certain parts of the circuit are enabled or disabled dynamically based on activity. Generated clocks can be used to control clock gating circuits, allowing for efficient power management by turning off clocks when they are not needed.

**Clock Domain Isolation** : 

In complex designs, different sections of a chip may operate in separate clock domains. Generated clocks can be used to create domain-specific clocks, enabling isolated operation with respect to clock signals. This is essential for managing timing constraints and avoiding issues associated with crossing clock domains.

**Synchronization** : 

When signals need to cross from one clock domain to another, synchronization is required to prevent data corruption. Generated clocks can be used to create synchronization signals and ensure proper data transfer between domains.


The command to create a generated clock is 

create_generated_clock -name <name_of_generated_clock> - master <master_clock_name> -source \[<master_clock_definition_point>] -div <value> \[<generated_clock_definition_point>]

Here a generated clock namely MYGEN_CLK is created , we can see that its attribute is G

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/7aad20b4-ccc3-47d0-9163-da35a933bc95)


Report timing we get respect to MYCLK

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/2f22858f-1109-4531-9c1b-42b67f0b9a57)

when we add constraints to the MYGEN_CLK we get timing with repect to MYGEN_CLK

set_clock_latency -max 1 \[get_clocks MYGEN_CLK}

set_output_delay -max 5 \[get_ports OUT_Y] -clock \[get_clocks MYGEN_CLK]

set_output_delay -min 1 \[get_ports OUT_Y] -clock \[get_clocks MYGEN_CLK]

The design used for this experiment is as follows

```
module lab8 circuit (input rst, input clk , input IN_A , input IN_B , output OUT_Y , output out_clk output reg out_div_clk)
reg REGA, REGB , REGC ;
always @ (posedge clk , posedge rst )
begin
	if(rst)
	begin
		REGA <= 1'b0 ;
		REGB <= 1'b0 ;
		REGC <= 1'b0 ;
		out_div_clk <= 1'b0 ;
	end
	else
	begin
		REGA= IN_A | IN_B;
		REGB<- IN_A ^ IN_B;
		REGC <= !(REGA & REGB) ;
		out_div_clk <= ~out_div_clk
	end
end

assign OUT_Y = ~REGC ;

assign out_clk = clk;

endmodule
```
Instead of writting constraints everytime we can create a .tcl script and then source it evrerytime

```
create_clock -name MYCLK -per 10 [get_ports clk];
set_clock_latency -source 2 [get_clocks MYCLK];
set_clock_latency 1 [get_clocks MYCLK];
set_clock_uncertainty -setup 0.5 [get_clocks MYCLK];
set_clock_uncertainty -hold 0.1 [get_clocks MYCLK];
set_input_delay -max 4 -clock [get_clocks MYCLK] [get_ports IN_A];
set_input_delay -max 4 -clock [get_clocks MYCLK] [get_ports IN_B];
set_input_delay -min 1 -clock [get_clocks MYCLK] [get_ports IN_A];
set_input_delay -min 1 -clock [get_clocks MYCLK] [get_ports IN_B];
set_input_transition -max 0.4 [get_ports IN_A];
set_input_transition -max 0.4 [get_ports IN_B];
set_input_transition -min 0.1 [get_ports IN_A];
set_input_transition -min 0.1 [get_ports IN_B];
create_generated_clock -name MYGEN_CLK -master MYCLK -source [get_ports clk] -div 1 [get_ports out_clk];
create_generated_clock -name MYGEN_DIV_CLK -master MYCLK -source [get_ports clk] -div 2 [get_ports out_div_clk]; 
set_output_delay -max 4 -clock [get_clocks MYGEN_CLK] [get_ports OUT_Y];
set_output_delay -min 1 -clock [get_clocks MYGEN_CLK] [get_ports OUT_Y];
set_load -max 0.4 [get_ports OUT_Y];
set_load -min 0.1 [get_ports OUT_Y];

```
The report_timing after sourcing the tcl script

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/61196011-e453-48f7-881a-aaa67ccad3e9)

When we give report_port -verbose

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/197bd233-491a-4707-8b7c-faee883b09a1)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/253f1ac0-2f23-4622-839e-bf7ce8e90066)

When we give set_input_delay -max 3 -clock <clock_name>  [<definition_point>]

  Here -max 3 implies that the data arrives 3 ns late compared to clock

  set_input_delay -max -3 -clock <clock_name>  [<definition_point>]

  Here the data is arriving 3 ns before the rising edge which helps in setup time

  so negative max relaxes the path in case of setup

  Positive max tightens the path in case of setup

  In case of hold it is the opposite case negative min tightens the path and positive min relaxes the path.

  The command for max_latency is

  set_max_latency <value> -from \[<source_port_name>] -to \[<destination_port_name>]

  The command for creating virtual clock

  create_clock -name <virtual_clock_name> -period <value>

  For virtual clock there is no latency and no clock defination point 
  ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/51f7afe4-47e3-4b90-9d74-d59889aca6fe)


![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/7f76130e-f5dd-4eb3-93b1-e5ad73cb5f6c)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/97382e37-33b1-4c21-b600-38d0733fc49a)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/e7923dc7-a397-4e84-8960-997ac963aae0)

![schematic (1)](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/6a9fa376-2d5d-4fc3-a9e9-eb04777eaf3d)


<details>
<summary>Virtual Clock and Set Max delay Constraints</summary>

**Creating a Virtual Clock with `create_clock`**:

In Synopsys Design Constraints (SDC), you can define a virtual clock using the `create_clock` command by specifying a period of 10 units. This effectively creates a virtual clock with a specified period.

**Syntax**:
```tcl
create_clock -name virtual_clk -period 10
```
-name <clock_name>: Assigns a name to the virtual clock, in this case, "virtual_clk."
-period <period_value>: Specifies the clock period, which is set to 10 units in this example.

**Working**:

The `create_clock` command is typically used to define clock signals in a digital design.
In this case, we are using it to create a virtual clock, which is a clock that doesn't have a physical source but is defined for timing analysis purposes.
We specify a name for the virtual clock, "virtual_clk," to uniquely identify it in the design.
 The `-period` option sets the clock period to 10 units. While this period value is provided, keep in mind that in the context of a virtual clock, this period doesn't represent a real clock period but is used as an abstract timing constraint for paths associated with this virtual clock.

**Using `set_max_delay` with Virtual Clocks**:

Once you have defined a virtual clock, you can use the `set_max_delay` command to specify timing constraints for paths related to this virtual clock. For example, if you want to set a maximum delay of 15 units for a specific path associated with the virtual clock "virtual_clk," you can use the following command:

```tcl
set_max_delay -from <source> -to <destination> 15 -clock virtual_clk
```

 from source: Specifies the source point in the design.
 -to destination: Specifies the destination point in the design.
 delay_value : Specifies the maximum allowable delay, in this case, 15 units.
 -clock virtual_clk : Associates this timing constraint with the virtual clock "virtual_clk."

**Rise and Fall Delays**:

In addition to setting maximum delays, you can also specify rise and fall delays using the `set_max_delay` command. Rise and fall delays represent the maximum time a signal is allowed to transition from a logic low (0) to a logic high (1) or vice versa. These constraints are important for ensuring proper signal transitions in your design.

To set a maximum rise delay of 5 units and a maximum fall delay of 3 units for a path associated with the virtual clock "virtual_clk," you can use the following commands:

```tcl
set_max_delay -from <source> -to <destination> 5 -clock virtual_clk -rise
set_max_delay -from <source> -to <destination> 3 -clock virtual_clk -fall
```

- `-rise`: Specifies that you are setting a maximum rise delay.
- `-fall`: Specifies that you are setting a maximum fall delay.

By applying these constraints, you ensure that signal transitions on paths related to the virtual clock meet the specified timing requirements, contributing to the overall reliability and performance of your design.
</details>


<details>
<summary>Lab on the above concept</summary>

Let us consider the design shown below
	
```
module lab8_circuit (input rst, input clk , input IN_A , input IN_B , output OUT_Y , output out_clk);
reg REGA , REGB , REGC ; 

always @ (posedge clk , posedge rst)
begin
	if(rst)
	begin
		REGA <= 1'b0;
		REGB <= 1'b0;
		REGC <= 1'b0;
	end
	else
	begin
		REGA <= IN_A | IN_B;
		REGB <= IN_A ^ IN_B;
		REGC <= !(REGA & REGB); 
	end
end

assign OUT_Y = ~REGC;

assign out_clk = clk;

endmodule

```
Commands used to run the Synthesis are

```
#configure .synopsys_dc.setup
read_verilog lab8_circuit.v
link
compile_ultra
write -f ddc -out lab8_circuit.ddc
```

Apart from the verilog code used above we have also used the modified version of it which is mentioned below

```
module lab8_circuit (input rst, input clk , input IN_A , input IN_B , output OUT_Y , output out_clk , output reg out_div_clk , input IN_C , input IN_D , output OUT_Z );
reg REGA , REGB , REGC ; 

always @ (posedge clk , posedge rst)
begin
	if(rst)
	begin
		REGA <= 1'b0;
		REGB <= 1'b0;
		REGC <= 1'b0;
		out_div_clk <= 1'b0;
	end
	else
	begin
		REGA <= IN_A | IN_B;
		REGB <= IN_A ^ IN_B;
		REGC <= !(REGA & REGB);
		out_div_clk <= ~out_div_clk; 
	end
end

assign OUT_Y = ~REGC;

assign out_clk = clk;
assign OUT_Z = IN_C ^ IN_D ;


endmodule
```

Information on all the clocks is given below
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/81229ce8-e3e1-428f-91ac-015223ccb682)

 Since we have not compiled the design the path to OUT_Z is still unconstrained as shown:

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/6063c39c-02c7-46d4-a549-487ca51e1722)


We will constraint the path to OUT_Z by using the virtual clock: <br>

```
set_input_delay -max 5 [get_ports IN_C] -clock [get_clocks MYVCLK];
set_input_delay -max 5 [get_ports IN_D] -clock [get_clocks MYVCLK];
set_output_delay -max 4.9 [get_ports OUT_Z] -clock [get_clocks MYVCLK];
```
 Time period of the clock to 10 ns. Now out of 10 ns, 5 ns for input delay and 4.9 ns is used up by the output path. So out of 10ns only 100 ps is left for the combinational delay of the XOR gate between IN_A, IN_C to OUT_Z. From report XOR gate needs 120 ps, but only 100 ps is available for the combination logic, therefore slack is not met.

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/84b1f179-56ea-4d8d-b548-a620cc31aa2a)


 Now we will compile the design to optimise to fix slack violation as shown

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/9a30d0ac-a0af-4b7b-a45e-19f3bf1e87a0)


It is noted that the input and the output delays are with respect to virtual clock now as shown

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/0baaaeb0-edc6-45ee-874e-51fede331ea8)

</details>


</details>


## Day-9 OPTIMIZATION

<details>
<summary>Introduction to Combinational and Sequential Optimization</summary>

VLSI optimization which is done to improve the design's power consumption, area utilization, timing.

 The goals of optimization :

 **Cost based Optimization**
     Optimize till cost is met at the same time taking care over optimization of one goal should'nt harm other goals.
     
 **Performance Optimization**
      
   Speed :-
      Improve the operational speed of the IC by minimizing delays, optimizing critical paths, and ensuring that the design meets specified timing requirements.
      
  Throughput :-
      Enhance the overall system throughput by optimizing data flow and minimizing bottlenecks in the circuit.

 **Power Optimization**

        Dynamic Power :-
	          Minimize dynamic power consumption to extend battery life in portable devices and reduce power dissipation in data centers.
        Static Power :- 
	          Reduce static power (leakage power) to lower overall power consumption when the IC is in standby or idle mode.

This logic optimizations are mainly of two types:

  -->  Combinational logic optimizations.

            Constant propagation (Direct optimization)

            Squeezing the logic to get optimized version of the output saving area as well as power

  -->  Sequential logic optimizations.

       Basic
           Sequential Constant propagation
           
	   Retiming 
	         Retiming is done when there is requirement distribution of the combinational logic between the  flip flops
           
	   Unused Flop Removal 
           
	   Clock Gating

  	Advanced
           State Optimization 
           Sequential logic cloning :  [Logic cloning is done during physical aware synthesis when there is a huge positive slack is present]


    
 **Optimization of Unloaded Outputs**

Optimizing unloaded outputs typically involves reduction of power consumption , area, delay for unused or idle pins . It refers to flip-flops whose outputs are not connected to any subsequent logic gates or do not affect the functionality of the overall circuit. so these flip flops can be removed thus retaining the function and reducing the area , power of the design.

**Controlling sequential optimization**

**- compile_seqmap_propagate_constants** If this parameter is not set to true, the sequential constant propagating circuits are retained in circuit and not optimized.

**- compile_delete_unloaded_sequential_cells** If this parameter is not set to true, it doesn't remove the counter cells as discussed, it retains all counters in the circuit.

**- compile_register_replication** If this parameter is set to true, this replicates the registers in cloning optimization so that timing is met.
                    
</details>


<details>
<summary> Labs on Sequential and Combinational Optimization </summary>

 1. **Opt_check**
    
    The RTL code of the opt_check is as follows
    ```
    module opt_check (input a , input b , input c , output y1, output y2);
	wire a1;
	assign y1 = a?b:0;
	assign y2 = ~((a1 & b) | c);
	assign a1 = 1'b0;
    endmodule
    ```
    The above code optimized to a simple AND gate after optimization

      ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/6f0a16d5-1074-4e25-8323-17c8582ac286)

      ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/79909207-c9dd-4f2d-a346-46f989791062)

 2. **Opt_check2**

   The RTL code of the opt_check is as follows
    ```
   module opt_check2 (input a , input b , output y);
	assign y = a?1:b;
   endmodule
    ```
    After optimization it result in a simple OR gate

     ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/9569cd29-4f10-42a6-8ecb-e7ef4ca7359b)

3. **Opt_check3**
   
    The RTL code of the opt_check is as follows
    ```
   module opt_check3 (input a , input b, input c , output y);
	assign y = a?(c?b:0):0;
   endmodule
    ```
  The above code is actually supposed to get two multiplexers but after the optimization breaks down into 3 input AND gate as shown below

   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/d838e21d-69bd-4572-85d5-c14075568e3e)

4. **Opt_check4**
   
   The RTL code of the opt_check is as follows
    ```
   module opt_check4 (input a , input b , input c , output y);
 	assign y = a?(b?(a & c ):c):(!c);
   endmodule
    ```
     Finally it optimized to XNOR gate

   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/760c0e5c-03cd-423a-a15b-abb8fd8f6454)
   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/d1ab7238-d78c-480b-8d54-e32cb02a5f14)
   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/ded64aa4-8d0f-494b-841e-bdb436eaf34a)
   ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/769be8db-047f-47c7-bebf-e8e5c6971b8c)

**Resource Sharing**

 Consider the example 
 ```
module resource_sharing_mult_check (input [3:0] a , input [3:0] b, input [3:0] c , input [3:0] d, output [7:0] y  , input sel);
	assign y = sel ? (a*b) : (c*d);

endmodule
```

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/d5520240-ab8d-4631-b23e-563ad0b1d59e)

The timing report without constraint to the design are as follows

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/4130e92d-d76e-4136-b4c6-8f9046571605)

when constraining design with max_delay 2.5 ns 
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/f2bd1695-c0e9-43a6-aa85-cefcf58e1283)

After optimization

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/1fefb331-4d0e-4551-a8f6-cb30ccd1993e)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/00448b3b-a051-4185-b2ef-7662474086d6)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/7b93010f-a530-4515-8315-d1d473f9075e)

**set_max_area 800**

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/5232a718-5879-4169-ae23-02bd5af0b933)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/8f0ac7e6-002d-4383-8935-1cb8f91ca0a4)


**Lab Sequential logic Optimizations**

In this optimization sequential constant propagation 1 traverses finally . But we can't directly connect VDD as due to noise logic may degrade hence we use TIE cells

Tie cells

Tie cells also known as tie-high and tie-low cells, are components used in design to ensure that fixed signal value are held at a logic level either 1 or 0 regardless of input condition. These cells are particularly useful in preventing floating or undefined states in digital circuit.

 **dff_const**
  ```ruby
   module dff_const1(input clk, input reset, output reg q);
	always @(posedge clk, posedge reset)
	begin
		if(reset)
			q <= 1'b0;
		else
			q <= 1'b1;
	end

  endmodule
  ```
As it is not a sequential constant we see the flops are present in logic

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/44d65d34-2b0d-4629-b6e4-0e24f98bc4e8)

**dff_const2**
```
module dff_const2(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b1;
	else
		q <= 1'b1;
end

endmodule
```
It is a sequential constant propagation so th flops are optimized also we could also see TIE cell

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/8b8a3ff1-391d-4f4a-9f42-857636593b3d)

If design rquirement is such that we want Flip flops or intermediate modules need to be intact we don't need to optimize the circuit

In such case we can use the following command to prevent constant sequential propagation

**set compile_seqmap_propagate_constants false**

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/30b6e064-f015-4610-8992-7ff627ff4850)

**dff_const3**
```
module dff_const3(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```
This is not an example of sequential constant propagation

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/8ae92186-7fac-463d-b237-9a84dff7a6b1)

**dff_const4**
```
module dff_const4(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b1;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/37027cdc-bdc6-402b-b80c-850ed66bf851)

**dff_const5**
```
module dff_const5(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
        begin
		q <= 1'b0;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```
begin
		q <= 1'b0;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end
endmodule
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/83915d25-3f94-47ba-855f-fc1499a9872e)

</details>

<details>
<summary>Special optimization</summary>

**Boundary Optimization**

The optimization of boundaries or interfaces between different components or modules within a design.

Aspect of Boundary optimization 

Placement Algorithms: Boundary optimization involves using placement algorithms to determine the optimal physical location of each module on the chip's layout. These algorithms consider factors like signal interconnect lengths, wire delays, and minimizing congested areas on the chip.

Routing Considerations : After placement, routing algorithms are used to create the physical wires that connect the module boundaries. Proper routing is essential for meeting timing constraints and minimizing power consumption.Following manhattan algorithm

Design Rules : Boundary optimization must adhere to manufacturing design rules and constraints imposed by the semiconductor fabrication process. These rules govern factors like minimum feature sizes, metal layers, and spacing requirements to ensure the manufacturability of the chip.

Boundary optimization is often an iterative process. Designers may need to make trade-offs between area, power, and timing to achieve the desired performance goals.

**Lab**

RTL Design code
```
module check_boundary (input clk , input res , input [3:0] val_in , output reg [3:0] val_out);
wire en;
internal_module u_im (.clk(clk) , .res(res) , .cnt_roll(en));

always @ (posedge clk , posedge res)
begin
	if(res)
		val_out <= 4'b0;
	else if(en)
		val_out <= val_in;	
end
endmodule

module internal_module (input clk , input res , output cnt_roll);
reg [2:0] cnt;

always @(posedge clk , posedge res)
begin
	if(res)
		cnt <= 3'b0;
	else
		cnt <= cnt + 1;
end

assign cnt_roll = (cnt == 3'b111);

endmodule
```
Loading the design and compiling

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/89704c5a-1ad4-49cd-bc55-889cf0244d16)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/61707ba0-e51d-4adb-8374-d096c8c57f32)

No boundary , Entire design is optimized
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/6cb01c28-b2a4-46be-9c70-e8f73a7234c8)

If we don't want boundary optimization then we need to use the below command

**set_boundary_optimization <name_pin> false**

example : *set_boundary_optimization u_im false*

The following image shows the design with hierarchical module u_im in the design.
 ![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/222527eb-dadb-4e9f-a4ae-7bff62509b65)

**Register Retiiming**

Register retiming is a technique used in design to optimize the performance of digital circuits by rearranging the registers in the circuit without changing its functionality. The primary goal of register retiming is to minimize the critical path delay, which is the longest path in the circuit from an input to an output.

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/2223e83c-614e-4563-aa4e-977952db5716)

Command used for retiming in the synthesis

**compile_ultra -retime**


**Lab**

Consider a example in which a 4-bit multiplier multiplying two 4-bit numbers and three 8-bit registers through which data is propagated to output.
```
module check_reg_retime (input clk , input [3:0] a, input [3:0] b , output [7:0] c , input reset);

wire [7:0] mult;
assign mult = a * b;
reg [7:0] q1;
reg [7:0] q2;
reg [7:0] q3;

always @ (posedge clk , posedge reset)
begin
	if(reset)
	begin
		q1 <= 8'b0;
		q2 <= 8'b0;
		q3 <= 8'b0;
	end
	else
	begin
		q1 <= mult;
		q2 <= q1;
		q3 <= q2;
	end
end
assign c = q3;

endmodule
```
The schematic before retime

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/70c81ab7-1ed8-402e-b6a6-0a97a13518d4)

After giving constraint to the design with the given specs when we give report_timing we get violated report on the input side of design

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/69942cc8-bbf6-4c64-be1f-085c60ea0f22)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/c279844e-8996-428f-8555-07aab4314484)

In order to rectify this we retime it using following command

**compile_ultra -retime**

The violation are reduces and is now only on output path

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/cdbf2dbd-93b0-4cea-86c0-5d2e2140549a)

The multiplier used in this has the following design

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/700bc775-9cb0-4c05-8946-f0685c85339d)


**Isolating Output ports**

In VLSI isolating output ports often refers to ensuring that the output signals of a circuit or module are properly isolated and do not interfere with each other or with other parts of the system. This isolation is crucial for maintaining signal integrity, reducing noise, and preventing unintended interactions.

Output port isolation in VLSI design:

1. **Output Ports**: In VLSI design, an integrated circuit typically includes multiple output ports, which are points where the circuit provides data or information to the external world. These output ports can be connected to various external devices or other parts of the circuit.

2. **Signal Integrity**: In a complex IC, signals on different output ports may have different requirements, such as timing, voltage levels, and signal quality. Undesirable interactions between these signals can lead to signal integrity issues, including noise, glitches, and crosstalk.

3. **Output Port Isolation**: Output port isolation is the practice of designing the circuit in such a way that the signals on one output port do not interfere with or affect the signals on another output port. This is achieved by implementing various isolation techniques:

   - **Physical Separation**: Physically separating the output buffers associated with different output ports can reduce the chances of signal interference. This may involve placing output buffers in different areas of the chip or on separate metal layers.

   - **Buffer Design**: Careful selection of buffer types and configurations can help reduce interference. For example, using differential signaling (such as LVDS or differential ECL) can improve noise immunity compared to single-ended signaling.

   - **Shielding**: Adding shielding structures, such as metal layers or well-taps, around sensitive output ports can help block electromagnetic interference (EMI) and minimize crosstalk.

   - **Timing Constraints**: Properly defining and enforcing timing constraints for different output ports can prevent timing violations and ensure that signals do not overlap or cause setup and hold time violations.

Consider a below example, which contains more number of outputs to be connected after implementation of design, this may cause a violation of internal delays as cell delay is a function of load capacitance. Inorder to avoid internal failure, we isolate by inserting a buffer at output port. So, the buffer drives the external load.Now, the internal paths are decoupled from output paths.

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/abeb0616-c238-47ef-b881-0af045e2a337)

**Lab**

RTL Design code
```
module check_boundary (input clk , input res , input [3:0] val_in , output reg [3:0] val_out);
wire en;
internal_module u_im (.clk(clk) , .res(res) , .cnt_roll(en));

always @ (posedge clk , posedge res)
begin
	if(res)
		val_out <= 4'b0;
	else if(en)
		val_out <= val_in;	
end
endmodule


module internal_module (input clk , input res , output cnt_roll);
reg [2:0] cnt;

always @(posedge clk , posedge res)
begin
	if(res)
		cnt <= 3'b0;
	else
		cnt <= cnt + 1;
end

assign cnt_roll = (cnt == 3'b111);

endmodule
```
The Design before isolating the ports 

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/f5cac34c-226f-475c-9405-0f27804b643a)

The timing report before isolating ports

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/cab91262-12e8-4d5d-8d26-6ffb006d3325)

The command for isolating ports

**set_isolate_ports -type buffer \[all_outputs]**

The Design after isolating the ports
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/7dd7ea74-0d7e-4029-a071-f4612c956464)

The timing report after isolating the port

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/68bdeff5-b694-4698-9e0c-1367b2b19e6d)


**Multicycle path**

A multicycle path in design refers to a timing path within a digital circuit where a signal takes multiple clock cycles to propagate from a source register (or flip-flop) to a destination register. This is in contrast to a single-cycle path where the signal must propagate and settle within a single clock cycle.

Multicycle paths are typically encountered in digital designs when specific timing constraints or requirements allow for signals to have longer propagation delays. These paths are often used for various purposes, including achieving certain functionalities, optimizing critical paths, or accommodating variations in clocking schemes.

For a single cycle path, the setup check is done at the consecutive edge of the flop and hold is done at the same edge of the flop. Hold is always checked edge before setup. For a half cycle path, the setup check is done at the subsequent fall edge of the flop and hold is done at the previous falling edge of the flop. In a half cycle path, setup is very tight and hold is relaxed. For a multicycle path, the -setup switch specifies the number of cycles after the launch edge, it needs to check setup and the -hold switch specifies the number of cycles the launch edge moves to check with capture.

**Lab**

The RTL design code 
```
module mcp_check (input clk , input res  , input [7:0] a , input [7:0] b, input en , output reg [15:0] prod);

reg valid; 

always @ (posedge clk , posedge res)
begin
	if(res)
		valid <= 1'b0;
	else 
		valid <= en;
end
always @ (posedge clk , posedge res)
begin
	if(res)
		prod <= 16'b0;
	else if (valid)
		prod <= a * b;
end

endmodule
```
The tcl file for constraints

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/9d0ab020-0de3-40f1-98a4-acd8cd053dda)

The report before optimization

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/bbdd170d-16e3-4531-bbf6-c683b2daabc7)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/8a86403a-a3f2-4779-b230-fa9e6ab975e8)

Now using the command 

**set_multicycle_path -setup 2 -to prod_reg\[*]/D -from \[all_inputs]**

The input report timing 
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/656e8fdd-1154-403d-bde0-603e10630149)

When we give report_timing -delay min we get the violated report as we have only optimized setup path and not hold path

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/b0f1c73a-a885-4c13-aaa8-3bb81bb6b68e)

Then optimizing the hold path by the following command

set_multicycle_path -hold 1 -to prod_reg\[*]/D -from \[all_inputs] -to prod_reg\[*]/D 

report_timing after optimizing hold path
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/0c6d50bb-9aa2-4d79-8a04-87313a61460d)

But the output slack is not met , because high load on the output side
![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/070308f6-d44a-4207-87ff-27be0470f1b9)

By isolating the port we can rectify this

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/33941330-c0b5-4666-80a3-3a6df20600bf)

**FALSE PATH**

A false path constraint is a timing constraint used in design during synthesis to inform the synthesis tool that a particular path in the design should not be considered for timing analysis. False path constraints are applied to paths that are not relevant for the overall functionality or timing of the circuit, and they help improve synthesis and optimization results by excluding these paths from the timing analysis process. False path constraints are especially useful when dealing with paths that are not critical to the circuit's operation and should not be optimized for timing.

Here's how you can apply a false path constraint using Synopsys Design Constraints (SDC),  command:

**SDC Command for Applying a False Path Constraint:**

set_false_path -from <source_pins> -to <destination_pins> [-through <through_pins>]

- `set_false_path`: This command is used to specify that a particular path should be treated as a false path.

- `-from <source_pins>`: Replace `<source_pins>` with the list of source pins or elements for the path you want to designate as a false path. These are typically the output pins of certain elements in your design.

- `-to <destination_pins>`: Replace `<destination_pins>` with the list of destination pins or elements for the path you want to designate as a false path. These are typically the input pins of certain elements in your design.

- `-through <through_pins>` (optional): If you want to specify that the path is a false path only when it goes through specific pins or elements, you can use this option to specify those pins or elements.

**Explanation:**
A false path constraint is applied to tell the synthesis tool and timing analysis tools (like static timing analyzers) that a particular path should be ignored during timing analysis. This means that the tools will not consider this path when calculating setup times, hold times, or other timing characteristics.

False paths are often used for the following reasons:

1. **Irrelevant Paths**: In complex designs, there may be paths that are not critical for the circuit's operation, such as debug paths, bypass paths, or paths that are intentionally designed for slower operation. Applying a false path constraint allows you to exclude these paths from timing analysis.

2. **Optimization Control**: By marking certain paths as false paths, you can prevent the synthesis tool from applying aggressive optimization techniques that might negatively impact the circuit's performance. This is especially useful when dealing with sensitive paths that should not be overly optimized.

3. **Tool Efficiency**: Excluding non-critical paths from timing analysis can improve tool efficiency and reduce analysis time, especially in large designs.

 Apply a false path constraint in SDC:

tcl
# Specify that the path from the output "output_reg" to the input "input_reg" is a false path
set_false_path -from \[get_pins output_reg/Q] -to \[get_pins input_reg/D]


In this example, the `output_reg` and `input_reg` represent the source and destination registers of the false path, respectively. The `-from` and `-to` options specify the pins of these registers. By applying this false path constraint, you inform the synthesis tool that this particular path should not be considered for timing analysis, helping you achieve better control and optimization of your design.
</details>


## Day-10-Quality Checks

<details>
 <summary> Introduction </summary>

**Sanity checks:**

Sanity checks in VLSI serve as a checkpoint to decide whether the testing for design-build may proceed or not. The main purpose of this testing is to ensure that the changes or planned features are operating as intended. To ensure that the input received from the library team and synthesis team is correct or not. If we are not doing these checks then it creates problems in later stages of design.

      Design/netlist checks
      SDC checks
     Library checks

Design checks:
To check if current design is consistent or not
It checks the quality of netlist and identifies:
      
       Undriven input ports
       Unloaded outputs
       Floating pins
       Multidriven nets 
       Unconstrained pins 
       Pin mismatch counts between an instance and its reference
       Tristate buses with non-tristate drivers
       Wire loops across hierarchies
 
 **check_design** command 
 
Checks for multi driven nets, floating nets/pins, empty modules.
Pins mismatch, cells or instances without I/O pins/ports etc. 

SDC Checks:

* If any unconstrained paths exist in the design then PNR tool will not optimize that path, so these checks are used to report unconstrained paths 
* Checks whether the clock is reaching to all the clock pin of the flip-flop.
* Check if multiple clock are driving same registers
* Check unconstrained endpoints 
* Port missing input/output delay.
* Port missing slew/load constraints.

**check_timing** command

Library checks:

It checks the quality of Physical and logical library

**check_library**
This command shows the library type & its version, units of time, capacitance, leakage power, and current. It shows the number of cells missing, the number of metal or pins missing in the physical and logical library.


**Propagation Delay :**
Propagation delay, in the context of digital electronics and integrated circuits, refers to the time it takes for an electrical signal to travel from the input of a digital logic gate or circuit to its output. It is a critical parameter in digital design because it affects the speed and performance of the circuit. Propagation delay is typically measured in time units, such as nanoseconds (ns) or picoseconds (ps), and it depends on various factors, including the specific technology used, the length of interconnecting wires, and the complexity of the circuit.

**Rising Edge Propagation Delay (tplh)**: This is the time it takes for the output signal to transition from a low (0) to a high (50% of Vdd crossing) level after the input signal has made a similar transition.

**Falling Edge Propagation Delay (tphl)**: This is the time it takes for the output signal to transition from a high (50% of Vdd crossing) to a low (0) level after the input signal has made a similar transition.

##Some Command Usage


Before using those commands some basic steps

In Design Compiler tool  we load our design, and we check the design

Ensure that you have compiled your design with the necessary constraints files.

Run the timing analysis by entering the **report_timing** command in the Design Compiler command-line interface. Here's a basic syntax:

   report_timing -from <source> -to <destination>
   
   You can also add additional options and constraints to refine the analysis, such as specifying clock constraints, input delays, and output delays.

 **View the Report**: Design Compiler will generate a timing report that includes information about setup time, hold time, clock-to-q delays, and more. You can view this report in the shell or append it to a file for complete scenario

Here's a simplified example of how to use the `report_timing` command:


# Analyze the timing from input signal A to output signal Z
report_timing -from A -to Z

By using the `report_timing` command, you can look for timing violations and make necessary optimizations to meet your design's timing requirements, ensuring that it is functioning correctly at the specified clock frequency.

The `report_timing` command in Synopsys Design Compiler is a powerful tool for analyzing the timing characteristics of a synthesized digital design. It provides various options to specify which timing paths or constraints you want to analyze. Let's break down the key options you mentioned:

1. `-from <source>`: Start point for timing analysis. You can use a specific signal name or a logical expression to define the source. For example:

  **report_timing -from input_IN**

   This command will analyze timing paths starting from the signal named input_IN.

3. `-to <destination>`: This option specifies the destination signal or path up to which you want to analyze timing. Similar to the `-from` option, you can use a signal name or logical expression. For example:

 **report_timing -to output_OUT**

  This command will analyze timing paths up to the signal named `output_Z`.

**-fall_from <source>` and `-rise_from <source>** These options allow you to specify whether you want to analyze falling-edge or rising-edge timing paths from the given source. Timing analysis often considers both rising and falling edges of a clock signal, so you can use these options to focus on one edge if needed. For example:

   report_timing -fall_from clk -to output_Q

   This command will analyze falling-edge timing paths from the clock signal to the output signal output_Q.

`-delay_type max/min`: These options specify whether you want to report the maximum or minimum delay for the timing paths being analyzed. Depending on your design goals, you may want to optimize for maximum delay (worst-case performance) or minimum delay (best-case performance). For example:

   report_timing -from input_IN -to output_OUT -delay_type max
   
This command will report the maximum delay from `input_IN` to `output_OUT`.

Now, let's combine these options in a more comprehensive example:

```
# Analyze the maximum falling-edge delay from input IN to output OUT
report_timing -fall_from input_A -to output_Z -delay_type max
```

In this command, we are specifically interested in the worst-case (maximum) falling-edge delay from input_IN to output_OUT. This information can help identify critical timing paths that may need optimization to meet your design's performance requirements.

By using various combinations of these options, you can customize your timing analysis to focus on specific aspects of your design and identify potential timing violations or optimization opportunities.

The `report_timing` command with the `-max paths -nworst` options in Synopsys Design Compiler is used to report the paths with the maximum (worst-case) timing delays in a digital design. This command is particularly useful for identifying the most critical timing paths in your design, which can be crucial for meeting your design's performance requirements. Let's break down this command and explain its usage:


`report_timing`: This is the main command for timing analysis in Design Compiler.

`-max paths`: This option instructs Design Compiler to report the paths with maximum delays. 

`-nworst`: This option specifies how many of the worst-case paths you want to report. You can specify a numerical value to limit the number of paths reported. For example, `-nworst 3` will report the 3 sluggiest paths.


   ```shell
   report_timing -max paths -nworst <number_of_paths>
   ```

<number_of_paths> : Specify the number of worst-case paths you want to report.

4. **View the Report**: Design Compiler will generate a report listing the specified number of paths with the longest delays. This report will include information about the paths' starting points, ending points, and the timing constraints.

 To use the `report_timing -max paths -nworst` command:

```shell
# Report the 5 worst-case timing paths in the design
report_timing -max paths -nworst 5
```

In this example, the command will identify and report the five paths in your design with the maximum delays. Helps in location critical paths in your design that may require optimization 

By using the `-max paths -nworst` options, you can quickly focus on the most critical timing paths in your design, allowing you to prioritize optimization efforts and make informed decisions about your design's overall performance.

 **Report Many Critical Paths**:

   ```shell
   # Report the 20 worst-case timing paths in the design
   report_timing -max paths -nworst 20
   ```
</details>

<details>
 <summary> LABs </summary>

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/d4c10d72-f176-437c-8445-285de2905cff)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/11f9cd6f-cf0d-4de4-bcc0-e58309184568)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/67800a72-fc3b-4c87-8615-581ab3f3eaaf)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/f280b6b0-7c6f-48fc-91d4-c2bd5c694270)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/eaf62a75-567a-4866-9edf-ca993c5b18ee)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/9c13f691-7931-4e2e-964c-e2f1f2d8ef13)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/b1a6aeda-0002-485e-81d1-afdd35cd72c3)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/27776866-b4a9-4040-a35f-18c7e938fd5f)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/509e8789-23d9-46b6-8efa-a687df30f143)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/bfee4a44-7d76-4062-95ef-d95325bff53a)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/f303d70a-68e6-464f-a408-1ca21b0de225)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/56d946cf-d648-45ec-8165-35b39c58d0ff)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/1f6dbaa9-ee36-4291-b1e2-fb9f9515c8a5)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/7ecfc2fd-754e-4cd5-872b-d658f59b5b61)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/a3d33dd4-a49e-4805-b13a-e5e3cf1fd74f)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/25c34e32-4698-49e7-b67a-94eaaecf6c18)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/4a632416-1375-4bd0-97e3-afda4e6b7c2c)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/c13bd022-5499-4e2e-bb1b-714c668f0785)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/b52bdb5b-8e60-4d47-bf83-ba6c037b0ca7)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/fb5d85a5-4c1b-4b78-9f6e-7eee425abbd2)

![image](https://github.com/Avi991/Samsung-PD-training-/assets/142480104/6b67bba0-d0bf-43e8-b99d-e29397ec5e00)

</details>

## Day-11 SOC
 <details>
 <summary>SoC</summary>
**Describing chip used in Oneplus Nord CE 2 LITE is Snapdragon 695**

The Qualcomm Snapdragon 695 is a mid-range mobile system-on-a-chip (SoC) designed and manufactured by Qualcomm. It was announced in 2021 and was part of Qualcomm's Snapdragon 6-series, which is known for offering a good balance between performance and power efficiency.

**CPU Architecture:**
The Snapdragon 695 features a  Qualcomm Kryo 619 CPU, which is an octa-core processor.It features 8 Kryo 660 called cores (64-Bit capable) that are divided in two clusters. A fast cluster of two cores with up to 2.2 GHz based on the ARM Cortex-A78 design. Compared to the previous SD690, the SD695 is now manufactured in 6nm (instead of 8nm) and offers a higher clocked performance cluster. However, the SD695 only supports Wi-Fi 5 instead of Wi-Fi 6 of the SD690.  It's divided into two clusters:

 **1x high-performance core**: This core is designed to handle demanding tasks and offers high single-threaded performance.
 **1x power-efficient core**: This core is optimized for power efficiency to handle light tasks and improve battery life.
 **6x power-efficient cores**: These cores are used for general-purpose computing and background tasks, balancing performance and efficiency.

**GPU:**
he Qualcomm Adreno 619 is a mobile graphics card for mid-range smartphones and tablets (mostly Android based). It is included in the Qualcomm Snapdragon 750G SoCs and based on the Adreno 600 architecture (like the Adreno 630, which should be fully compatible in software). The performance is 60% better compared to the Adreno 612 graphics card and in our benchmarks on par with the 700 series cards.

**Connectivity:**
In addition to the 8 CPU cores, the SoC integrates a lower mid range Adreno 619 GPU, a X51 5G radio (up to 2.5 Gbits download, no mmWave), a 802.11ac (Wi-Fi 5, 8x8 sounding, Dual Band, 2x2), a Bluetooth 5.2 radio, satellite positioning (GPS, QZSS, GLONASS, SBAS, Beidou and Galileo) and a video engine (support for H.265, H.264, VP8 and VP9).

**AI and Machine Learning:**
The Snapdragon 695 includes an AI Engine that supports on-device AI and machine learning tasks.long-standing prowess in AI is thoughtfully incorporated into the Snapdragon 695, steering enhancements from smart imaging techniques to predictive user-interface responses.It can handle functions like image recognition, voice recognition, and various AI-driven enhancements for camera and gaming experiences.

**Camera and Multimedia:**
The SoC supports cameras with impressive capabilities. It can handle up to a 108-megapixel single camera or a 36-megapixel dual-camera setup. It also supports 4K video capture and playback, HDR10+ content, and HEIF image format for efficient storage.

**Display Support:**
The Snapdragon 695 supports Full HD+ displays with high refresh rates, making it suitable for mid-range smartphones with smooth and responsive screens.

**Battery Efficiency:**
Qualcomm's chipsets are known for their power efficiency, and the Snapdragon 695 is no exception. The combination of CPU and GPU cores, AI optimizations, and the integrated 5G modem is designed to strike a balance between performance and battery life.

**Manufacturing Process:**
Depending on the exact model of processor CPUs are built using 6nm tech node
</details>

## Day-11 SOC
 <details>
 <summary>BabySOC MODEL</summary>

 **RTL code for UP_COUNTER**

```
module up_counter (input clk , input reset, output reg [2:0] count);
always @ (posedge clk , posedge reset)
begin
	if(reset)
		count <= 4'b000;
	else
		count <= count + 1;
end
endmodule
```
**TEST BENCH for UP_COUNTER**

```
`timescale 1ns / 1ps
module tb_upcounter;
	reg clk, reset;
	wire [2:0] count;

      	up_counter uut (
		.clk(clk),
		.reset(reset),
		.count(count)
	);

	initial begin
	$dumpfile("tb_upcounter.vcd");
	$dumpvars(0,tb_upcounter);
        clk = 0;
	reset = 1;
	#2000 $finish;
	end

always #10 clk = ~clk;
always #100 reset=0;
endmodule
```
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/66ea92aeb518fad0ed29622de9034fe2189ab2cc/Samsung_PD_%23day11/4(up%20counter).png">

**DAC**
TO model DAC commands used :-

```
iverilog avsddac.v avsddac_tb_test.v
./a.out
gtkwave avsddac_tb_test.vcd
```
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/66ea92aeb518fad0ed29622de9034fe2189ab2cc/Samsung_PD_%23day11/2(dac%20wave%20sim).png">

**PLL**
 
To model PLL commands used are:-
```
iverilog avsd_pll_1v8.v pll_tb.v
./a.out
gtkwave test.vcd
```
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/66ea92aeb518fad0ed29622de9034fe2189ab2cc/Samsung_PD_%23day11/1(pll%20wave%20sim).png">

**RVMYTH**
For rvmyth following is the command:-
	
```
iverilog mythcore_test.v tb_mythcore_test.v 
./a.out
gtkwave tb_mythcore_test.vcd
```
```
[aviral.s@ssirlab03 module]$ iverilog mythcore_test.v tb_mythcore_test.v 
[aviral.s@ssirlab03 module]$ ./a.out
VCD info: dumpfile tb_mythcore_test.vcd opened for output.
[aviral.s@ssirlab03 module]$ gtkwave tb_mythcore_test.vcd
```
<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/66ea92aeb518fad0ed29622de9034fe2189ab2cc/Samsung_PD_%23day11/3(mythcore%20wave%20simn).png">

**VSDBABY SOC TOP MODULE**

Interfacing all the modules following is the command:-
```
iverilog vsdbabysoc.v testbench.v avsdpll.v avsddac.v mythcore_test.v
./a.out
gtkwave dump.vcd
```
```
[aviral.s@ssirlab03 module]$ iverilog vsdbabysoc.v testbench.v avsdpll.v avsddac.v mythcore_test.v
[aviral.s@ssirlab03 module]$ ./a.out
VCD info: dumpfile dump.vcd opened for output.
[aviral.s@ssirlab03 module]$ gtkwave dump.vcd
```

<img width="1085" alt="lib1" src="https://github.com/Avi991/Samsung-PD-training-/blob/66ea92aeb518fad0ed29622de9034fe2189ab2cc/Samsung_PD_%23day11/4(soc%20wave%20sim).png">
